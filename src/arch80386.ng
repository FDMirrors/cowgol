%{
	#include "globals.h"
	#include "emitter.h"
	#include "midcodes.h"
	#include "compiler.h"
	#include "parser.h"
	#include <bsd/string.h>
	#include <ctype.h>

	#define IMPL
	#include "codegen.h"

	#define E emitter_printf
	static char asmbuffer[80];

	static int id = 1;
	static Symbol* uint32_type;
	static Symbol* int32_type;
	static Symbol* int16_type;
	static Symbol* uint16_type;
	static Symbol* int8_type;

	void arch_init_types(void)
	{
		uint32_type = make_number_type("uint32", 4, false);
		int32_type = make_number_type("int32", 4, true);
		uint16_type = make_number_type("uint16", 2, false);
		int16_type = make_number_type("int16", 2, true);
		uint8_type = make_number_type("uint8", 1, false);
		int8_type = make_number_type("int8", 1, true);

		intptr_type = uint32_type;
		add_alias(NULL, "intptr", intptr_type);
	}

	uint32_t arch_align_up(uint32_t value, uint8_t alignment)
	{
		return value;
	}

	Symbol* arch_guess_int_type(uint32_t min, uint32_t max)
	{
		if ((min >= 0) && (max <= 255))
			return uint8_type;
		if ((min >= -128) && (max <= 127))
			return int8_type;
		if ((min >= 0) && (max <= 65535))
			return uint16_type;
		if ((min >= -32768) && (max <= 32767))
			return int16_type;
		if (min >= 0)
			return uint32_type;
		return int32_type;
	}

	void arch_init_subroutine(struct subroutine* sub) {}

	void arch_init_variable(struct symbol* var)
	{
		/* All variables get allocated from workspace 0. */
		var->u.var.offset = current_sub->workspace[0];
		current_sub->workspace[0] += var->u.var.type->u.type.width;
	}

	void arch_init_member(struct symbol* record, struct symbol* member, int position)
	{
		if (position == -1)
			position = record->u.type.width;
		member->u.var.offset = position;
		position += member->u.var.type->u.type.width;
		if (position > record->u.type.width)
			record->u.type.width = position;
	}

	static const char* regref(reg_t reg)
	{
		switch (reg)
		{
			case REG_EAX: return "%eax";
			case REG_EBX: return "%ebx";
			case REG_ECX: return "%ecx";
			case REG_EDX: return "%edx";
			case REG_ESI: return "%esi";
			case REG_EDI: return "%edi";
			case REG_AX: return "%ax";
			case REG_BX: return "%bx";
			case REG_CX: return "%cx";
			case REG_DX: return "%dx";
			case REG_SI: return "%si";
			case REG_DI: return "%di";
			case REG_AL: return "%al";
			case REG_BL: return "%bl";
			case REG_CL: return "%cl";
			case REG_DL: return "%dl";
			default: fatal("unknown register id 0x%x", reg);
		}
	}

	static const char* stkref(reg_t reg)
	{
		switch (reg)
		{
			case REG_EAX: return "%eax";
			case REG_EBX: return "%ebx";
			case REG_ECX: return "%ecx";
			case REG_EDX: return "%edx";
			case REG_ESI: return "%esi";
			case REG_EDI: return "%edi";
			case REG_AL: case REG_AX: return "%ax";
			case REG_BL: case REG_BX: return "%bx";
			case REG_CL: case REG_CX: return "%cx";
			case REG_DL: case REG_DX: return "%dx";
			case REG_SI: return "%si";
			case REG_DI: return "%di";
			default: fatal("unknown register id 0x%x", reg);
		}
	}

	static const char* byteregref(reg_t reg)
	{
		switch (reg)
		{
			case REG_AL: case REG_AX: case REG_EAX: return "%al";
			case REG_BL: case REG_BX: case REG_EBX: return "%bl";
			case REG_CL: case REG_CX: case REG_ECX: return "%cl";
			case REG_DL: case REG_DX: case REG_EDX: return "%dl";
			default: fatal("unknown register id 0x%x", reg);
		}
	}

	static const char* wordregref(reg_t reg)
	{
		switch (reg)
		{
			case REG_AL: case REG_AX: case REG_EAX: return "%ax";
			case REG_BL: case REG_BX: case REG_EBX: return "%bx";
			case REG_CL: case REG_CX: case REG_ECX: return "%cx";
			case REG_DL: case REG_DX: case REG_EDX: return "%dx";
			default: fatal("unknown register id 0x%x", reg);
		}
	}

	static const char* longregref(reg_t reg)
	{
		switch (reg)
		{
			case REG_AL: case REG_AX: case REG_EAX: return "%eax";
			case REG_BL: case REG_BX: case REG_EBX: return "%ebx";
			case REG_CL: case REG_CX: case REG_ECX: return "%ecx";
			case REG_DL: case REG_DX: case REG_EDX: return "%edx";
			default: fatal("unknown register id 0x%x", reg);
		}
	}

	static const char* subref(Subroutine* sub)
	{
		if (sub->externname)
			return sub->externname;
		
		static char buffer[32];
		snprintf(buffer, sizeof(buffer), "f%d", sub->id);
		return buffer;
	}

	static const char* symref(Symbol* sym, int32_t off)
	{
		static char buffer[32];
		if (sym->u.var.externname)
			snprintf(buffer, sizeof(buffer), "(%s+%d)",
				sym->u.var.externname, off);
		else
			snprintf(buffer, sizeof(buffer), "(w%d+%d)",
				sym->u.var.sub->id,
				sym->u.var.offset + off);
		return buffer;
	}

	static const char* labelref(int label)
	{
		static char buffer[32];
		snprintf(buffer, sizeof(buffer), "x%d", label);
		return buffer;
	}

	/* Note! This is allowed to destroy the source register. */
	void arch_emit_move(reg_t src, reg_t dest)
	{
		if (!src)
			E("\tpop %s\n", stkref(dest));
		else if (!dest)
			E("\tpush %s\n", stkref(src));
		else
			E("\tmov %s, %s\n", regref(src), regref(dest));
	}

	void arch_emit_comment(const char* text, ...)
	{
		va_list ap;
		va_start(ap, text);
		emitter_printf("\t# ");
		emitter_vprintf(text, ap);
		emitter_printf("\n");
		va_end(ap);
	}
%}

register eax ebx ecx edx esi edi;
register ax bx cx dx si di;
register al ah bl bh cl ch dl dh;
register stk4 param;

regclass r8 := al|bl|cl|dl;
regclass r16 := ax|bx|cx|dx|si|di;
regclass r32 := eax|ebx|ecx|edx|esi|edi;
regclass ri := ebx|esi|edi;
regclass allregs := r8|r16|r32|ri;

regdata eax compatible r32    uses eax|ax|al;
regdata ebx compatible r32|ri uses ebx|bx|bl;
regdata ecx compatible r32    uses ecx|cx|cl;
regdata edx compatible r32    uses edx|dx|dl;
regdata esi compatible r32|ri;
regdata edi compatible r32|ri;
regdata ax compatible r16     uses eax|ax|al;
regdata bx compatible r16     uses ebx|bx|bl;
regdata cx compatible r16     uses ecx|cx|cl;
regdata dx compatible r16     uses edx|dx|dl;
regdata si compatible r16;
regdata di compatible r16;
regdata al compatible r8      uses eax|ax|al;
regdata bl compatible r8      uses ebx|bx|bl;
regdata cl compatible r8      uses ecx|cx|cl;
regdata dl compatible r8      uses edx|dx|dl;
regdata stk4 stacked;
regdata param stacked;

gen STARTFILE()
{
    emitter_open_chunk();
	E("\t.code32\n");
    emitter_close_chunk(NULL);
}

gen ENDFILE();

gen STARTSUB():s
{
    emitter_open_chunk();
    E("\n");
    E("# %s\n", $s.sub->name);
    E("\t.text\n");
    if ($s.sub->externname)
        E("\t.global %s\n", $s.sub->externname);
    E("\t.global %s\n", subref($s.sub));
    E("%s:\n", subref($s.sub));

    if ($s.sub->inputparameters != 0)
    {
        E("\tpopl %%eax\n");
        for (int i=$s.sub->inputparameters-1; i>=0; i--)
        {
			Symbol* param = get_input_parameter($s.sub, i);

			const char* insn = "popw";
			int w = param->u.var.type->u.type.width;
			switch (w)
			{
				case 1:
					E("\tpopw %%bx\n");
					E("\tmovb %%bl, %s\n", symref(param, 0));
					break;

				case 4:
					insn = "popl";
					/* fall through */
				case 2:
					E("\t%s %s\n", insn, symref(param, 0));
					break;
			}
        }
        E("\tpushl %%eax\n");
    }
}

gen ENDSUB():s
{
	E("end_%s:\n", subref($s.sub));
	if ($s.sub->outputparameters != 0)
	{
		E("\tpopl %%eax\n");

		for (int i=0; i<$s.sub->outputparameters; i++)
		{
			struct symbol* param = get_output_parameter($s.sub, i);

			const char* insn = "pushw";
			if (param->u.var.type->u.type.width == 4)
				insn = "pushl";
			E("\t%s %s\n", insn, symref(param, 0));
		}

		E("\tjmp *%%eax\n");
	}
	else
		E("\tret\n");

    E("\t.bss\n");
	E("w%d:\n", $s.sub->id);
	if ($s.sub->workspace[0] != 0)
		E("\t.space %d\n", $s.sub->workspace[0]);
    emitter_close_chunk(current_sub);
}

// --- Control flow ------------------------------------------------------

gen RETURN()
{
	E("\tjmp end_%s\n", subref(current_sub));
}

gen LABEL():b
{
	E("%s:\n", labelref($b.label));
}

gen JUMP():j
{
	E("\tjmp %s\n", labelref($j.label));
}

// --- Subroutines -------------------------------------------------------

// SETPARAM leaves the parameter on the top of the stack, where the
// code generator loses track of it.

gen param := END();

gen param := PUSHPARAM1(param, r8:val)
	{ E("\tpushw %s\n", stkref($val)); }

gen param := PUSHPARAM2(param, r16:val)
	{ E("\tpushw %s\n", stkref($val)); }

gen param := PUSHPARAM4(param, r32:val)
	{ E("\tpushl %s\n", stkref($val)); }

gen param := PUSHPARAM4(param, LOAD4(ADDRESS():a))
	{ E("\tpushl (%s)\n", symref($a.sym, $a.off)); }

gen param := PUSHPARAM4(param, ADDRESS():a)
	{ E("\tpushl $%s\n", symref($a.sym, $a.off)); }

gen param := PUSHPARAM1(param, CONSTANT():c)
	{ E("\tpushw $0x%x\n", $c.value & 0xff); }

gen param := PUSHPARAM2(param, CONSTANT():c)
	{ E("\tpushw $0x%x\n", $c.value & 0xffff); }

gen param := PUSHPARAM4(param, CONSTANT():c)
	{ E("\tpushl $0x%x\n", $c.value); }

%{
	static void call(Subroutine* sub)
	{
		if (sub->externname)
		{
			emitter_open_chunk();
			E("\t.extern %s\n", sub->externname);
			emitter_close_chunk(current_sub);
		}

		arch_emit_comment("subroutine with %d input parameters", sub->inputparameters);
		E("\tcall %s\n", subref(sub));
	}

	static void calln(Subroutine* sub, reg_t reg)
	{
		call(sub);
		E("\tpop %s\n", stkref(reg));
	}
%}

gen CALLS(param);

gen param := CALL0(param):c uses allregs
	{ call($c.sub); }

gen al := CALL1(param):c uses ebx|ecx|edx|esi|edi
	{ calln($c.sub, $$); }

gen ax := CALL2(param):c uses ebx|ecx|edx|esi|edi
	{ calln($c.sub, $$); }

gen eax := CALL4(param):c uses ebx|ecx|edx|esi|edi
	{ calln($c.sub, $$); }

%{
	static void popparam(Symbol* sym, int32_t off)
	{
		const char* ins = "popw";
		switch (sym->u.var.type->u.type.width)
		{
			case 1:
				E("\tpopw %%ax\n");
				E("\tmovb %%al, %s\n", symref(sym, off));
				break;

			case 4:
				ins = "popl";
				/* fall through */
			case 2:
				E("\t%s %s\n", ins, symref(sym, off));
				break;

			default: assert(false);
		}
	}
%}

rewrite POPPARAM1(p, a) := POPPARAM4(p, a);
rewrite POPPARAM2(p, a) := POPPARAM4(p, a);

gen POPPARAM4(param, ADDRESS():a) uses eax
	{ popparam($a.sym, $a.off); }

gen param := POPPARAM4(param, ADDRESS():a) uses eax
	{ popparam($a.sym, $a.off); }

// --- Core conversions --------------------------------------------------

gen r8 := CONSTANT(value == 0)
	{ E("\txorb %s, %s\n", regref($$), regref($$)); }

gen r8 := CONSTANT(): c
	{ E("\tmovb $0x%x, %s\n", $c.value & 0xff, regref($$)); }

gen r16 := CONSTANT(value == 0)
	{ E("\txorw %s, %s\n", regref($$), regref($$)); }

gen r16 := CONSTANT():c
	{ E("\tmovw $0x%x, %s\n", $c.value & 0xffff, regref($$)); }

gen r32 := CONSTANT(value == 0)
	{ E("\txorl %s, %s\n", regref($$), regref($$)); }

gen r32 := CONSTANT():c
	{ E("\tmov $0x%x, %s\n", $c.value, regref($$)); }

gen r32 := ADDRESS():a
	{ E("\tlea %s, %s\n", symref($a.sym, $a.off), regref($$)); }

// --- Loads and stores --------------------------------------------------

gen r8 := LOAD1(r32:lhs)
	{ E("\tmovb (%s), %s\n", regref($lhs), regref($$)); }
	
gen r8 := LOAD1(ADDRESS():a)
	{ E("\tmovb %s, %s\n", symref($a.sym, $a.off), regref($$)); }
	
gen r8 := LOAD1(ADD4(r32: addr, r32: disp))
	{ E("\tmovb (%s,%s), %s\n", regref($addr), regref($disp), regref($$)); }

gen r8 := LOAD1(ADD4(r32: addr, CONSTANT():c))
	{ E("\tmovb %d(%s), %s\n", $c.value, regref($addr), regref($$)); }

gen r16 := LOAD2(r32:lhs)
	{ E("\tmovw (%s), %s\n", regref($lhs), regref($$)); }

gen r16 := LOAD2(ADDRESS():a)
	{ E("\tmovw %s, %s\n", symref($a.sym, $a.off), regref($$)); }
	
gen r32 := LOAD4(r32:lhs)
	{ E("\tmov (%s), %s\n", regref($lhs), regref($$)); }

gen r32 := LOAD4(ADDRESS():a)
	{ E("\tmov %s, %s\n", symref($a.sym, $a.off), regref($$)); }
	
gen STORE1(r8:val, r32:addr)
	{ E("\tmovb %s, (%s)\n", regref($val), regref($addr)); }

gen STORE1(r8:val, ADDRESS():a)
	{ E("\tmovb %s, %s\n", regref($val), symref($a.sym, $a.off)); }

gen STORE1(r8:val, ADD4(r32:addr, r32:disp))
	{ E("\tmovb %s, (%s,%s)\n", regref($val), regref($addr), regref($disp)); }
	
gen STORE1(r8:val, ADD4(r32:addr, CONSTANT():c))
	{ E("\tmovb %s, %d(%s)\n", regref($val), $c.value, regref($addr)); }

gen STORE2(r16:val, r32:addr)
	{ E("\tmovw %s, (%s)\n", regref($val), regref($addr)); }

gen STORE2(r16:val, ADDRESS():a)
	{ E("\tmovw %s, %s\n", regref($val), symref($a.sym, $a.off)); }

gen STORE4(r32:val, r32:addr)
	{ E("\tmov %s, (%s)\n", regref($val), regref($addr)); }

gen STORE4(r32:val, ADDRESS():a)
	{ E("\tmov %s, %s\n", regref($val), symref($a.sym, $a.off)); }

// --- Casts ----------------------------------------------------------------

gen r8 := CAST21(r16:val)
	{ E("\tmovb %s, %s\n", byteregref($val), regref($$)); }

gen r8 := CAST41(r32:val)
	{ E("\tmovb %s, %s\n", byteregref($val), regref($$)); }

gen r16 := CAST42(r32:val)
	{ E("\tmovw %s, %s\n", wordregref($val), regref($$)); }

gen r16 := CAST12(r8:val):c
	{ E("\tmov%cx %s, %s\n", $c.sext ? 's' : 'z', regref($val), longregref($$)); }

gen r32 := CAST14(r8:val):c
	{ E("\tmov%cx %s, %s\n", $c.sext ? 's' : 'z', regref($val), longregref($$)); }

gen r32 := CAST24(r16:val):c
	{ E("\tmov%cx %s, %s\n", $c.sext ? 's' : 'z', regref($val), longregref($$)); }

// --- 8-bit arithmetic -----------------------------------------------------

gen r8 := ADD1(r8:lhs, $$:rhs)
	{ E("\taddb %s, %s\n", regref($lhs), regref($$)); }

gen r8 := ADD1($$, CONSTANT():c)
	{ E("\taddb $0x%x, %s\n", $c.value & 0xff, regref($$)); }

gen r8 := ADD1($$, CONSTANT(value==1))
	{ E("\tincb %s\n", regref($$)); }
	
gen r8 := ADD1($$, CONSTANT(value==-1))
	{ E("\tdecb %s\n", regref($$)); }

gen r8 := SUB1($$:lhs, r8:rhs)
	{ E("\tsubb %s, %s\n", regref($rhs), regref($$)); }

gen r8 := SUB1($$, CONSTANT():c)
	{ E("\tsubb $0x%x, %s\n", $c.value & 0xff, regref($$)); }

gen r8 := NEG1($$:val)
	{ E("\tnegb %s\n", regref($$)); }

gen al := MUL1(r8:rhs, al)
	{ E("\timulb %s\n", regref($rhs)); }

gen al := DIVU1(al, bl|cl|dl:rhs)
{
	E("\txor %%ah, %%ah\n");
	E("\tdivb %s\n", regref($rhs));
}

gen al := REMU1(al, bl|cl|dl:rhs)
{
	E("\txor %%ah, %%ah\n");
	E("\tdivb %s\n", regref($rhs));
	E("\tmov %%ah, %%al\n");
}

gen al := DIVS1(al, bl|cl|dl:rhs)
{
	E("\tcbw\n");
	E("\tidivb %s\n", regref($rhs));
}

gen al := REMS1(al, bl|cl|dl:rhs)
{
	E("\tcbw\n");
	E("\tidivb %s\n", regref($rhs));
	E("\tmov %%ah, %%al\n");
}

gen r8 := AND1($$:lhs, r8:rhs)
	{ E("\tandb %s, %s\n", regref($rhs), regref($$)); }

gen r8 := AND1($$:lhs, CONSTANT():c)
	{ E("\tandb $0x%02x, %s\n", $c.value & 0xff, regref($$)); }

gen r8 := OR1($$:lhs, r8:rhs)
	{ E("\torb %s, %s\n", regref($rhs), regref($$)); }

gen r8 := OR1($$:lhs, CONSTANT():c)
	{ E("\torb $0x%02x, %s\n", $c.value & 0xff, regref($$)); }

gen r8 := EOR1($$:lhs, r8:rhs)
	{ E("\txorb %s, %s\n", regref($rhs), regref($$)); }

gen r8 := EOR1($$:lhs, CONSTANT():c)
	{ E("\txorb $0x%02x, %s\n", $c.value & 0xff, regref($$)); }

gen r8 := NOT1($$:val)
	{ E("\tnotb %s\n", regref($$)); }

gen r8 := LSHIFT1($$:lhs, cl:rhs)
	{ E("\tshlb %s, %s\n", regref($rhs), regref($$)); }

gen r8 := RSHIFTU1($$:lhs, cl:rhs)
	{ E("\tshrb %s, %s\n", regref($rhs), regref($$)); }

gen r8 := RSHIFTS1($$:lhs, cl:rhs)
	{ E("\tsarb %s, %s\n", regref($rhs), regref($$)); }

// --- 16-bit arithmetic ----------------------------------------------------

gen r16 := ADD2(r16:lhs, $$:rhs)
	{ E("\taddw %s, %s\n", regref($lhs), regref($$)); }

gen r16 := ADD2($$, CONSTANT():c)
	{ E("\taddw $0x%x, %s\n", $c.value & 0xffff, regref($$)); }

gen r16 := ADD2($$, CONSTANT(value==1))
	{ E("\tincw %s\n", regref($$)); }
	
gen r16 := ADD2($$, CONSTANT(value==-1))
	{ E("\tdecw %s\n", regref($$)); }

gen r16 := SUB2($$:lhs, r16:rhs)
	{ E("\tsubw %s, %s\n", regref($rhs), regref($$)); }

gen r16 := SUB2($$, CONSTANT():c)
	{ E("\tsubw $0x%x, %s\n", $c.value & 0xffff, regref($$)); }

gen r16 := NEG2($$:val)
	{ E("\tnegw %s\n", regref($$)); }

gen r16 := MUL2(r16:lhs, $$)
	{ E("\timulw %s, %s\n", regref($lhs), regref($$)); }

gen ax := DIVU2(ax, bx|cx:rhs) uses dx
{
	E("\txorw %%dx, %%dx\n");
	E("\tdivw %s\n", regref($rhs));
}

gen dx := REMU2(ax, bx|cx:rhs)
{
	E("\txorw %%dx, %%dx\n");
	E("\tdivw %s\n", regref($rhs));
}

gen ax := DIVS2(ax, bx|cx:rhs) uses dx
{
	E("\tcwd\n");
	E("\tidivw %s\n", regref($rhs));
}

gen dx := REMS2(ax, bx|cx:rhs)
{
	E("\tcwd\n");
	E("\tidivw %s\n", regref($rhs));
}

gen r16 := AND2($$:lhs, r16:rhs)
	{ E("\tandw %s, %s\n", regref($rhs), regref($$)); }

gen r16 := OR2($$:lhs, r16:rhs)
	{ E("\torw %s, %s\n", regref($rhs), regref($$)); }

gen r16 := EOR2($$:lhs, r16:rhs)
	{ E("\txorw %s, %s\n", regref($rhs), regref($$)); }

gen r16 := NOT2($$:val)
	{ E("\tnotw %s\n", regref($$)); }

gen r16 := LSHIFT2($$:lhs, cl:rhs)
	{ E("\tshlw %s, %s\n", regref($rhs), regref($$)); }

gen r16 := RSHIFTU2($$:lhs, cl:rhs)
	{ E("\tshrw %s, %s\n", regref($rhs), regref($$)); }

gen r16 := RSHIFTS2($$:lhs, cl:rhs)
	{ E("\tsarw %s, %s\n", regref($rhs), regref($$)); }

// --- 32-bit arithmetic ----------------------------------------------------

gen r32 := ADD4(r32:lhs, $$:rhs)
	{ E("\taddl %s, %s\n", regref($lhs), regref($$)); }

gen r32 := ADD4($$, CONSTANT():c)
	{ E("\taddl $0x%x, %s\n", $c.value, regref($$)); }

gen r32 := ADD4($$, CONSTANT(value==1))
	{ E("\tincl %s\n", regref($$)); }
	
gen r32 := ADD4($$, CONSTANT(value==-1))
	{ E("\tdecl %s\n", regref($$)); }

gen r32 := SUB4($$:lhs, r32:rhs)
	{ E("\tsubl %s, %s\n", regref($rhs), regref($$)); }

gen r32 := SUB4($$, CONSTANT():c)
	{ E("\tsubl $0x%x, %s\n", $c.value, regref($$)); }

gen r32 := NEG4($$:val)
	{ E("\tnegl %s\n", regref($$)); }

gen r32 := MUL4(r32:lhs, $$)
	{ E("\timull %s, %s\n", regref($lhs), regref($$)); }

gen eax := DIVU4(eax, ebx|ecx:rhs) uses edx
{
	E("\txorl %%edx, %%edx\n");
	E("\tdivl %s\n", regref($rhs));
}

gen edx := REMU4(eax, ebx|ecx:rhs)
{
	E("\txorl %%edx, %%edx\n");
	E("\tdivl %s\n", regref($rhs));
}

gen eax := DIVS4(eax, ebx|ecx:rhs) uses edx
{
	E("\tcdq\n");
	E("\tidivl %s\n", regref($rhs));
}

gen edx := REMS4(eax, ebx|ecx:rhs)
{
	E("\tcdq\n");
	E("\tidivl %s\n", regref($rhs));
}

gen r32 := AND4($$:lhs, r32:rhs)
	{ E("\tandl %s, %s\n", regref($rhs), regref($$)); }

gen r32 := OR4($$:lhs, r32:rhs)
	{ E("\torl %s, %s\n", regref($rhs), regref($$)); }

gen r32 := EOR4($$:lhs, r32:rhs)
	{ E("\txorl %s, %s\n", regref($rhs), regref($$)); }

gen r32 := NOT4($$:val)
	{ E("\tnotl %s\n", regref($$)); }

gen r32 := LSHIFT4($$:lhs, cl:rhs)
	{ E("\tshll %s, %s\n", regref($rhs), regref($$)); }

gen r32 := RSHIFTU4($$:lhs, cl:rhs)
	{ E("\tshrl %s, %s\n", regref($rhs), regref($$)); }

gen r32 := RSHIFTS4($$:lhs, cl:rhs)
	{ E("\tsarl %s, %s\n", regref($rhs), regref($$)); }

// --- Branches -------------------------------------------------------------

%{
	static void cmp(const char* insn, const char* trueop,
		int truelabel, int falselabel, reg_t lhs, reg_t rhs)
	{
		E("\t%s %s, %s\n", insn, regref(rhs), regref(lhs));
		E("\t%s %s\n", trueop, labelref(truelabel));
		E("\tjmp %s\n", labelref(falselabel));
	}

	static void cmpc(int32_t lhs, int32_t rhs, int truelabel, int falselabel, int fallthrough)
	{
		E("\tjmp %s\n", labelref((lhs == rhs) ? truelabel : falselabel));
	}
%}

gen BEQU0(CONSTANT():c1, CONSTANT():c2):b
	{ cmpc($c1.value, $c2.value, $b.truelabel, $b.falselabel, $b.fallthrough); }

gen BEQS0(CONSTANT():c1, CONSTANT():c2):b
	{ cmpc($c1.value, $c2.value, $b.truelabel, $b.falselabel, $b.fallthrough); }

gen BEQU1(r8:lhs, r8:rhs):b
	{ cmp("cmpb", "je", $b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BEQS1(r8:lhs, r8:rhs):b
	{ cmp("cmpb", "je", $b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BLTU1(r8:lhs, r8:rhs):b
	{ cmp("cmpb", "jb", $b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BLTS1(r8:lhs, r8:rhs):b
	{ cmp("cmpb", "jl", $b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BEQU2(r16:lhs, r16:rhs):b
	{ cmp("cmpw", "je", $b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BEQS2(r16:lhs, r16:rhs):b
	{ cmp("cmpw", "je", $b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BLTU2(r16:lhs, r16:rhs):b
	{ cmp("cmpw", "jb", $b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BLTS2(r16:lhs, r16:rhs):b
	{ cmp("cmpw", "jl", $b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BEQU4(r32:lhs, r32:rhs):b
	{ cmp("cmpl", "je", $b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BEQS4(r32:lhs, r32:rhs):b
	{ cmp("cmpl", "je", $b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BLTU4(r32:lhs, r32:rhs):b
	{ cmp("cmpl", "jb", $b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BLTS4(r32:lhs, r32:rhs):b
	{ cmp("cmpl", "jl", $b.truelabel, $b.falselabel, $lhs, $rhs); }

// --- Case statements ---------------------------------------------------

%{
	static void docase(Instruction* self, reg_t value, const char* format, uint32_t mask)
	{
		Node* n = self->n[0]->right;
		while (n->op == MIDCODE_WHEN)
		{
			if (!n->u.when.isdefault)
			{
				E(format, n->u.when.value & mask);
				E(", %s\n\tje %s\n", regref(value), labelref(n->u.when.label));
			}
			n = n->left;
		}

		n = self->n[0]->right;
		while (n->op == MIDCODE_WHEN)
		{
			if (n->u.when.isdefault)
			{
				E("\tjmp %s\n", labelref(n->u.when.label));
				break;
			}
			n = n->left;
		}
	}
%}

gen CASE1(r8:value, param)
	{ docase(self, $value, "\tcmpb $0x%02x", 0xff); }

gen CASE2(r16:value, param)
	{ docase(self, $value, "\tcmpw $0x%04x", 0xffff); }

gen CASE4(r32:value, param)
	{ docase(self, $value, "\tcmpl $0x%08x", 0xffffffff); }

gen param := WHEN(param);

// --- Inline assembly ------------------------------------------------------

gen ASMSTART()
{
    asmbuffer[0] = '\0';
}

gen ASMTEXT():t
{
    strlcat(asmbuffer, $t.text, sizeof(asmbuffer));
    strlcat(asmbuffer, " ", sizeof(asmbuffer));
}

gen ASMSYMBOL():s
{
	if ($s.sym->kind == VAR)
		strlcat(asmbuffer, symref($s.sym, 0), sizeof(asmbuffer));
	else
		strlcat(asmbuffer, subref($s.sym->u.sub), sizeof(asmbuffer));
    strlcat(asmbuffer, " ", sizeof(asmbuffer));
}

gen ASMVALUE():c
{
	int p = strlen(asmbuffer);
	snprintf(asmbuffer+p, sizeof(asmbuffer)-p, "%d", $c.value);
}

gen ASMEND()
{
    E("\t%s\n", asmbuffer);
}

// --- Array initialisers ------------------------------------------------

%{
	static int emit_string(const char* s)
	{
		int sid = id++;
		emitter_open_chunk();
		E("\t.data 1\n");
		E("s%d:\n", sid);
		E("\t.byte ");
		bool start = true;
		for (;;)
		{
			char c = *s++;
			if (!c)
				break;
			if (!start)
				E(", ");
			E("0x%02x", c);
			start = false;
		}
		if (!start)
			E(", ");
		E("0\n");
		emitter_close_chunk(current_sub);
		return sid;
	}
%}

gen STARTINIT():s
{
	int sid = id++;
	$s.sym->u.var.externname = aprintf("array%d", sid);

	emitter_open_chunk();
	E("\t.data 4\n"); // TODO
	E("%s:\n", $s.sym->u.var.externname);
}
	
gen INIT1():c { E("\t.byte %d\n", $c.value); }
gen INIT2():c { E("\t.short %d\n", $c.value); }
gen INIT4():c { E("\t.long %d\n", $c.value); }
gen INITS():s { E("\t.long s%d\n", emit_string($s.text)); }

gen ENDINIT()
{
	emitter_close_chunk(current_sub);
}

// --- Strings -----------------------------------------------------------

gen r32 := STRING():s
{
	E("\tlea s%d, %s\n", emit_string($s.text), regref($$));
}
