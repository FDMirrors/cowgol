%{
	var uint32_type: [Symbol];
	var int32_type: [Symbol];
	var uint16_type: [Symbol];
	var int16_type: [Symbol];
	var uint8_type: [Symbol];
	var int8_type: [Symbol];
	var intptr_type: [Symbol];

	const VARSTACK_WS := 1;
	const PTRSTACK_WS := 2;

	const FAKE_STACK_SIZE := 32;

	var varstack: uint8[FAKE_STACK_SIZE];
	var varsp: uint8 := 0;

	var ptrstack: uint8[FAKE_STACK_SIZE];
	var ptrsp: uint8 := 0;

	record Extern
		name: string;
		id: uint16;
		next: [Extern];
	end record;

	var externs: [Extern] := (0 as [Extern]);

	sub ArchAlignUp(value: Size, alignment: uint8): (newvalue: Size)
		newvalue := value;
	end sub;

	sub ArchInitTypes()
		uint32_type := MakeNumberType(4, 1, 0, "uint32");
		int32_type := MakeNumberType(4, 1, 1, "int32");
		uint16_type := MakeNumberType(2, 1, 0, "uint16");
		int16_type := MakeNumberType(2, 1, 1, "int16");
		uint8_type := MakeNumberType(1, 1, 0, "uint8");
		int8_type := MakeNumberType(1, 1, 1, "int8");

		intptr_type := uint16_type;
		AddAliasString("intptr", intptr_type);
	end sub;

	sub ArchGuessIntType(min: Arith, max: Arith): (symbol: [Symbol])
		if (min >= 0) and (max <= 255) then
			symbol := uint8_type;
		elseif (min >= -128) and (max <= 127) then
			symbol := int8_type;
		elseif (min >= 0) and (max <= 65535) then
			symbol := uint16_type;
		elseif (min >= -32768) and (max <= 32767) then
			symbol := int16_type;
		elseif (min >= 0) then
			symbol := uint32_type;
		else
			symbol := int32_type;
		end if;
	end sub;

	sub ArchInitVariable(symbol: [Symbol])
		var subr := symbol.vardata.subr;
		var offset := subr.workspace[0];
		symbol.vardata.offset := offset;
		subr.workspace[0] := offset + symbol.vardata.type.typedata.width;
	end sub;

	sub ArchInitMember(containing: [Symbol], member: [Symbol], position: Size)
		member.vardata.offset := position;
		position := position + member.vardata.type.typedata.width;
		if position > containing.typedata.width then
			containing.typedata.width := position;
		end if;
	end sub;

	sub Push(reg: RegId, width: uint8): (stackaddr: uint16)
		if (reg & REG_P16) != 0 then
			stackaddr := (PTRSTACK_WS<<8) | (ptrsp as uint16);
			ptrsp := ptrsp + width;
		else
			stackaddr := (VARSTACK_WS<<8) | (varsp as uint16);
			varsp := varsp + width;
		end if;
	end sub;

	sub Pop(reg: RegId, width: uint8): (stackaddr: uint16)
		if (reg & REG_P16) != 0 then
			ptrsp := ptrsp - width;
			stackaddr := (PTRSTACK_WS<<8) | (ptrsp as uint16);
		else
			varsp := varsp - width;
			stackaddr := (VARSTACK_WS<<8) | (varsp as uint16);
		end if;
	end sub;

	sub E_stackref(sid: uint16)
		EmitByte(COO_ESCAPE_WSREF);
		E_h16(current_subr.id);
		E_h8((sid >> 8) as uint8);
		E_h16(sid & 0xff);
	end sub;

	sub E_indstackref(sid: uint16)
		EmitByte('(');
		E_stackref(sid);
		E("),y");
	end sub;

	sub E_symref(sym: [Symbol], off: Size)
		if sym.vardata.externname != (0 as string) then
			E(sym.vardata.externname);
			E_i16(off as int16);
		else
			EmitByte(COO_ESCAPE_WSREF);
			E_h16(sym.vardata.subr.id);
			E_h8(0);
			E_h16(sym.vardata.offset + off);
		end if;
	end sub;

	sub E_loaddr(sym: [Symbol], off: Size)
		E("<#");
		E_symref(sym, off);
	end sub;

	sub E_hiaddr(sym: [Symbol], off: Size)
		E(">#");
		E_symref(sym, off);
	end sub;

	sub R_flushall()
		RegCacheFlush(ALL_REGS);
	end sub;

	sub R_flush(reg: RegId)
		RegCacheFlush(FindConflictingRegisters(reg));
	end sub;

	sub E_label(label: LabelRef)
		R_flushall();
		E_labelref(label);
		E(":\n");
	end sub;

	sub E_insn(insn: string)
		E_tab();
		E(insn);
		E_space();
	end sub;

	sub E_const(value: uint8)
		EmitByte('#');
		E_u8(value);
	end sub;

	sub E_jump(insn: string, label: LabelRef)
		R_flushall();
		E_tab();
		E(insn);
		E_space();
		E_labelref(label);
		E_nl();
	end sub;

	sub E_jmp(label: LabelRef)
		E_jump("jmp", label);
	end sub;

	sub E_rts() E("\trts\n"); end sub;
	sub E_clc() E("\tclc\n"); end sub;
	sub E_sec() E("\tsec\n"); end sub;
	sub E_pha() E("\tpha\n"); end sub;
	sub E_pla() E("\tpla\n"); end sub;
	sub E_txa() E("\ttxa\n"); end sub;
	sub E_tya() E("\ttya\n"); end sub;
	sub E_tax() E("\ttax\n"); end sub;
	sub E_tay() E("\ttay\n"); end sub;

	sub E_ld(reg: RegId)
		R_flush(reg);
		case reg is
			when REG_A: E("\tlda");
			when REG_X: E("\tldx");
			when REG_Y: E("\tldy");
		end case;
		E_space();
	end sub;

	sub E_lda()
		E_ld(REG_A);
	end sub;

	sub E_st(reg: RegId)
		case reg is
			when REG_A: E("\tsta");
			when REG_X: E("\tstx");
			when REG_Y: E("\tsty");
		end case;
		E_space();
	end sub;

	sub E_sta()
		E_st(REG_A);
	end sub;

	sub E_loadconst(reg: RegId, value: uint8)
		var cache := RegCacheFindConstant(value) & reg;
		if cache == 0 then
			E_ld(reg);
			E_const(value);
			E_nl();
			RegCacheLeavesConstant(reg, value);
		end if;
	end sub;

	# Note that this *destroys* the source register.
	sub ArchEmitMove(src: RegId, dest: RegId)
		case src is
			when REG_A:
				case dest is
					when REG_X: E_tax(); return;
					when REG_Y: E_tay(); return;
					when 0:     E_pha(); return;
				end case;

			when 0:
				case dest is
					when REG_A: E_pla(); return;
				end case;

			when REG_X:
				case dest is
					when REG_A: E_txa(); return;
				end case;

			when REG_Y:
				case dest is
					when REG_Y: E_tya(); return;
				end case;
		end case;

		StartError();
		print("bad move ");
		E_h8(src);
		E(" -> ");
		E_h8(dest);
		EndError();
	end sub;

	sub ArchEndInstruction()
	end sub;

	sub ArchEndGroup()
	end sub;
%}

wordsize uint8;

register a x y;
register v8;  // value on fake stack
register v16; // value on fake stack
register p16; // pointer on fake stack
register v32; // value on fake stack;
register param;

regclass a16 := v16|p16;

regdata a compatible a|x|y;
regdata x compatible a|x;
regdata y compatible a|y;
regdata v16 stacked;
regdata p16 stacked;
regdata v32 stacked;
regdata param stacked;

// --- Core things ----------------------------------------------------------

gen STARTFILE();
gen ENDFILE();

gen LABEL():b
{
	E_label($b.label);
}

gen JUMP():j
{
	E_jmp($j.label);
}

// --- Subroutines ----------------------------------------------------------

gen STARTSUB():s
{
	RegCacheReset();

	EmitterPushChunk();
	E_h16($s.subr.id);

	E("\n\n\t; ");
	E($s.subr.name);
	E_nl();

	E("\tcseg\n");
	EmitByte(COO_ESCAPE_THISSUB);
	E(":\n");
}

gen ENDSUB():s
{
	E_rts();
	EmitterPopChunk('S');
}

// --- Constants ------------------------------------------------------------

gen a|x|y := CONSTANT():c
{
	E_loadconst($$, $c.value as uint8);
}

gen a16 := ADDRESS():a uses a
{
	var sid := Push($$, 2);

	E_ld(REG_A);
	E_loaddr($a.sym, $a.off);
	E_nl();
	E_st(REG_A);
	E_stackref(sid);
	E_nl();

	E_ld(REG_A);
	E_hiaddr($a.sym, $a.off);
	E_nl();
	E_st(REG_A);
	E_stackref(sid+1);
	E_nl();
}

// --- 8-bit memory ----------------------------------------------------------

gen STORE1(a:lhs, p16:ptr)
{
	var sid := Pop($ptr, 2);
	E_loadconst(REG_Y, 0);

	E_insn("sta");
	E_indstackref(sid);
	E_nl();
}

gen STORE1(a|x|y:lhs, ADDRESS():a)
{
	E_st($lhs);
	E_symref($a.sym, $a.off);
	E_nl();
	RegCacheLeavesValue($lhs, $a.sym, $a.off);
}

gen a|x|y := LOAD1(ADDRESS():a)
{
	var cache := RegCacheFindValue($a.sym, $a.off) & $$;
	if cache == 0 then
		E_ld($$);
		E_symref($a.sym, $a.off);
		E_nl();
		RegCacheLeavesValue($$, $a.sym, $a.off);
	end if;
}

gen v8 := FALLBACK(a)
{
	R_flush(REG_A);
	var sid := Push(REG_V8, 1);
	
	E_st(REG_A);
	E_stackref(sid);
	E_nl();
}

// --- 8-bit maths -----------------------------------------------------------

%{
	sub DoAlu1S(insn: string)
		var rhssid := Pop(REG_V8, 1);

		R_flush(REG_A);
		E_insn(insn);
		E_stackref(rhssid);
		E_nl();
	end sub;

	sub DoAlu1C(insn: string, value: uint8)
		R_flush(REG_A);
		E_insn(insn);
		E_const(value);
		E_nl();
	end sub;

	sub DoAlu1M(insn: string, sym: [Symbol], off: Size)
		R_flush(REG_A);
		E_insn(insn);
		E_symref(sym, off);
		E_nl();
	end sub;

	sub DoAlu1PS(insn: string)
		var rhssid := Pop(REG_P16, 2);

		E_loadconst(REG_Y, 0);
		R_flush(REG_A);
		E_insn(insn);
		E_indstackref(rhssid);
		E_nl();
	end sub;
%}

gen a := ADD1(a, v8)                 { E_clc(); DoAlu1S("adc"); }
gen a := SUB1(a, v8)                 { E_sec(); DoAlu1S("sbc"); }

gen a := ADD1(a, LOAD1(ADDRESS():a)) { E_clc(); DoAlu1M("adc", $a.sym, $a.off); }
gen a := SUB1(a, LOAD1(ADDRESS():a)) { E_sec(); DoAlu1M("sbc", $a.sym, $a.off); }

gen a := ADD1(a, LOAD1(p16))         { E_clc(); DoAlu1PS("adc"); }
gen a := SUB1(a, LOAD1(p16))         { E_sec(); DoAlu1PS("sbc"); }

gen a := ADD1(a, CONSTANT():c)       { E_clc(); DoAlu1C("adc", $c.value as uint8); }
gen a := SUB1(a, CONSTANT():c)       { E_sec(); DoAlu1C("sbc", $c.value as uint8); }

// --- 8-bit memory ----------------------------------------------------------

%{
	const MODE_CONST := 0;
	const MODE_STACK := 1;
	const MODE_SYMBOL := 2;

	record Operand
		sid @at(0): uint16;
		off @at(0): Size;
		val @at(0): Arith;
		sym: [Symbol];
		mode: uint8;
	end record;

	var paramwidth: uint8;
	var lhsparam: Operand;
	var rhsparam: Operand;
	var destparam: Operand;

	sub LhsConst(value: Arith)
		lhsparam.mode := MODE_CONST;
		lhsparam.val := value;
	end sub;

	sub RhsConst(value: Arith)
		rhsparam.mode := MODE_CONST;
		rhsparam.val := value;
	end sub;

	sub LhsPop(reg: RegId)
		lhsparam.mode := MODE_STACK;
		lhsparam.sid := Pop(paramwidth, reg);
	end sub;

	sub RhsPop(reg: RegId)
		rhsparam.mode := MODE_STACK;
		rhsparam.sid := Pop(paramwidth, reg);
	end sub;

	sub DestPush(reg: RegId)
		destparam.mode := MODE_STACK;
		destparam.sid := Push(paramwidth, reg);
	end sub;

	sub LhsSym(sym: [Symbol], off: Size)
		lhsparam.mode := MODE_SYMBOL;
		lhsparam.sym := sym;
		lhsparam.off := off;
	end sub;

	sub RhsSym(sym: [Symbol], off: Size)
		rhsparam.mode := MODE_SYMBOL;
		rhsparam.sym := sym;
		rhsparam.off := off;
	end sub;

	sub DestSym(sym: [Symbol], off: Size)
		destparam.mode := MODE_SYMBOL;
		destparam.sym := sym;
		destparam.off := off;
	end sub;

	sub DoParam(operand: [Operand], insn: string)
		E_insn(insn);
		case operand.mode is
			when MODE_CONST:
				E_const(operand.val as uint8);
				operand.val := operand.val >> 8;

			when MODE_STACK:
				E_stackref(operand.sid);
				operand.sid := operand.sid + 1;

			when MODE_SYMBOL:
				E_symref(operand.sym, operand.off);
				operand.off := operand.off + 1;
		end case;
		E_nl();
	end sub;

	sub DoCopy()
		R_flush(REG_A);
		while paramwidth != 0 loop
			DoParam(&lhsparam, "lda");
			DoParam(&destparam, "sta");
			paramwidth := paramwidth - 1;
		end loop;
	end sub;

	sub Do3Op(insn: string)
		R_flush(REG_A);
		while paramwidth != 0 loop
			DoParam(&lhsparam, "lda");
			DoParam(&rhsparam, insn);
			DoParam(&destparam, "sta");
			paramwidth := paramwidth - 1;
		end loop;
	end sub;

	sub DoAdc()
		E_clc();
		Do3Op("adc");
	end sub;
%}

gen a16 := CONSTANT():c uses a
		{ paramwidth := 2; LhsConst($c.value);                                     DestPush($$);                  DoCopy(); }

gen STORE2(a16:lhs, ADDRESS():rhs) uses a
		{ paramwidth := 2; LhsPop($lhs);                                           DestSym($rhs.sym, $rhs.off);   DoCopy(); }
gen STORE2(CONSTANT():lhs, ADDRESS():rhs) uses a
		{ paramwidth := 2; LhsConst($lhs.value);                                   DestSym($rhs.sym, $rhs.off);   DoCopy(); }
gen STORE2(LOAD2(ADDRESS():lhs), ADDRESS():rhs) uses a
		{ paramwidth := 2; LhsSym($lhs.sym, $lhs.off);                             DestSym($rhs.sym, $rhs.off);   DoCopy(); }

gen a16 := LOAD2(ADDRESS():lhs) uses a
		{ paramwidth := 2; LhsSym($lhs.sym, $lhs.off);                             DestPush($$);                  DoCopy(); }

gen a16 := ADD2(a16:lhs, a16:rhs) uses a
		{ paramwidth := 2; RhsPop($rhs);               LhsPop($lhs);               DestPush($$);                  DoAdc(); }
gen a16 := ADD2(a16:lhs, CONSTANT():rhs) uses a
		{ paramwidth := 2; RhsConst($rhs.value);       LhsPop($lhs);               DestPush($$);                  DoAdc(); }
gen a16 := ADD2(a16:lhs, LOAD2(ADDRESS():rhs)) uses a
		{ paramwidth := 2; RhsSym($rhs.sym, $rhs.off); LhsPop($lhs);               DestPush($$);                  DoAdc(); }
gen a16 := ADD2(LOAD2(ADDRESS():lhs), CONSTANT():rhs) uses a
		{ paramwidth := 2; RhsConst($rhs.value);       LhsSym($lhs.sym, $lhs.off); DestPush($$);                  DoAdc(); }
gen a16 := ADD2(LOAD2(ADDRESS():lhs), LOAD2(ADDRESS():rhs)) uses a
		{ paramwidth := 2; RhsSym($rhs.sym, $rhs.off); LhsSym($lhs.sym, $lhs.off); DestPush($$);                  DoAdc(); }

gen STORE2(ADD2(LOAD2(ADDRESS():lhs), LOAD2(ADDRESS():rhs)), ADDRESS():dest) uses a
		{ paramwidth := 2; RhsSym($rhs.sym, $rhs.off); LhsSym($lhs.sym, $lhs.off); DestSym($dest.sym, $dest.off); DoAdc(); }

