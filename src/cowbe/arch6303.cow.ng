%[
	record MemOp is
		sym: [Symbol];
		off: Size;
	end record;
		
	record ImmOp is
		value: Arith;
	end record;

	record VsOp is
		sp: uint8;
	end record;

	record XIndOp is
		off: uint8;
	end record;

	record Operand is
		mem @at(0): MemOp;
		xind @at(0): XIndOp;
		imm @at(0): ImmOp;
		vs @at(0): VsOp;
	end record;
%]

%{
    const VARMEM_WS := 0;
    const VARSTACK_WS := 1;

	var varsp: uint8 := 0;

    record ArchSubroutine is
        end_label: LabelRef;
		var_stack: uint8;
    end record;

	record Extern is
		name: string;
		id: uint16;
		next: [Extern];
	end record;

	var externs: [Extern] := (0 as [Extern]);

	sub ArchAlignUp(value: Size, alignment: uint8): (newvalue: Size) is
		newvalue := value;
	end sub;

	sub E_symref(sym: [Symbol], off: Size) is
		if sym.wsid == WSID_STATIC then
			E_wsref(sym.subr.id, sym.wsid, sym.off);
			if off != 0 then
				E_u16(off as uint16);
			end if;
		else
			E_wsref(sym.subr.id, sym.wsid, sym.off + off);
		end if;
	end sub;

	# Does not persist the name; only call this with constant strings.
	sub GetHelper(name: string): (e: [Extern]) is
		e := externs;
		while e != (0 as [Extern]) loop
			if StrCmp(e.name, name) == 0 then
				break;
			end if;
			e := e.next;
		end loop;

		if e == (0 as [Extern]) then
			e := InternalAlloc(@bytesof Extern) as [Extern];
			e.name := name;
			e.id := AllocSubrId();
			e.next := externs;
			externs := e;

			EmitterDeclareExternalSubroutine(e.id, name);
		end if;

		EmitterReferenceSubroutineById(current_subr.id, e.id);
	end sub;

	sub R_flushall() is
		RegCacheFlush(ALL_REGS);
	end sub;

	sub R_flush(reg: RegId) is
		RegCacheFlush(FindConflictingRegisters(reg));
	end sub;

	sub AllocPLabel(): (lid: uint16) is
		# Cheap and cheerful way to allocate a label which won't overlap the
		# frontend's numbering.
		lid := -AllocLabel();
	end sub;

	sub E_label(label: LabelRef) is
		R_flushall();
		E_labelref(label);
		E(" = *\n");
	end sub;

	sub E_insn(insn: string) is
		E_tab();
		E(insn);
		E_space();
	end sub;

	sub E_insn_simple(insn: string) is
		E_tab();
		E(insn);
		E_nl();
	end sub;

	sub E_const() is
		E("#");
	end sub;

	sub E_db() is E_insn("db"); end sub;
	sub E_dw() is E_insn("dw"); end sub;
	sub E_dl() is E_insn("dl"); end sub;

	sub E_jump(insn: string, label: LabelRef) is
		R_flushall();
		E_insn(insn);
		E_labelref(label);
		E_nl();
	end sub;

	sub E_jmp(label: LabelRef) is E_jump("bra", label); end sub;

    sub E_jumps_with_fallthrough(trueinsn: string, falseinsn: string, node: [Node]) is
        if node.beq.truelabel != node.beq.fallthrough then
            E_jump(trueinsn, node.beq.truelabel);
        end if;
        if node.beq.falselabel != node.beq.fallthrough then
            E_jump(falseinsn, node.beq.falselabel);
        end if;
    end sub;

	sub E_acc(ainsn: string, binsn: string, reg: RegId) is
		E_tab();
		if reg == REG_A then
			E(ainsn);
		elseif reg == REG_B then
			E(binsn);
		else
			SimpleError("bad accumulator register");
		end if;
		E_space();
	end sub;

	sub E_st(reg: RegId) is
		if reg == REG_A then
			E_insn("staa");
		elseif reg == REG_B then
			E_insn("stab");
		elseif reg == REG_D then
			E_insn("std");
		elseif reg == REG_X then
			E_insn("stx");
		else
			SimpleError("bad accumulator register");
		end if;
	end sub;

	sub E_ld(reg: RegId) is
		R_flush(reg);
		if reg == REG_A then
			E_insn("ldaa");
		elseif reg == REG_B then
			E_insn("ldab");
		elseif reg == REG_D then
			E_insn("ldd");
		elseif reg == REG_X then
			E_insn("ldx");
		else
			SimpleError("bad accumulator register");
		end if;
	end sub;

	sub E_ldx() is
		R_flush(REG_X);
		E_insn("ldx");
	end sub;

	sub E_ldd() is
		R_flush(REG_D);
		E_insn("ldd");
	end sub;

	sub E_add(reg: RegId) is
		R_flush(reg);
		E_acc("adda", "addb", reg);
	end sub;

	sub E_sub(reg: RegId) is
		R_flush(reg);
		E_acc("suba", "subb", reg);
	end sub;

    sub E_xgdx() is
        R_flush(REG_D|REG_X);
        E_insn_simple("xgdx");
    end sub;

    sub PrepareWorkspacePointerForAddress(sym: [Symbol], off: uint16) is
        if (sym.subr == current_subr) and ((sym.off + off) < 252) then
            var cache := RegCacheFindWsRef(sym.subr, VARMEM_WS, 0) & REG_X;
            if cache != 0 then
                # The workspace pointer is already in X.
                return;
            end if;
            R_flush(REG_X);
            E_insn("ldx");
            E_const();
			E_wsref(sym.subr.id, sym.wsid, 0);
            E_nl();

            RegCacheLeavesWsRef(REG_X, sym.subr, VARMEM_WS, 0);
        end if;
    end sub;

    sub PrepareWorkspacePointer(reg: RegId, op: [Operand]) is
        if reg == REG_MEM then
            PrepareWorkspacePointerForAddress(op.mem.sym, op.mem.off);
        end if;
    end sub;

    sub RetractVStack(reg: RegId, op: [Operand]) is
        case reg is
            when REG_VS1: varsp := varsp - 1;
            when REG_VS2: varsp := varsp - 2;
            when REG_VS4: varsp := varsp - 4;
        end case;
    end sub;

    sub PushVStack(op: [Operand], size: uint8) is
        op.vs.sp := varsp;
        varsp := varsp + size;
        if current_subr.arch.var_stack < varsp then
            current_subr.arch.var_stack := varsp;
        end if;
    end sub;

    sub E_vsref(sp: uint8) is
        E_wsref(current_subr.id, VARSTACK_WS, sp as uint16);
    end sub;

    sub E_memop(sym: [Symbol], off: Size) is
        off := off + sym.off;
        if (sym.subr == current_subr) and (off < 252) then
            E_u8(off as uint8);
            E(",x");
        else
            E_symref(sym, off);
        end if;
    end sub;

	sub E_op(reg: RegId, operand: [Operand], byte: uint8, shift: uint8) is
        sub dovs() is
            E_vsref(operand.vs.sp + byte);
        end sub;

		case reg is
			when REG_MEM:
                E_memop(operand.mem.sym, operand.mem.off + (byte as uint16));

			when REG_IMM:
                var value := ((operand.imm.value as uint32) >> shift) as uint16;
                E_const();
                E_u16(value);

			when REG_X:
                E_u8(byte);
                E(",x");

			when REG_XIND:
                E_u8(operand.xind.off + byte);
                E(",x");

			when REG_VS1: dovs();
			when REG_VS2: dovs();
			when REG_VS4: dovs();

			when else:
                StartError();
                print("bad operand ");
                print_hex_i16(reg);
                EndError();
		end case;
	end sub;

    sub E_ldop(destreg: RegId, srcreg: RegId, operand: [Operand], byte: uint8, shift: uint8) is
        PrepareWorkspacePointer(srcreg, operand);
        R_flush(destreg);
        case destreg is
            when REG_A: E_insn("ldaa");
            when REG_B: E_insn("ldab");
            when REG_D: E_insn("ldd");
            when REG_X: E_insn("ldx");
        end case;
        E_op(srcreg, operand, byte, shift);
        E_nl();
    end sub;

    sub E_ldop_c(destreg: RegId, srcreg: RegId, operand: [Operand], byte: uint8, shift: uint8) is
        case srcreg is
            when REG_IMM:
                if (RegCacheFindConstant(operand.imm.value as uint16) & destreg) != 0 then
                    return;
                end if;

            when REG_MEM:
                if (RegCacheFindValue(operand.mem.sym, operand.mem.off) & destreg) != 0 then
                    return;
                end if;
        end case;

        E_ldop(destreg, srcreg, operand, byte, shift);

        case srcreg is
            when REG_IMM:
                RegCacheLeavesConstant(destreg, operand.imm.value as uint16);
            when REG_MEM:
                RegCacheLeavesValue(srcreg, operand.mem.sym, operand.mem.off);
        end case;
    end sub;

    sub E_stop(srcreg: RegId, destreg: RegId, operand: [Operand], byte: uint8, shift: uint8) is
        PrepareWorkspacePointer(destreg, operand);
        case srcreg is
            when REG_A: E_insn("staa");
            when REG_B: E_insn("stab");
            when REG_D: E_insn("std");
            when REG_X: E_insn("stx");
        end case;
        E_op(destreg, operand, byte, shift);
        E_nl();
    end sub;

    sub E_stop_c(srcreg: RegId, destreg: RegId, operand: [Operand], byte: uint8, shift: uint8) is
        E_stop(srcreg, destreg, operand, byte, shift);

        case destreg is
            when REG_IMM:
                RegCacheLeavesConstant(srcreg, operand.imm.value as uint16);
            when REG_MEM:
                RegCacheLeavesValue(srcreg, operand.mem.sym, operand.mem.off);
        end case;
    end sub;

	sub E_pop(reg: RegId) is
		case reg is
			when REG_A: E_insn_simple("pula");
			when REG_B: E_insn_simple("pulb");
			when REG_X: E_insn_simple("pulx");
			when REG_D: E_insn_simple("pula"); E_insn_simple("pulb");
            when REG_XD:
                E_insn_simple("pulx");
                E_insn_simple("pula");
                E_insn_simple("pulb");
		end case;
	end sub;

	sub E_push(reg: RegId) is
		case reg is
			when REG_A: E_insn_simple("psha");
			when REG_B: E_insn_simple("pshb");
			when REG_X: E_insn_simple("pshx");
			when REG_D: E_insn_simple("pshb"); E_insn_simple("psha");
            when REG_XD:
                E_insn_simple("pshb");
                E_insn_simple("psha");
                E_insn_simple("pshx");
		end case;
	end sub;

	# Note that this *destroys* the source register.
	sub ArchEmitMove(src: RegId, dest: RegId) is
		if (src == REG_A) and (dest == REG_B) then
			E_insn_simple("tab");
		elseif (src == REG_B) and (dest == REG_A) then
			E_insn_simple("tba");
		elseif (src == REG_X) and (dest == REG_D) then
			E_push(REG_X);
			E_pop(REG_D);
		elseif (src == REG_D) and (dest == REG_X) then
			E_push(REG_D);
			E_pop(REG_X);
		elseif dest == 0 then
			E_push(src);
		elseif src == 0 then
			E_pop(dest);
		else
			StartError();
			print("bad move: ");
			print_hex_i16(src);
			print(" -> ");
			print_hex_i16(dest);
			EndError();
		end if;
	end sub;

	sub ArchEndInstruction() is
	end sub;

	sub ArchEndGroup() is
	end sub;
%}

wordsize uint16;

register a;     // 0001
register b;     // 0002
register d;     // 0004
register x;     // 0008
register xd;    // 0010
register param; // 0020

operand imm;    // 0040
operand mem;    // 0080
operand xind;   // 0100
operand vs1;    // 0200
operand vs2;    // 0400
operand vs4;    // 0800

regdata a uses d  |xd  compatible a|b;
regdata b uses d  |xd  compatible a|b;
regdata d uses a|b|xd  compatible d|x;
regdata x uses     xd  compatible d|x;
regdata xd uses a|b|d|x;
regdata param stacked;

regdata xind uses x;

regclass op := imm|mem|xind;

// --- Core things ----------------------------------------------------------

gen STARTFILE();
gen ENDFILE();

gen LABEL():b
{
	E_label($b.label);
}

gen JUMP():j
{
	E_jmp($j.label);
}

// --- Subroutines ----------------------------------------------------------

gen STARTSUB()
{
    current_subr.arch := InternalAlloc(@bytesof ArchSubroutine) as [ArchSubroutine];
    current_subr.arch.end_label := AllocPLabel();

    EmitterOpenStream(current_subr);

    E("\n\n\t; ");
    E(current_subr.name);
    E_nl();

    E_b8(COO_ESCAPE_THISSUB);
    E(" = *\n");

	var count := current_subr.num_input_parameters;
	var lastparam := count - 1;
	var popped: uint8 := 0;

	sub pop_return_address() is
		if popped == 0 then
			E_pop(REG_D);
			popped := 1;
		end if;
	end sub;

	while count != 0 loop
		count := count - 1;
		var param := GetInputParameter(current_subr, count);

		case param.width is
			when 1:
				if count != lastparam then
					pop_return_address();
					E_pop(REG_A);
				end if;
				E_insn("staa");
				E_symref(param as [Symbol], 0);
				E_nl();

			when 2:
				if count != lastparam then
					pop_return_address();
					E_pop(REG_X);
				end if;
				E_insn("stx");
				E_symref(param as [Symbol], 0);
				E_nl();

			when 4:
				pop_return_address();
				E_pop(REG_X);

				E_insn("stx");
				E_symref(param as [Symbol], 0);
				E_nl();

				E_pop(REG_X);

				E_insn("stx");
				E_symref(param as [Symbol], 2);
				E_nl();
		end case;
	end loop;

	if popped != 0 then
		E_push(REG_D);
	end if;
}

gen ENDSUB()
{
	E_label(current_subr.arch.end_label);

	var count: uint8 := 0;
	var params := current_subr.num_output_parameters;
	var pushed: uint8 := 0;

	sub push_return_address() is
		if pushed == 0 then
			E_pop(REG_D);
			pushed := 1;
		end if;
	end sub;

	while count != params loop
		var param := GetOutputParameter(current_subr, count);

		case param.width is
			when 1:
				E_insn("ldaa");
				E_symref(param as [Symbol], 0);
				E_nl();

				if count != (params-1) then
					push_return_address();
					E_push(REG_A);
				end if;

			when 2:
				E_insn("ldx");
				E_symref(param as [Symbol], 0);
				E_nl();

				if count != (params-1) then
					push_return_address();
					E_push(REG_X);
				end if;

			when 4:
				push_return_address();
				E_insn("ldx");
				E_symref(param as [Symbol], 2);
				E_nl();
				E_push(REG_X);

				E_insn("ldx");
				E_symref(param as [Symbol], 0);
				E_nl();
				E_push(REG_X);
		end case;

		count := count + 1;
	end loop;

	if pushed != 0 then
		E_push(REG_D);
	end if;
	E_insn_simple("rts");

    EmitterCloseStream();

    EmitterDeclareWorkspace(current_subr.id, VARSTACK_WS, current_subr.arch.var_stack as uint16);
	Free(current_subr.arch as [uint8]);
}

%{
	sub Call(addr: [MidcodeSubref]) is
        R_flushall();
		E_insn("bsr");
		E_subref(addr.subr);
		E_nl();
	end sub;

	sub CallI() is
        R_flushall();
		E_insn_simple("jsr ,x");
	end sub;
%}

gen         CALL(       param,      SUBREF():a) uses a|b|x { Call(&$a); }
gen         CALL(  ARG1(param, a),  SUBREF():a) uses   b|x { Call(&$a); }
gen         CALL(  ARG2(param, x),  SUBREF():a) uses     x { Call(&$a); }
gen a :=    CALLE1(     param,      SUBREF():a) uses   b|x { Call(&$a); }
gen a :=    CALLE1(ARG1(param, a),  SUBREF():a) uses   b|x { Call(&$a); }
gen a :=    CALLE1(ARG2(param, x),  SUBREF():a) uses     x { Call(&$a); }
gen x :=    CALLE2(     param,      SUBREF():a) uses a|b   { Call(&$a); }
gen x :=    CALLE2(ARG1(param, a),  SUBREF():a) uses a|b   { Call(&$a); }
gen x :=    CALLE2(ARG2(param, x),  SUBREF():a) uses a|b   { Call(&$a); }

gen param := END();

gen param := ARG1(param, a|b:lhs)  { E_push($lhs); }
gen param := ARG2(param, d|x:lhs)  { E_push($lhs); }

gen a   := POPARG1(remaining==0);
gen d   := POPARG2(remaining==0);

gen a|b := POPARG1(remaining!=0) { E_pop($$); }
gen d|x := POPARG2(remaining!=0) { E_pop($$); }

gen RETURN()
{
	E_insn("jmp");
	E_labelref(current_subr.arch.end_label);
	E_nl();
}

// --- Read operands --------------------------------------------------------

gen mem := LOAD1(ADDRESS():a) cost 5
{
	var op := &self.n[0].operand;
	op.mem.sym := &$a.sym;
	op.mem.off := $a.off;
}

gen mem := LOAD2(ADDRESS():a) cost 5
{
	var op := &self.n[0].operand;
	op.mem.sym := &$a.sym;
	op.mem.off := $a.off;
}

gen mem := LOAD4(ADDRESS():a) cost 5
{
	var op := &self.n[0].operand;
	op.mem.sym := &$a.sym;
	op.mem.off := $a.off;
}

gen xind := LOAD1(ADD2(x, CONSTANT(value is byte):c)) cost 5
{
	var op := &self.n[0].operand;
	op.xind.off := $c.value as uint8;
}

gen xind := LOAD2(ADD2(x, CONSTANT(value is bytem1):c)) cost 5
{
	var op := &self.n[0].operand;
	op.xind.off := $c.value as uint8;
}

gen xind := LOAD4(ADD2(x, CONSTANT(value is bytem3):c)) cost 5
{
	var op := &self.n[0].operand;
	op.xind.off := $c.value as uint8;
}

gen imm := CONSTANT():c cost 5
{
	var op := &self.n[0].operand;
	op.imm.value := $c.value;
}

gen vs1 := FALLBACK(a|b:lhs)
{
	E_st($lhs);
	E_wsref(current_subr.id, VARSTACK_WS, varsp as uint16);
	E_nl();

    PushVStack(&$@$.operand, 1);
}

gen vs2 := FALLBACK(d|x:lhs)
{
	E_st($lhs);
	E_wsref(current_subr.id, VARSTACK_WS, varsp as uint16);
	E_nl();

    PushVStack(&$@$.operand, 2);
}

// --- Simple things --------------------------------------------------------

gen x|d := ADDRESS():a
{
	var cache := RegCacheFindAddress(&$a.sym, $a.off) & $$;
	if (cache & $$) != 0 then
		# The value is already in the desired register.
		return;
	end if;

	if $$ == REG_X then
		E_ldx();
	else
		E_ldd();
	end if;
	E_const();
	E_symref(&$a.sym, $a.off);
	E_nl();

	RegCacheLeavesAddress($$, &$a.sym, $a.off);
}

gen a|b|d|x := CONSTANT():c
{
	var cache := RegCacheFindConstant($c.value as uint16) & $$;
	if (cache & $$) != 0 then
		# The value is already in the desired register.
		return;
	end if;

	if ($$ & (REG_A|REG_B)) != 0 then
		E_acc("clra", "clrb", $$);
        E_nl();
	elseif $$ == REG_D then
		E_insn_simple("clra");
		E_insn_simple("clrb");
	else
		E_ld($$);
		E_const();
		E_u16($c.value as uint16);
		E_nl();
	end if;

	RegCacheLeavesConstant($$, $c.value as uint16);
}

gen vs4 := CONSTANT():c
{
    E("; VS4 CONSTANT\n");
    var op: Operand;

    op.imm.value := ($c.value >> 16) as uint16 as int32;
    E_ldop_c(REG_D, REG_IMM, &op, 0, 0);

    op.vs.sp := varsp;
    E_stop(REG_D, REG_VS4, &op, 0, 0);

    op.imm.value := $c.value as uint16 as int32;
    E_ldop_c(REG_D, REG_IMM, &op, 0, 0);

    PushVStack(&$@$.operand, 4);
}

// --- Stores (these don't use operands) ------------------------------------

gen STORE1(a|b:lhs, x)
{
	E_st($lhs);
	E(",x\n");
}

gen STORE1(a|b:lhs, ADD2(x, CONSTANT():c))
{
	E_st($lhs);
	E_u16($c.value as uint16);
	E(",x\n");
}

gen STORE1(a|b:lhs, ADDRESS():a)
{
    var op: Operand;
    op.mem.sym := &$a.sym;
    op.mem.off := $a.off;
    E_stop_c($lhs, REG_MEM, &op, 0, 0);
}

gen STORE2(x|d:lhs, x)
{
	E_st($lhs);
	E(",x\n");
}

gen STORE2(x|d:lhs, ADD2(x, CONSTANT():c))
{
	E_st($lhs);
	E_u16($c.value as uint16);
	E(",x\n");
}

gen STORE2(d:lhs, ADDRESS():a)
{
    var op: Operand;
    op.mem.sym := &$a.sym;
    op.mem.off := $a.off;
    E_stop_c($lhs, REG_MEM, &op, 0, 0);
}

gen STORE4(imm|mem|xind|vs4:lhs, ADDRESS():a)
{
    RetractVStack($lhs, &$@lhs.operand);

    E("\t; STORE4\n");
    RetractVStack($lhs, &$@lhs.operand);
    PrepareWorkspacePointerForAddress(&$a.sym, $a.off);

    E_ldop(REG_D, $lhs, &$@lhs.operand, 2, 0);
    E_st(REG_D);
    E_memop(&$a.sym, $a.off+0);
    E_nl();

    E_ldop(REG_D, $lhs, &$@lhs.operand, 0, 16);
    E_st(REG_D);
    E_memop(&$a.sym, $a.off+2);
    E_nl();
}

// --- Loads (these don't use operands) ----------------------------------

gen a|b := LOAD1(x)
{
	E_ld($$);
	E(",x\n");
}

gen a|b := LOAD1(ADDRESS():a) uses x
{
    var op: Operand;
    op.mem.sym := &$a.sym;
    op.mem.off := $a.off;
    E_ldop_c($$, REG_MEM, &op, 0, 0);
}

gen a|b := LOAD1(ADD2(x, CONSTANT():c))
{
	E_ld($$);
	E_u16($c.value as uint16);
	E(",x\n");
}

gen x|d := LOAD2(x)
{
	E_ld($$);
	E(",x\n");
}

gen x|d := LOAD2(ADDRESS():a) uses x
{
    var op: Operand;
    op.mem.sym := &$a.sym;
    op.mem.off := $a.off;
    E_ldop_c($$, REG_MEM, &op, 0, 0);
}

gen x|d := LOAD2(ADD2(x, CONSTANT():c))
{
	E_ld($$);
	E_u16($c.value as uint16);
	E(",x\n");
}

gen vs4 := LOAD4(ADDRESS():a) uses d|x
{
    var op: Operand;
    op.mem.sym := &$a.sym;
    op.mem.off := $a.off;
    E_ldop(REG_D, REG_MEM, &op, 0, 0);

    op.vs.sp := varsp;
    E_stop(REG_D, REG_VS4, &op, 2, 0);

    op.mem.sym := &$a.sym;
    op.mem.off := $a.off;
    E_ldop(REG_D, REG_MEM, &op, 2, 16);

    PushVStack(&$@$.operand, 4);
    E_stop(REG_D, REG_VS4, &op, 2, 16);
}

// --- 8-bit arithmetic -----------------------------------------------------

gen a|b := ADD1($$:lhs, op:rhs) uses x
{
    RetractVStack($rhs, &$@rhs.operand);

	R_flush($$);
	E_add($$);
	E_op($rhs, &$@rhs.operand, 0, 0);
	E_nl();
}

gen a|b := ADD1($$:lhs, CONSTANT(value == 1))
{
	R_flush($$);
	E_acc("inca", "incb", $$);
	E_nl();
}

gen a|b := ADD1($$:lhs, CONSTANT(value == -1))
{
	R_flush($$);
	E_acc("deca", "decb", $$);
	E_nl();
}

gen a|b := SUB1($$:lhs, op:rhs) uses x
{
    RetractVStack($rhs, &$@rhs.operand);

	R_flush($$);
	E_sub($$);
	E_op($rhs, &$@rhs.operand, 0, 0);
	E_nl();
}

gen a|b := NEG1($$)
{
	R_flush($$);
	E_acc("nega", "negb", $$);
	E_nl();
}

gen a := MUL1(a, b)
{
	R_flush(REG_A|REG_B);
	E_insn_simple("mul");
}

%{
    sub Alu1(lhs: RegId, rhs: RegId, rhsop: [Operand], insna: string, insnb: string) is
        RetractVStack(rhs, rhsop);

        R_flush(lhs);
        E_acc(insna, insnb, lhs);
        E_op(rhs, rhsop, 0, 0);
        E_nl();
    end sub;
%}

gen a|b := EOR1($$:lhs, op|vs1:rhs) uses x { Alu1($$, $rhs, &$@rhs.operand, "eora", "eorb"); }
gen a|b := OR1 ($$:lhs, op|vs1:rhs) uses x { Alu1($$, $rhs, &$@rhs.operand, "oraa", "orab"); }
gen a|b := AND1($$:lhs, op|vs1:rhs) uses x { Alu1($$, $rhs, &$@rhs.operand, "anda", "andb"); }

// --- 16-bit arithmetic ----------------------------------------------------

gen d := ADD2($$:lhs, op:rhs) uses x
{
    RetractVStack($rhs, &$@rhs.operand);

	R_flush($$);
	E_insn("addd");
	E_op($rhs, &$@rhs.operand, 0, 0);
	E_nl();
}

gen d := SUB2($$:lhs, op:rhs) uses x
{
    RetractVStack($rhs, &$@rhs.operand);

	R_flush($$);
	E_insn("subd");
	E_op($rhs, &$@rhs.operand, 0, 0);
	E_nl();
}

%{
	sub is_byte(value: int32): (result: uint8) is
		if (value & 0xffffff00) == 0 then
			result := 1;
		else
			result := 0;
		end if;
	end sub;

	sub is_bytem1(value: int32): (result: uint8) is
        if (value >= 0) and (value <= 254) then
			result := 1;
		else
			result := 0;
		end if;
	end sub;

	sub is_bytem3(value: int32): (result: uint8) is
        if (value >= 0) and (value <= 252) then
			result := 1;
		else
			result := 0;
		end if;
	end sub;
%}

gen x := ADD2($$:lhs, CONSTANT(value is byte):c) uses b cost -5
{
	var cache := RegCacheFindConstant($c.value as uint16) & $$;
	if (cache & $$) != 0 then
		# The value is already in the desired register.
	else
		R_flush(REG_B);
		E_insn("ldab #");
		E_u8($c.value as uint8);
		E_nl();
		RegCacheLeavesConstant($$, $c.value as uint16);
	end if;

	R_flush($$);
	E_insn_simple("abx");
}

gen x := ADD2($$:lhs, CONSTANT(value == 1)) cost 1
{
	R_flush($$);
	E_insn_simple("inx");
}

gen x := ADD2($$:lhs, CONSTANT(value == -1)) cost 1
{
	R_flush($$);
	E_insn_simple("dex");
}

// --- 32-bit arithmetic ----------------------------------------------------

%{
    sub AddSub4(dest: RegId, destop: [Operand],
            lhs: RegId, lhsop: [Operand],
            rhs: RegId, rhsop: [Operand],
            insnd: string, insnb: string, insna: string) is
        E("\t; ADDSUB4\n");
        RetractVStack(lhs, lhsop);
        RetractVStack(rhs, rhsop);
        if dest == REG_VS4 then
            destop.vs.sp := varsp;
        end if;

        E_ldop(REG_D, lhs, lhsop, 2, 0);
        PrepareWorkspacePointer(rhs, rhsop);
        E_insn(insnd);
        E_op(rhs, rhsop, 2, 0);
        E_nl();
        E_stop(REG_D, dest, destop, 2, 0);

        E_ldop(REG_D, lhs, lhsop, 0, 0);
        PrepareWorkspacePointer(rhs, rhsop);
        E_insn(insnb);
        E_op(rhs, rhsop, 1, 16);
        E_nl();
        E_insn(insna);
        E_op(rhs, rhsop, 0, 24);
        E_nl();
        E_stop(REG_D, dest, destop, 0, 0);
    end sub;
%}

gen vs4 := ADD4(imm|mem|vs4:lhs, op|vs4:rhs) uses x
{
    AddSub4($$, &$@$.operand, $lhs, &$@lhs.operand, $rhs, &$@rhs.operand,
        "addd", "adcb", "adca");
    PushVStack(&$@$.operand, 4);
}

gen STORE4(ADD4(imm|mem|vs4:lhs, op|vs4:rhs), ADDRESS():a) uses x
{
    var op: Operand;
    op.mem.sym := &$a.sym;
    op.mem.off := $a.off;
    AddSub4(REG_MEM, &op, $lhs, &$@lhs.operand, $rhs, &$@rhs.operand,
        "addd", "adcb", "adca");
}

gen vs4 := SUB4(imm|mem|vs4:lhs, op|vs4:rhs) uses x
{
    AddSub4($$, &$@$.operand, $lhs, &$@lhs.operand, $rhs, &$@rhs.operand,
        "subd", "sbcb", "sbca");
    PushVStack(&$@$.operand, 4);
}

gen STORE4(SUB4(imm|mem|vs4:lhs, op|vs4:rhs), ADDRESS():a) uses x
{
    var op: Operand;
    op.mem.sym := &$a.sym;
    op.mem.off := $a.off;
    AddSub4(REG_MEM, &op, $lhs, &$@lhs.operand, $rhs, &$@rhs.operand,
        "subd", "sbcb", "sbca");
}

%{
    sub DivRem4(lhs: RegId, lhsop: [Operand], rhs: RegId, rhsop: [Operand],
            helpername: string) is
        var helper := GetHelper(helpername);
        var corehelper := GetHelper("_mathpad");
        var id := corehelper.id;

        E_ldop(REG_D, lhs, lhsop, 2, 0);
        E_insn("std");
        E_wsref(id, VARSTACK_WS, 0);
        E_nl();
        E_ldop(REG_D, lhs, lhsop, 0, 16);
        E_insn("std");
        E_wsref(id, VARSTACK_WS, 2);
        E_nl();

        E_ldop(REG_D, rhs, rhsop, 11, 0);
        E_ldop(REG_X, rhs, rhsop, 8, 16);

        R_flushall();
        E_insn("bsr");
        E_b8(COO_ESCAPE_SUBREF);
        E_b16(helper.id);
        E_nl();
    end sub;
%}

gen vs4 := DIVU4(imm|mem|vs4:lhs, op|vs4:rhs) uses x
{
    DivRem4($lhs, &$@lhs.operand, $rhs, &$@rhs.operand, "_divu4");
    PushVStack(&$@$.operand, 4);
    E_stop(REG_D, $$, &$@$.operand, 2, 0);
    E_stop(REG_X, $$, &$@$.operand, 0, 16);
}

gen vs4 := REMU4(imm|mem|vs4:lhs, op|vs4:rhs) uses x
{
    DivRem4($lhs, &$@lhs.operand, $rhs, &$@rhs.operand, "_remu4");
    PushVStack(&$@$.operand, 4);
    E_stop(REG_D, $$, &$@$.operand, 6, 0);
    E_stop(REG_X, $$, &$@$.operand, 4, 16);
}

gen vs4 := DIVS4(imm|mem|vs4:lhs, op|vs4:rhs) uses x
{
    DivRem4($lhs, &$@lhs.operand, $rhs, &$@rhs.operand, "_divs4");
    PushVStack(&$@$.operand, 4);
    E_stop(REG_D, $$, &$@$.operand, 2, 0);
    E_stop(REG_X, $$, &$@$.operand, 0, 16);
}

gen vs4 := REMS4(imm|mem|vs4:lhs, op|vs4:rhs) uses x
{
    DivRem4($lhs, &$@lhs.operand, $rhs, &$@rhs.operand, "_rems4");
    PushVStack(&$@$.operand, 4);
    E_stop(REG_D, $$, &$@$.operand, 6, 0);
    E_stop(REG_X, $$, &$@$.operand, 4, 16);
}

// --- Conditionals ---------------------------------------------------------

gen BEQ0(CONSTANT():lhs, CONSTANT():rhs):b
{
    var label := $b.falselabel;
    if $lhs.value == $rhs.value then
        label := $b.truelabel;
    end if;
    if label != $b.fallthrough then
        E_jmp(label);
    end if;
}

gen BEQ1(a|b:lhs, op:rhs):b uses x
{
    RetractVStack($rhs, &$@rhs.operand);

	E_acc("cmpa", "cmpb", $lhs);
	E_op($rhs, &$@rhs.operand, 0, 0);
	E_nl();
	E_jumps_with_fallthrough("beq", "bne", self.n[0]);
}

gen BEQ2(d|x:lhs, op:rhs):b
{
    RetractVStack($rhs, &$@rhs.operand);

	if $lhs == REG_D then
		E_insn("cmpd");
	else
		E_insn("cpx");
	end if;
	E_op($rhs, &$@rhs.operand, 0, 0);
	E_nl();
	E_jumps_with_fallthrough("beq", "bne", self.n[0]);
}

// --- Strings --------------------------------------------------------------

%{
    sub E_string(data: string): (lid: uint16) is
        lid := AllocPLabel();

        EmitterOpenStream(current_subr);

        E_label(lid);
        E_db();

        loop
            var c := [data];
            if c == 0 then
                break;
            end if;
            data := data + 1;
            
            E_u8(c);
            E_comma();
        end loop;
        E("0\n");
        EmitterCloseStream();
    end sub;
%}

gen d|x := STRING():s
{
	var lid := E_string($s.text);
	R_flush($$);
	if $$ == REG_D then
		E_insn("ldd");
	else
		E_insn("ldx");
	end if;
	E_const();
	E_labelref(lid);
	E_nl();
}

// --- Initialisers ---------------------------------------------------------

gen STARTINIT():s
{
    EmitterOpenStream(current_subr);
	E_symref(&$s.sym, 0);
    E(" = *\n");
}

gen ENDINIT()
{
    EmitterCloseStream();
}

gen INIT1():c
{
    E_db();
    E_u8($c.value as uint8);
    E_nl();
}

gen INIT2():c
{
    E_dw();
    E_u16($c.value as uint16);
    E_nl();
}

gen INIT4():c
{
    E_dl();
    E_u32($c.value as uint32);
    E_nl();
}

gen INITADDRESS():a
{
	E_symref(&$a.sym, $a.off);
}

gen INITSUBREF():a
{
	E_subref($a.subr);
}

gen INITSTRING():s
{
    var sid := E_string($s.text);

    E_dw();
    E_labelref(sid);
    E_nl();
}

// --- Inline assembly ------------------------------------------------------

gen ASMGROUPSTART();
gen ASMGROUPEND();

gen ASMSTART()
{
    E_tab();
}

gen ASMTEXT():t
{
    E($t.text);
    E_space();
}

gen ASMSYMBOL():s
{
	E_symref(&$s.sym, 0);
    E_space();
}

gen ASMSUBREF():s
{
	E_subref($s.subr);
    E_space();
}

gen ASMVALUE():c
{
    E_openp();
    E_i32($c.value);
    E_closep();
}

gen ASMEND()
{
    E_nl();
}

// vim: sw=4 ts=4 et

