sub print(ptr: [int8])
    var index: uint8 := 0;
    loop
        var c: int8 := ptr[index as int16];
        if c == 0 then
            return;
        end if;
        print_char(c as uint8);
        index := index + 1;
    end loop;
end sub;

sub print_char(char: uint8)
    @bytes 0xAD, &char;        # LDA char
    @bytes 0x4C, 0xE3, 0xFF;   # JMP OSASCII
end sub;

sub print_newline()
    @bytes 0x4C, 0xE7, 0xFF;   # JMP abs
end sub;

sub print_i8(value: uint8)
end sub;

sub print_i16(value: uint16)
end sub;

sub print_i32(value: uint32)
end sub;

sub print_hex_i8(value: uint8)
end sub;

sub print_hex_i16(value: uint16)
end sub;

sub print_hex_i32(value: uint32)
end sub;

sub file_openin(filename: [int8]): (fd: uint8)
end sub;

sub file_openout(filename: [int8]): (fd: uint8)
end sub;

sub file_getblock(fd: uint8, ptr: [int8], length: uint16)
end sub;

sub file_putblock(fd: uint8, ptr: [int8], length: uint16)
end sub;

sub file_seek(fd: uint8, pos: uint32)
end sub;

sub file_ext(fd: uint8): (length: uint32)
end sub;

sub file_eof(fd: uint8): (eof: uint8)
end sub;

sub file_getchar(fd: uint8): (char: int8)
end sub;

sub file_close(fd: uint8)
end sub;

sub exit(status: uint8)
end sub;

var __nextaddr: uint16 @segment(0x81);
var __pointers: uint16[3] @segment(0x81);

# Copies A parameters from __nextaddr into __pointers. Advances __nextaddr.
sub __copyparams()
    @bytes 0xAA;                 # TAX
    @bytes 0xA8;                 # TAY

again:
    @bytes 0x88;                 # DEY
    @bytes 0x30, 0xF8;           # BPL loop
    @bytes 0xB1, >&__nextaddr;   # LDA (__nextaddr), Y
    @bytes 0x99, &__pointers;    # STA __pointers, Y
    goto again;

    @bytes 0x8A;                 # TXA
    @bytes 0x18;                 # CLC
    @bytes 0x65, >&__nextaddr+0; # ADC __nextaddr
    @bytes 0x85, >&__nextaddr+0; # STA __nextaddr
    @bytes 0x90, 0x02;           # BCC exit
    @bytes 0xE6, >&__nextaddr+1; # INC __nextaddr+1
end sub;

#sub __add16()
#    @bytes 0x68;             # PLA
#    @bytes 0x85, >&lp;       # STA lp
#    @bytes 0x68;             # PLA
#    @bytes 0x85, >&lp+1;     # STA lp+1
#
#    @bytes 0xA9, 0x06;       # LDA #6
#    __copyparams();
#
#    # loop:
#    @bytes 0xA0, 0x00;       # LDY #0
#    @bytes 0xA2, 0x01;       # LDX #1
#    @bytes 0x18;             # CLC
#    # loop:
#    @bytes 0xB1, >&__pointers+0; # LDA (__pointers+0), Y
#    @bytes 0x71, >&__pointers+2; # ADC (__pointers+2), Y
#    @bytes 0x91, >&__pointers+4; # STA (__pointers+4), Y
#    @bytes 0xC8;             # INY
#    @bytes 0xCA;             # DEX
#    @bytes 0x10, 0xF6;       # BPL loop
#
#    @bytes 0x6C, &__nextaddr; # JMP (__nextaddr)
#end sub;

sub __lsl16()
    var count: uint8;
    @bytes 0x8D, &count;         # STA count

    @bytes 0x68;                 # PLA
    @bytes 0x85, >&__nextaddr+0; # STA __nextaddr+0
    @bytes 0x68;                 # PLA
    @bytes 0x85, >&__nextaddr+1; # STA __nextaddr+1

    @bytes 0xA9, 0x06;           # LDA #4
    __copyparams();

    # Copy the value from src to dest, shifting once as we go.

shiftagain:
    @bytes 0xA0, 0x00;           # LDY #0
    @bytes 0xA2, 0x01;           # LDX #1
    @bytes 0x18;                 # CLC
    # loop:
    @bytes 0xB1, >&__pointers+0; # LDA (__pointers+0), Y
    @bytes 0x2A;                 # ROL A
    @bytes 0x91, >&__pointers+2; # STA (__pointers+2), Y
    @bytes 0xC8;                 # INY
    @bytes 0xCA;                 # DEX
    @bytes 0x10, 0xF8;           # BPL loop

    @bytes 0xCE, &count;         # DEC count
    @bytes 0xF0, 0x09;           # BEQ exit

    # We need to shift more, so we do it in-place in dest.

    @bytes 0xA5, >&__pointers+2; # LDA __pointers+2
    @bytes 0x85, >&__pointers+0; # STA __pointers+0
    @bytes 0xA5, >&__pointers+3; # LDA __pointers+3
    @bytes 0x85, >&__pointers+1; # STA __pointers+1
    goto shiftagain;

    @bytes 0x6C, &__nextaddr;    # JMP (__nextaddr)
end sub;

sub __mul8u(left: uint8, right: uint8): (result: uint8)
    @bytes 0xA9, 0x00; # LDA #0
    @bytes 0xF0, 0x07; # BEQ start

    # add:
    @bytes 0x18; # CLC
    @bytes 0x6D, &left; # ADC abs
    # loop:
    @bytes 0x0E, &left; # ASL abs
    # start:
    @bytes 0x4E, &right; # LSR abs
    @bytes 0xB0, 0xF4; # BCS add
    @bytes 0xD0, 0xF6; # BNE loop
    @bytes 0x8D, &result; # STA abs
end sub;

var LOMEM: [int8];
var HIMEM: [int8];
