sub WriteSubroutinesToOutputFile(coo: [Coo])
	var id: uint16;
	var subroutine: [Subroutine];
	var c: uint8;
	var length: Size;

	sub MalformedError(s: [uint8])
		print("error: malformed coofile: ");
		print(s);
		print_nl();
		ExitWithError();
	end sub;

	sub UnexpectedEndOfChunk()
		MalformedError("unexpected end of chunk");
	end sub;

	sub ReadB1(): (result: uint8)
		if length < 1 then
			UnexpectedEndOfChunk();
		end if;
		length := length - 1;
		result := read_bin1(&coo.fcb);
	end sub;

	sub ReadB2(): (result: uint16)
		if length < 2 then
			UnexpectedEndOfChunk();
		end if;
		length := length - 2;
		result := read_bin2(&coo.fcb);
	end sub;

	sub CheckSubExists(subr: [Subroutine])
		if (subr.state & SUB_IMPLEMENTATION) == 0 then
			StartError();
			print("reference to undefined subroutine ");
			if subr.name != (0 as string) then
				print("'");
				print(subr.name);
				print("'");
			else
				print("which is anonymous");
			end if;
			EndError();
		end if;
	end sub;

	sub CopySourceChunk()
		var subid: uint16;
		var subr: [Subroutine];
		var wid: uint8;
		var off: Size;

		while length != 0 loop
			c := ReadB1();
			case c is
				when COO_ESCAPE_THISCOO:
					E_b8('c');
					E_h8(coo.id as uint8);
					E_b8('_');

				when COO_ESCAPE_THISSUB:
					ArchEmitSubRef(subroutine);

				when COO_ESCAPE_SUBREF:
					subid := ReadB2();
					subr := FindOrCreateSub(coo, subid);
					subr := Deref(subr);
					CheckSubExists(subr);
					ArchEmitSubRef(subr);

				when COO_ESCAPE_WSREF:
					subid := ReadB2();
					wid := ReadB1();
					off := ReadB2();
					subr := FindOrCreateSub(coo, subid);
					subr := Deref(subr);
					CheckSubExists(subr);
					ArchEmitWSRef(wid, subr.workspaceAddress[wid] + off);

				when COO_ESCAPE_WSSIZE:
					subid := ReadB2();
					wid := ReadB1();
					subr := FindOrCreateSub(coo, subid);
					subr := Deref(subr);
					CheckSubExists(subr);
					ArchEmitWSRef(wid, subr.workspaceSize[wid]);

				when else:
					E_b8(c);
			end case;
		end loop;
	end sub;

	var pos: uint32 := 0;
	loop
		length := 255; # no length limit here
		FCBSeek(&coo.fcb, pos);
		c := ReadB1();
		length := ReadB2();
		pos := pos + (length as uint32) + 3;

		if c == 'E' then
			break;
		elseif c == 'S' then
			id := ReadB2();
			subroutine := FindOrCreateSub(coo, id);
			subroutine := Deref(subroutine);
			if (subroutine.state & SUB_USED) != 0 then
				CopySourceChunk();
			end if;
		end if;
	end loop;
end sub;

sub WriteAllSubroutinesToOutputFile(coos: [Coo])
	while coos != (0 as [Coo]) loop
		WriteSubroutinesToOutputFile(coos);
		coos := coos.next;
	end loop;
end sub;

