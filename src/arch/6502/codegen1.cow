record CachedValue
    ea: EffectiveAddress;
    locations: uint8;
end record;

var values: CachedValue[16];
var locked_registers: uint8;

$if DEBUG
	sub print_cache()
		var i: uint8 := 0;
		while i < values@size loop
			var value: [CachedValue] := &values[i];
			if value.locations != 0 then
				print("cache slot ");
				print_i8(i);
				print(": ");
				print_ea(&value.ea);
				if (value.locations & PRECIOUS) != 0 then
					print(" precious");
				end if;
				print(" in 0x");
				print_hex_i8(value.locations & REG_MASK);
				print_newline();
			end if;
			i := i + 1;
		end loop;
	end sub;
$endif

sub arch_init_codegen()
    zero_memory(&values[0] as [int8], values@bytes);
end sub;

sub insn_check_saveable()
    if (insn.indexreg != 0) or (insn.mode == MODE_IND) then
        print("unsaveable object");
        halt();
    end if;
end sub;

sub load_saveable_object(ea: [EffectiveAddress], location: uint8)
    var storage: Insn;
    save_insn(&storage);

    insn_init_from_ea(ea);
    insn.datareg := location;
    insn_check_saveable();
    insn_load_object();

    load_insn(&storage);
end sub;

sub save_saveable_object(ea: [EffectiveAddress], location: uint8)
    var storage: Insn;
    save_insn(&storage);

    insn_init_from_ea(ea);
    insn.datareg := location;
    insn_check_saveable();
    insn_save_object();

    load_insn(&storage);
end sub;

sub write_back_precious_value(location: uint8, ea: [EffectiveAddress])
    location := find_first_bit(location);
	$if DEBUG
		print("* writing back 0x");
		print_hex_i8(location);
		print(" to precious value ");
		print_ea(ea);
		print_newline();
	$endif

    save_saveable_object(ea, location);
end sub;

sub write_back_precious_values(mask: uint8)
    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        var locations: uint8 := value.locations;
        if (locations & mask) != 0 then
            if (locations & PRECIOUS) != 0 then
                # We only need to write back the value if it's not previous
                # in other registers (i.e. this is the last use).
                if (locations & (mask ^ 0x7f)) == 0 then
                    locations := locations ^ PRECIOUS;
                    write_back_precious_value(locations, &value.ea);
                    value.locations := locations;
                end if;
            end if;
        end if;
        i := i + 1;
    end loop;
end sub;

sub flush_cached_values(mask: uint8)
	$if DEBUG
		print("* flushing cached values in 0x");
		print_hex_i8(mask);
		print_newline();
	$endif

    write_back_precious_values(mask);

    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        value.locations := value.locations & (0xFF ^ mask);
        i := i + 1;
    end loop;
end sub;

sub find_unused_regs(candidates: uint8): (mask: uint8)
    var i: uint8 := 0;
    while i < values@size loop
        candidates := candidates & (values[i].locations ^ 0xff);
        i := i + 1;
    end loop;
    mask := candidates & REG_MASK;
end sub;

sub allocate_reg(candidates: uint8): (mask: uint8)
    $if DEBUG
        print("* looking for register matching 0x");
        print_hex_i8(candidates);
        print_newline();
    $endif

    candidates := candidates & (locked_registers ^ 0xff);
    mask := find_unused_regs(candidates);
    if mask == 0 then
        mask := candidates;
        if mask == 0 then
			$if DEBUG
				print_cache();
			$endif
            print("locked register bitmask: 0x");
            print_hex_i8(locked_registers);
            print_newline();
            print("no available registers");
            halt();
        end if;
    end if;
    mask := find_first_bit(mask);
    flush_cached_values(mask);
    locked_registers := locked_registers | mask;

	$if DEBUG
		print("* allocating 0x");
		print_hex_i8(mask);
		print_newline();
	$endif
end sub;

sub free_reg(mask: uint8)
    locked_registers := locked_registers & (mask ^ REG_MASK);
end sub;

sub allocate_fixed_reg(candidates: uint8)
    var location: uint8 := allocate_reg(candidates);
end sub;

sub find_regs_with_value(ea: [EffectiveAddress], candidates: uint8): (locations: uint8)
    var index: uint8 := 0;
    while index < values@size loop
        var value: [CachedValue] := &values[index];
        locations := value.locations & candidates & REG_MASK;
        if (locations != 0) and (is_same_ea_ignoring_type(&value.ea, ea) != 0) then
            locations := value.locations & REG_MASK;

			$if DEBUG
				print("* found in 0x");
				print_hex_i8(locations);
				print(" value ");
				print_ea(ea);
				print_newline();
			$endif

            return;
        end if;
        index := index + 1;
    end loop;
    locations := 0;

	$if DEBUG
		print("* did not find value ");
		print_ea(ea);
		print(" in any register\n");
	$endif
end sub;

sub find_reg_with_value(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := find_regs_with_value(ea, candidates);
    if location != 0 then
        location := find_first_bit(location & candidates);
    end if;
end sub;

sub value_is_cached_in_reg(ea: [EffectiveAddress], locations: uint8)
    var i: uint8;
    var value: [CachedValue];

	$if DEBUG
		sub msg()
			print("* remembering that ");
			print_ea(ea);
			print(" is also in 0x");
			print_hex_i8(locations);
			print_newline();
		end sub;
	$endif

    # Look for a cache slot already containing this value.
    i := 0;
    while i < values@size loop
        value := &values[i];

        if is_same_ea_ignoring_type(&value.ea, ea) != 0 then
            value.locations := value.locations | locations;

			$if DEBUG
				msg();
			$endif

            return;
        end if;
        i := i + 1;
    end loop;

    # Not found --- find an empty cache slot and use that.
    i := 0;
    while i < values@size loop
        value := &values[i];

        if value.locations == 0 then
            value.locations := locations;
            copy_ea(ea, &value.ea);

			$if DEBUG
				msg();
			$endif

            return;
        end if;
        i := i + 1;
    end loop;

    print("can't cache, value cache is full");
    halt();
end sub;

sub is_value_precious(ea: [EffectiveAddress]): (precious: uint8)
    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];

        if is_same_ea_ignoring_type(&value.ea, ea) != 0 then
            if (value.locations & PRECIOUS) != 0 then
                precious := 1;
                return;
            end if;
        end if;
        i := i + 1;
    end loop;

    precious := 0;
    return;
end sub;

sub value_is_precious(ea: [EffectiveAddress])
    var i: uint8 := 0;
    var made_precious: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        if value.locations != 0 then
            if is_same_ea_ignoring_type(ea, &value.ea) != 0 then
                if (value.locations & PRECIOUS) == 0 then
					$if DEBUG
						print("* remembering that value ");
						print_ea(ea);
						print(" is precious in 0x");
						print_hex_i8(value.locations);
						print_newline();
					$endif

                    value.locations := value.locations | PRECIOUS;
                else
					$if DEBUG
						print("* value ");
						print_ea(ea);
						print(" is already precious in 0x");
						print_hex_i8(value.locations & (PRECIOUS ^ 0xff));
						print_newline();
					$endif
                end if;
                made_precious := 1;
            end if;
        end if;
        i := i + 1;
    end loop;

    if made_precious == 0 then
        $if DEBUG
            print_cache();
        $endif
        print("can't make precious, value ");
        print_ea(ea);
        print(" is not in the cache");
        halt();
    end if;
end sub;

sub value_is_not_precious(ea: [EffectiveAddress])
    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        if (value.locations != 0) and (is_same_ea_ignoring_type(ea, &value.ea) != 0) then
            if (value.locations & PRECIOUS) != 0 then
				$if DEBUG
					print("* value ");
					print_ea(ea);
                    print(" in 0x");
                    print_hex_i8(value.locations & (PRECIOUS ^ 0xff));
					print(" is no longer precious\n");
				$endif

                value.locations := value.locations ^ PRECIOUS;
                return;
            end if;
        end if;
        i := i + 1;
    end loop;
end sub;

sub move_value_to_reg(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
	$if DEBUG
		print("* hunting for ");
		print_ea(ea);
		print(" in 0x");
		print_hex_i8(candidates);
		print_newline();
	$endif

    location := find_reg_with_value(ea, candidates);
    if location != 0 then
        locked_registers := locked_registers | location;
        return;
    end if;

    location := find_reg_with_value(ea, REG_A|REG_X|REG_Y);
    if location != 0 then
        # Does this value exist in another register?

        var oldlocation: uint8 := location;
        location := allocate_reg(candidates);

        # Special case: can't move from X to Y or vice versa.
        if (oldlocation|location) == (REG_X|REG_Y) then
            free_reg(location);
            location := 0;
        else
            $if DEBUG
                print("* moving value ");
                print_ea(ea);
                print(" from 0x");
                print_hex_i8(oldlocation);
                print(" to 0x");
                print_hex_i8(location);
                print_newline();
            $endif

            t_reg_reg(oldlocation, location);
            value_is_cached_in_reg(ea, location);
            if is_value_precious(ea) != 0 then
                value_is_precious(ea);
            end if;
            return;
        end if;
    end if;

    if (is_number_thing(ea.obj_id) != 0) and (ea.flags == EA_VALUE)
        and (ea.numoff_id == 0) and (ea.varoff_id == 0)
        and ((candidates & (REG_X|REG_Y)) != 0)
    then
        # We're loading a number into an index register. Can we construct it
        # with a inc or dec?

        candidates := candidates & (REG_X|REG_Y);

        var value: int8 := get_value_of_number(ea.obj_id) as int8;
        sub find_with_delta(delta: int8)
            var oldea: EffectiveAddress;
            zero_ea(&oldea);
            oldea.flags := EA_VALUE;
            oldea.obj_id := add_number_by_value((value + delta) as int32);
            location := find_reg_with_value(&oldea, candidates) & (locked_registers ^ 0xff);
        end sub;

        sub found(modx: uint8, mody: uint8)
            allocate_fixed_reg(location);
            
            $if DEBUG
                print("* constructing value ");
                print_ea(ea);
                print(" from 0x");
                print_hex_i8(location);
                print(" using 0x");
            $endif
            if location == REG_X then
                write_byte(modx);
                $if DEBUG
                    print_hex_i8(modx);
                $endif
            else
                write_byte(mody);
                $if DEBUG
                    print_hex_i8(mody);
                $endif
            end if;
            $if DEBUG
                print_newline();
            $endif

            value_is_cached_in_reg(ea, location);
        end sub;

        find_with_delta(-1);
        if location != 0 then
            found(0xe8, 0xc8); # INX, INY
            return;
        else
            find_with_delta(1);
            if location != 0 then
                found(0xca, 0x88); # DEX, DEY
                return;
            end if;
        end if;
    end if;
end sub;

sub flush_value(ea: [EffectiveAddress])
    var regs: uint8 := find_regs_with_value(ea, REG_A|REG_X|REG_Y);
    flush_cached_values(regs);
end sub;

# This value is about to be written to, so flush any references to it.
sub value_is_changing(oldvalue: [EffectiveAddress])
	$if DEBUG
		print("* flushing references to ");
		print_ea(oldvalue);
		print_newline();
	$endif

    var varoff_candidate: uint8;
    if (oldvalue.varoff_id == 0) and (get_value_of_number(oldvalue.numoff_id) == 0) then
        varoff_candidate := 1;
		$if DEBUG
			print("* (this might be used as a varoff)\n");
		$endif
    else
        varoff_candidate := 0;
    end if;

    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        var locations: uint8 := value.locations;

        sub flush()
			$if DEBUG
				print("* value ");
				print_ea(&value.ea);
				print(" is no longer cached\n");
			$endif
            value.locations := 0;
        end sub;

        if locations != 0 then
            if is_same_ea_ignoring_type(&value.ea, oldvalue) != 0 then
                flush();
            elseif (varoff_candidate != 0) and (value.ea.varoff_id == oldvalue.obj_id) then
                if (locations & PRECIOUS) != 0 then
                    locations := locations ^ PRECIOUS;
                    write_back_precious_value(locations ^ PRECIOUS, &value.ea);
                end if;
                flush();
            end if;
        end if;
        i := i + 1;
    end loop;
end sub;

# A value in a particular location is about to be replaced with a new value.
# If the old one is precious, write it back... except if it's the same as the new one, in which
# case we don't bother.
sub value_in_location_will_be_replaced_with(location: uint8,
        oldvalue: [EffectiveAddress], newvalue: [EffectiveAddress])
	$if DEBUG
		print("* location 0x");
		print_hex_i8(location);
		print(" is changing from ");
		print_ea(oldvalue);
		print(" to ");
		print_ea(newvalue);
		print_newline();
	$endif

    if is_same_ea_ignoring_type(oldvalue, newvalue) != 0 then
        # This means that the value is changing. Don't consider it to be precious any more
        # (because it's about to change).
		$if DEBUG
			print("* value is no longer precious\n");
		$endif

        value_is_not_precious(oldvalue);
        value_is_changing(oldvalue);
    end if;

    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        var locations: uint8 := value.locations;
        if locations == (location|PRECIOUS) then
            # This location contains the only copy of a precious value, so write it back.
			$if DEBUG
				print("* writing back only copy of precious value ");
				print_ea(&value.ea);
				print_newline();
			$endif

            write_back_precious_value(location, &value.ea);
            value.locations := 0;
        elseif (locations&location) != 0 then
			$if DEBUG
				print("* non-precious value ");
				print_ea(&value.ea);
				print(" is no longer cached in 0x");
				print_hex_i8(location);
				print_newline();
			$endif

            value.locations := locations^location;
        end if;
        i := i + 1;
    end loop;
end sub;

sub allocate_reg_for_value(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := allocate_reg(candidates);
    flush_cached_values(location);
    value_is_cached_in_reg(ea, location);
end sub;

sub find_or_load_primitive_value(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := move_value_to_reg(ea, candidates);
    if location != 0 then
        return;
    end if;
    
    location := allocate_reg_for_value(ea, candidates);
    load_saveable_object(ea, location);
end sub;

sub find_or_load_int(value: uint8, candidates: uint8): (location: uint8)
    var ea: EffectiveAddress;
    zero_ea(&ea);
    ea.obj_id := add_number_by_value(value as int32);
    location := find_or_load_primitive_value(&ea, candidates);
end sub;

sub find_or_load_fixed_int(value: uint8, candidates: uint8)
    var location: uint8 := find_or_load_int(value, candidates);
end sub;

sub find_or_load_objval(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := move_value_to_reg(ea, candidates);
    if location != 0 then
        return;
    end if;
    location := allocate_reg_for_value(ea, candidates);
    load_saveable_object(ea, location);
end sub;

# Loads *just the index part* of the EA into a register.
sub find_or_load_index(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    var indexea: EffectiveAddress;
    indexea.flags := EA_VALUE;
    indexea.varoff_id := 0;
    indexea.numoff_id := 0;
    if ea.varoff_id != 0 then
        indexea.obj_id := ea.varoff_id;
        ea.varoff_id := 0;
    else
        if ea.numoff_id == 0 then
            indexea.obj_id := add_number_by_value(0);
        else
            indexea.obj_id := ea.numoff_id;
        end if;
        ea.numoff_id := 0;
    end if;
    indexea.type_id := uint8_type;

	$if DEBUG
		print("* loading index value ");
		print_ea(&indexea);
		print_newline();
	$endif

    location := find_or_load_objval(&indexea, candidates);
end sub;

sub setup_insn(ea: [EffectiveAddress], offset: uint8, location: uint8): (indexreg: uint8)
    insn_init_from_ea(ea);
    indexreg := 0;
    if insn.mode == MODE_IMMLO then
        insn.mode := insn.mode + (offset as uint8);
    else
        insn.offset := insn.offset + (offset as uint16);
        if insn.mode == MODE_IND then
            if insn.offset > 0xff then
                print("offset too big");
                halt();
            end if;

            sub load_index(candidates: uint8)
                var indexea: EffectiveAddress;
                zero_ea(&indexea);
                indexea.obj_id := ea.varoff_id;
                indexea.type_id := uint8_type;
                indexreg := find_or_load_primitive_value(&indexea, candidates);
                insn.indexreg := indexreg;
            end sub;

            if ea.varoff_id != 0 then
                if insn.offset != 0 then
                    print("varoff and numoff in ea");
                    halt();
                end if;
                load_index(REG_Y);
            else
                find_or_load_fixed_int(insn.offset as uint8, REG_Y);
            end if;
            insn.offset := 0;
            insn.indexreg := REG_Y;
            indexreg := REG_Y;
        elseif (insn.mode == MODE_DIR) and (ea.varoff_id != 0) then
            load_index(REG_X|REG_Y);
        end if;
    end if;
    insn.datareg := location;
end sub;

sub find_or_load_value(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    $if DEBUG
        print("* loading ");
        print_ea(ea);
        print(" into 0x");
        print_hex_i8(candidates);
        print_newline();
    $endif

    location := move_value_to_reg(ea, candidates);
    if location != 0 then
        return;
    end if;

    var oldcandidates: uint8;
    if ea.flags == EA_DEREF then    
        oldcandidates := candidates;
        candidates := REG_A;
    end if;

    var storage: Insn;
    save_insn(&storage);
    location := allocate_reg_for_value(ea, candidates);
    var indexreg: uint8 := setup_insn(ea, 0, location);
    insn_load_object();
    free_reg(indexreg);
    load_insn(&storage);

    if (ea.flags == EA_DEREF) and ((oldcandidates & REG_A) == 0) then
        location := move_value_to_reg(ea, oldcandidates);
        free_reg(REG_A);
    end if;
end sub;

sub find_or_load_fixed_value(ea: [EffectiveAddress], candidates: uint8)
    var location: uint8 := find_or_load_value(ea, candidates);
end sub;

sub save_value(location: uint8, ea: [EffectiveAddress])
    $if DEBUG
        print("* saving 0x");
        print_hex_i8(location);
        print(" into ");
        print_ea(ea);
        print_newline();
    $endif

    var oldlocation: uint8;
    if ea.flags == EA_DEREF then    
        oldlocation := location;
        if location != REG_A then
            $if DEBUG
                print("* moving value because we can't save this register\n");
                print_cache();
            $endif
            allocate_fixed_reg(REG_A);
            t_reg_reg(location, REG_A);
            location := REG_A;
        end if;
    end if;

    var storage: Insn;
    save_insn(&storage);
    var indexreg: uint8 := setup_insn(ea, 0, location);
    insn_save_object();
    free_reg(indexreg);
    load_insn(&storage);

    if (ea.flags == EA_DEREF) and (oldlocation != REG_A) then    
        free_reg(location);
        value_is_cached_in_reg(ea, location);
    end if;
end sub;

sub aluop_objval(ea: [EffectiveAddress], opcode: uint8)
    if is_number_thing(ea.obj_id) != 0 then
        op_imm(get_value_of_number(ea.obj_id) as uint8, opcode & 0xFB);
    else
        var indexreg: uint8 := 0;
        if ea.varoff_id != 0 then
            indexreg := find_or_load_index(ea, REG_X|REG_Y);
            opcode := opcode | 0x10;
            if indexreg == REG_Y then
                opcode := opcode & 0xFB;
            end if;
        end if;

        op_abs(ea, opcode);

        free_reg(indexreg);
    end if;
end sub;

sub aluop_deref(ea: [EffectiveAddress], opcode: uint8)
    var indexreg: uint8 := find_or_load_index(ea, REG_Y);
    opcode := (opcode | 0x10) & 0xF3;
    ea.varoff_id := 0;
    ea.numoff_id := 0;

    op_ind(ea, opcode);

    free_reg(indexreg);
end sub;

sub make_value_precious_or_save_now(location: uint8, ea: [EffectiveAddress])
    if (ea.varoff_id != 0) or (ea.flags == EA_DEREF) then
		$if DEBUG
			print("* value ");
			print_ea(ea);
			print(" can't be made precious, saving now\n");
		$endif

        save_value(location, ea);

        if ea.flags != EA_DEREF then
            value_is_cached_in_reg(ea, location);
        end if;
    else
        value_is_cached_in_reg(ea, location);
        value_is_precious(ea);
    end if;
end sub;
