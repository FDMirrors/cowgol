%{
	#include "globals.h"
	#include "emitter.h"
	#include "midcodes.h"
	#include "compiler.h"
	#include "parser.h"
	#include <bsd/string.h>
	#include <ctype.h>

	#define IMPL
	#include "codegen.h"

	#define E emitter_printf
	static char asmbuffer[80];

	static int id = 1;
	static Symbol* uint32_type;
	static Symbol* int32_type;
	static Symbol* int16_type;
	static Symbol* uint16_type;
	static Symbol* int8_type;

	void arch_init_types(void)
	{
		uint32_type = make_number_type("uint32", 4, false);
		int32_type = make_number_type("int32", 4, true);
		uint16_type = make_number_type("uint16", 2, false);
		int16_type = make_number_type("int16", 2, true);
		uint8_type = make_number_type("uint8", 1, false);
		int8_type = make_number_type("int8", 1, true);

		intptr_type = uint16_type;
		add_alias(NULL, "intptr", intptr_type);
	}

	uint32_t arch_align_up(uint32_t value, uint8_t alignment)
	{
		return value;
	}

	Symbol* arch_guess_int_type(uint32_t min, uint32_t max)
	{
		if ((min >= 0) && (max <= 255))
			return uint8_type;
		if ((min >= -128) && (max <= 127))
			return int8_type;
		if ((min >= 0) && (max <= 65535))
			return uint16_type;
		if ((min >= -32768) && (max <= 32767))
			return int16_type;
		if (min >= 0)
			return uint32_type;
		return int32_type;
	}

	void arch_init_subroutine(struct subroutine* sub) {}

	void arch_init_variable(struct symbol* var)
	{
		/* All variables get allocated from workspace 0. */
		var->u.var.offset = current_sub->workspace[0];
		current_sub->workspace[0] += var->u.var.type->u.type.width;
	}

	void arch_init_member(struct symbol* record, struct symbol* member, int position)
	{
		if (position == -1)
			position = record->u.type.width;
		member->u.var.offset = position;
		position += member->u.var.type->u.type.width;
		if (position > record->u.type.width)
			record->u.type.width = position;
	}

	static const char* regref(reg_t reg)
	{
		switch (reg)
		{
			case REG_A: return "a";
			case REG_B: return "b";
			case REG_D: return "d";
			case REG_H: return "h";
			case REG_BC: return "b";
			case REG_DE: return "d";
			case REG_HL: return "h";
			default: fatal("unknown register id 0x%x", reg);
		}
	}

	static const char* stkref(reg_t reg)
	{
		if (reg == REG_A)
			return "psw";
		return regref(reg);
	}

	static const char* regreflo(reg_t reg)
	{
		switch (reg)
		{
			case REG_BC: return "c";
			case REG_DE: return "e";
			case REG_HL: return "l";
			default: assert(false);
		}
	}

	static const char* subref(Subroutine* sub)
	{
		if (sub->externname)
			return sub->externname;
		
		static char buffer[32];
		snprintf(buffer, sizeof(buffer), "f%d", sub->id);
		return buffer;
	}

	static const char* symref(Symbol* sym, int32_t off)
	{
		static char buffer[32];
		if (sym->u.var.externname)
			snprintf(buffer, sizeof(buffer), "%s+%d",
				sym->u.var.externname, off);
		else
			snprintf(buffer, sizeof(buffer), "w%d%+d",
				sym->u.var.sub->id,
				sym->u.var.offset + off);
		return buffer;
	}

	static const char* labelref(int label)
	{
		static char buffer[32];
		snprintf(buffer, sizeof(buffer), "x%d", label);
		return buffer;
	}

	/* Note! This is allowed to destroy the source register. */
	void arch_emit_move(reg_t src, reg_t dest)
	{
		if (!src)
			E("\tpop %s\n", stkref(dest));
		else if (!dest)
			E("\tpush %s\n", stkref(src));
		else
		{
			if (((src == REG_HL) && (dest == REG_DE)) ||
			    ((src == REG_DE) && (dest == REG_HL)))
				E("\txchg\n");
			else
			{
				E("\tmov %s, %s\n", regref(dest), regref(src));
				if (src & (REG_HL|REG_BC|REG_DE))
					E("\tmov %s, %s\n", regreflo(dest), regreflo(src));
			}
		}
	}

	void arch_emit_comment(const char* text, ...)
	{
		va_list ap;
		va_start(ap, text);
		emitter_printf("\t; ");
		emitter_vprintf(text, ap);
		emitter_printf("\n");
		va_end(ap);
	}
%}

register a b d h hl de bc;
register stk4 param;

regdata a compatible a|b|d|h;
regdata b uses bc compatible a|b|d|h;
regdata d uses de compatible a|b|d|h;
regdata h uses hl compatible a|b|d|h;
regdata bc uses bc compatible bc|de|hl;
regdata de uses de compatible bc|de|hl;
regdata hl uses hl compatible bc|de|hl;
regdata stk4 stacked;
regdata param stacked;

gen STARTFILE()
{
    emitter_open_chunk();
    E("\textrn add4\n");
    E("\textrn sub4\n");
    E("\textrn neg4\n");
	E("\textrn mul1\n");
	E("\textrn mul2\n");
	E("\textrn mul4\n");
	E("\textrn dvrmu1\n");
	E("\textrn dvrms1\n");
	E("\textrn dvrmu2\n");
	E("\textrn dvrms2\n");
	E("\textrn dvrmu4\n");
	E("\textrn dvrms4\n");
	E("\textrn divu4\n");
	E("\textrn divs4\n");
	E("\textrn remu4\n");
	E("\textrn rems4\n");
    E("\textrn cpy4\n");
    E("\textrn asl1\n");
    E("\textrn asl2\n");
	E("\textrn asl4\n");
	E("\textrn lsr1\n");
	E("\textrn lsr2\n");
	E("\textrn lsr4\n");
	E("\textrn asr1\n");
	E("\textrn asr2\n");
	E("\textrn asr4\n");
	E("\textrn and4\n");
	E("\textrn or4\n");
	E("\textrn eor4\n");
	E("\textrn not4\n");
	E("\textrn cmpu4\n");
	E("\textrn load4\n");
	E("\textrn store4\n");
    emitter_close_chunk(NULL);
}

gen ENDFILE();

gen STARTSUB():s
{
    emitter_open_chunk();
    E("\n");
    E("; %s\n", $s.sub->name);
    E("\tcseg\n");
    if ($s.sub->externname)
        E("\tpublic %s\n", $s.sub->externname);
    E("%s:\n", subref($s.sub));

    if ($s.sub->inputparameters != 0)
    {
        E("\tpop b\n");
        for (int i=$s.sub->inputparameters-1; i>=0; i--)
        {
			Symbol* param = get_input_parameter($s.sub, i);

			switch (param->u.var.type->u.type.width)
			{
				case 1:
					E("\tpop psw\n");
					E("\tsta %s\n", symref(param, 0));
					break;

				case 2:
					E("\tpop h\n");
					E("\tshld %s\n", symref(param, 0));
					break;

				case 4:
					E("\tpop h\n");
					E("\tshld %s\n", symref(param, 0));
					E("\tpop h\n");
					E("\tshld %s\n", symref(param, 2));
					break;

				default:
					assert(false);
			}
        }
        E("\tpush b\n");
    }
}

gen ENDSUB():s
{
	E("end_%s:\n", subref($s.sub));
	switch ($s.sub->outputparameters)
	{
		case 0:
			E("\tret\n");
			break;

		case 1:
		{
			struct symbol* param = get_output_parameter($s.sub, 0);
			switch (param->u.var.type->u.type.width)
			{
				case 1:
					E("\tlda %s\n", symref(param, 0));
					break;

				case 4:
					E("\tlhld %s\n", symref(param, 2));
					E("\txchg\n");
					/* fall through */
				case 2:
					E("\tlhld %s\n", symref(param, 0));
					break;

				default:
					assert(false);
			}
			E("\tret\n");
			break;
		}

		default:
			E("\tpop h\n");
			E("\txchg\n"); /* put return address in DE */

			for (int i=0; i<$s.sub->outputparameters; i++)
			{
				struct symbol* param = get_output_parameter($s.sub, i);

				switch (param->u.var.type->u.type.width)
				{
					case 1:
						E("\tlda %s\n", symref(param, 0));
						E("\tpush psw\n");
						break;

					case 4:
						E("\tlhld %s\n", symref(param, 2));
						E("\tpush h\n");
						/* fall through */
					case 2:
						E("\tlhld %s\n", symref(param, 0));
						E("\tpush h\n");
						break;

					default:
						assert(false);
				}
			}

			E("\txchg\n");
			E("\tpchl\n");
			break;
	}

    E("\tdseg\n");
	E("w%d: ds %d\n", $s.sub->id, $s.sub->workspace[0]);
    emitter_close_chunk(current_sub);
}

// --- Control flow ------------------------------------------------------

gen RETURN()
{
	E("\tjmp end_%s\n", subref(current_sub));
}

gen LABEL():b
{
	E("%s:\n", labelref($b.label));
}

gen JUMP():j
{
	E("\tjmp %s\n", labelref($j.label));
}

// --- Subroutines -------------------------------------------------------

// SETPARAM leaves the parameter on the top of the stack, where the
// code generator loses track of it.

gen param := END();

gen param := PUSHPARAM1(param, a|b|d|h:lhs)
	{ E("\tpush %s\n", stkref($lhs)); }

gen param := PUSHPARAM2(param, bc|de|hl:lhs)
	{ E("\tpush %s\n", stkref($lhs)); }

gen param := PUSHPARAM4(param, stk4);

%{
	static void call(Subroutine* sub)
	{
		if (sub->externname)
		{
			emitter_open_chunk();
			E("\textrn %s\n", sub->externname);
			emitter_close_chunk(current_sub);
		}

		arch_emit_comment("subroutine with %d input parameters", sub->inputparameters);
		E("\tcall %s\n", subref(sub));
	}
%}

gen CALLS(param);

// Single return values go in registers.

gen CALLS(POPPARAM1(CALL0(param):c, ADDRESS():a)) uses bc|de|hl
{
	call($c.sub);
	E("\tsta %s\n", symref($a.sym, $a.off));
}

gen CALLS(POPPARAM2(CALL0(param):c, ADDRESS():a)) uses bc|de
{
	call($c.sub);
	E("\tshld %s\n", symref($a.sym, $a.off));
}

gen CALLS(POPPARAM4(CALL0(param):c, ADDRESS():a)) uses bc|de
{
	call($c.sub);
	E("\tshld %s\n", symref($a.sym, $a.off+0));
	E("\txchg\n");
	E("\tshld %s\n", symref($a.sym, $a.off+2));
}

gen a := CALL1(param):c uses bc|de|hl
	{ call($c.sub); }

gen hl := CALL2(param):c uses a|bc|de
	{ call($c.sub); }

gen stk4 := CALL4(param):c uses a|bc
{
	call($c.sub);
	E("\tpush d\n");
	E("\tpush h\n");
}

gen param := CALL0(param):c uses a|bc|de|hl
	{ call($c.sub); }

gen param := POPPARAM1(param, ADDRESS():a) uses a
{
	E("\tpop psw\n");
	E("\tsta %s\n", symref($a.sym, $a.off));
}

gen param := POPPARAM2(param, ADDRESS():a) uses hl
{
	E("\tpop hl\n");
	E("\tshld %s\n", symref($a.sym, $a.off));
}

gen param := POPPARAM4(param, ADDRESS():a) uses hl
{
	E("\tpop hl\n");
	E("\tshld %s\n", symref($a.sym, $a.off+0));
	E("\tpop hl\n");
	E("\tshld %s\n", symref($a.sym, $a.off+2));
}

// --- Loads and stores --------------------------------------------------

%{
	static void load1(reg_t rhs)
	{
		switch (rhs)
		{
			case REG_BC:
				E("\tldax b\n");
				break;

			case REG_DE:
				E("\tldax d\n");
				break;

			case REG_HL:
				E("\tmov a, m\n");
				break;

			default:
				assert(false);
		}
	}
%}

gen a := LOAD1(bc|de|hl:lhs)
	{ load1($lhs); }

gen a := LOAD1(ADDRESS():a)
	{ E("\tlda %s\n", symref($a.sym, $a.off)); }

gen a := LOAD1(CONSTANT():c)
	{ E("\tlda 0x%x\n", $c.value); }

gen hl|bc|de := LOAD2(hl:lhs) uses a
{
	if ($$ == REG_HL)
	{
		E("\tmov a, m\n");
		E("\tinx h\n");
		E("\tmov h, m\n");
		E("\tmov l, a\n");
	}
	else
	{
		E("\tmov %s, m\n", regreflo($$));
		E("\tinx h\n");
		E("\tmov %s, m\n", regref($$));
	}
}

gen hl := LOAD2(ADDRESS():a)
	{ E("\tlhld %s\n", symref($a.sym, $a.off)); }

gen hl := LOAD2(CONSTANT():c)
	{ E("\tlhld 0x%x\n", $c.value); }

gen stk4 := LOAD4(ADDRESS():a) uses hl
{
	E("\tlhld %s\n", symref($a.sym, $a.off+2));
	E("\tpush h\n");
	E("\tlhld %s\n", symref($a.sym, $a.off+0));
	E("\tpush h\n");
}

gen stk4 := LOAD4(hl) uses bc|de
	{ E("\tcall load4\n"); }

gen STORE1(a, bc|de|hl:val)
{
	switch ($val)
	{
		case REG_BC:
			E("\tstax b\n");
			break;

		case REG_DE:
			E("\tstax d\n");
			break;

		case REG_HL:
			E("\tmov m, a\n");
			break;

		default:
			assert(false);
	}
}

gen STORE2(bc|de:val, hl) uses a
{
	E("\tmov m, %s\n", regreflo($val));
	E("\tinx h\n");
	E("\tmov m, %s\n", regref($val));
}

gen STORE2(CONSTANT():c, hl)
{
	E("\tmvi m, %d\n", $c.value & 0xff);
	E("\tinx h\n");
	E("\tmvi m, %d\n", ($c.value >> 8) & 0xff);
}

gen STORE1(a, ADDRESS():a)
	{ E("\tsta %s\n", symref($a.sym, $a.off)); }

gen STORE2(hl, ADDRESS():a)
	{ E("\tshld %s\n", symref($a.sym, $a.off)); }

gen STORE2(CONSTANT():c, ADDRESS():a) uses hl
{
	E("\tlxi h, %d\n", $c.value & 0xffff);
	E("\tshld %s\n", symref($a.sym, $a.off));
}

gen STORE4(stk4, hl) uses bc|de
	{ E("\tcall store4\n"); }

gen STORE4(stk4, ADDRESS():a) uses hl
{
	E("\tpop h\n"); 
	E("\tshld %s\n", symref($a.sym, $a.off+0));
	E("\tpop h\n"); 
	E("\tshld %s\n", symref($a.sym, $a.off+2));
}

gen STORE4(CONSTANT():c, ADDRESS():a) uses hl
{
	E("\tlxi h, %d\n", $c.value & 0xffff);
	E("\tshld %s\n", symref($a.sym, $a.off+0));
	E("\tlxi h, %d\n", ($c.value >> 16) & 0xffff);
	E("\tshld %s\n", symref($a.sym, $a.off+2));
}

gen a := CONSTANT(value==0)
	{ E("\txra a\n"); }

gen a|b|d|h := CONSTANT():rhs
	{ E("\tmvi %s, %d\n", regref($$), $rhs.value); }

gen bc|de|hl := CONSTANT():rhs
	{ E("\tlxi %s, %d\n", regref($$), $rhs.value); }

gen bc|de|hl := ADDRESS():rhs
	{ E("\tlxi %s, %s\n", regref($$), symref($rhs.sym, $rhs.off)); }

gen stk4 := CONSTANT():c uses hl
{
	E("\tlxi h, %d\n", ($c.value >> 16) & 0xffff);
	E("\tpush h\n");
	E("\tlxi h, %d\n", $c.value & 0xffff);
	E("\tpush h\n");
}

// --- 8-bit arithmetic -----------------------------------------------------

gen a := ADD1(a, b|d|h:rhs)
	{ E("\tadd %s\n", regref($rhs)); }

gen a := ADD1(a, CONSTANT():rhs)
	{ E("\tadi %d\n", $rhs.value); }

gen a|b|d|h := ADD1($$, CONSTANT(value==1))
	{ E("\tinc %s\n", regref($$)); }

gen a|b|d|h := ADD1($$, CONSTANT(value==2))
{
	E("\tinc %s\n", regref($$));
	E("\tinc %s\n", regref($$));
}

gen a|b|d|h := ADD1($$, CONSTANT(value==-1))
	{ E("\tdec %s\n", regref($$)); }

gen a|b|d|h := ADD1($$, CONSTANT(value==-2))
{
	E("\tdec %s\n", regref($$));
	E("\tdec %s\n", regref($$));
}

gen a := SUB1(a, b|d|h:rhs)
	{ E("\tsub %s\n", regref($rhs)); }

gen a := SUB1(a, CONSTANT():rhs)
	{ E("\tsbi %d\n", $rhs.value); }

gen a := NEG1(b|d|h:lhs)
{
	E("\txra a\n");
	E("\tsub %s\n", regref($lhs));
}

gen a := MUL1(b, d)
	{ E("\tcall mul1\n"); }
	
gen b := DIVU1(b, d) uses a
	{ E("\tcall dvrmu1\n"); }

gen a := REMU1(b, d)
	{ E("\tcall dvrmu1\n"); }

gen b := DIVS1(b, d) uses a
	{ E("\tcall dvrms1\n"); }

gen d := REMS1(b, d) uses a
	{ E("\tcall dvrms1\n"); }

gen a := LSHIFT1(a, b) uses bc
	{ E("\tcall asl1\n"); }

gen a := RSHIFTU1(a, b) uses bc
	{ E("\tcall lsr1\n"); }

gen a := RSHIFTS1(a, b) uses bc
	{ E("\tcall asr1\n"); }

gen a := AND1(a, b|d|h:rhs)
	{ E("\tand %s\n", regref($rhs)); }

gen a := OR1(a, b|d|h:rhs)
	{ E("\tora %s\n", regref($rhs)); }

gen a := EOR1(a, b|d|h:rhs)
	{ E("\txra %s\n", regref($rhs)); }

gen a := NOT1(a)
	{ E("\txri -1\n"); }

gen a := AND1(a, CONSTANT():c)
	{ E("\tani %d\n", $c.value & 0xff); }

// --- 16-bit arithmetic ----------------------------------------------------

gen hl := ADD2(hl|bc|de:lhs, hl|bc|de:rhs)
{ 
	if (($rhs != REG_HL) && ($lhs != REG_HL))
	{
		if ($rhs == REG_DE)
		{
			E("\txchg\n");
			$rhs = REG_HL;
		}
		else if ($lhs == REG_DE)
		{
			E("\txchg\n");
			$lhs = REG_HL;
		}
		else
		{
			E("\tmov h, %s\n", regref($lhs));
			E("\tmov l, %s\n", regreflo($lhs));
			$lhs = REG_HL;
		}
	}
		
	E("\tdad %s\n", regref(($lhs != REG_HL) ? $lhs : $rhs));
}

gen hl|bc|de := ADD2($$, CONSTANT(value==1))
	{ E("\tinx %s\n", regref($$)); }

gen hl|bc|de := ADD2($$, CONSTANT(value==2))
{
	E("\tinx %s\n", regref($$));
	E("\tinx %s\n", regref($$));
}

gen hl|bc|de := ADD2($$, CONSTANT(value==-1))
	{ E("\tdcx %s\n", regref($$)); }

gen hl|bc|de := ADD2($$, CONSTANT(value==-2))
{
	E("\tdcx %s\n", regref($$));
	E("\tdcx %s\n", regref($$));
}

gen bc|de|hl := SUB2(bc|de|hl:lhs, bc|de|hl:rhs) uses a
{
    E("\tmov a, %s\n", regreflo($lhs));
    E("\tsub %s\n", regreflo($rhs));
    E("\tmov %s, a\n", regreflo($$));
    E("\tmov a, %s\n", regref($lhs));
    E("\tsbb %s\n", regref($rhs));
    E("\tmov %s, a\n", regref($$));
}

gen bc|de|hl := NEG2(bc|de|hl:lhs) uses a
{
    E("\txra a\n");
    E("\tsub %s\n", regreflo($lhs));
    E("\tmov %s, a\n", regreflo($$));
	E("\tsbb a\n");
    E("\tsub %s\n", regref($lhs));
    E("\tmov %s, a\n", regref($$));
}

gen hl := MUL2(bc, de) uses a
	{ E("\tcall mul2\n"); }

gen de := DIVU2(de, bc) uses a
	{ E("\tcall dvrmu2\n"); }

gen hl := REMU2(de, bc) uses a
	{ E("\tcall dvrmu2\n"); }

gen de := DIVS2(de, bc) uses a
	{ E("\tcall dvrms2\n"); }

gen hl := REMS2(de, bc) uses a
	{ E("\tcall dvrms2\n"); }

gen bc|de|hl := OR2(bc|de|hl:lhs, bc|de|hl:rhs) uses a
{
	E("\tmov a, %s\n", regreflo($lhs));
	E("\tora %s\n", regreflo($rhs));
	E("\tmov %s, a\n", regreflo($$));
	E("\tmov a, %s\n", regref($lhs));
	E("\tora %s\n", regref($rhs));
	E("\tmov %s, a\n", regref($$));
}

gen bc|de|hl := AND2(bc|de|hl:lhs, bc|de|hl:rhs) uses a
{
	E("\tmov a, %s\n", regreflo($lhs));
	E("\tana %s\n", regreflo($rhs));
	E("\tmov %s, a\n", regreflo($$));
	E("\tmov a, %s\n", regref($lhs));
	E("\tana %s\n", regref($rhs));
	E("\tmov %s, a\n", regref($$));
}

gen bc|de|hl := EOR2(bc|de|hl:lhs, bc|de|hl:rhs) uses a
{
	E("\tmov a, %s\n", regreflo($lhs));
	E("\txra %s\n", regreflo($rhs));
	E("\tmov %s, a\n", regreflo($$));
	E("\tmov a, %s\n", regref($lhs));
	E("\txra %s\n", regref($rhs));
	E("\tmov %s, a\n", regref($$));
}

gen bc|de|hl := NOT2(bc|de|hl:lhs) uses a
{
	E("\tmov a, %s\n", regreflo($lhs));
	E("\tcpl\n");
	E("\tmov %s, a\n", regreflo($$));
	E("\tmov a, %s\n", regref($lhs));
	E("\tcpl\n");
	E("\tmov %s, a\n", regref($$));
}

gen hl := LSHIFT2(hl, b) uses a
	{ E("\tcall asl2\n"); }

gen hl := RSHIFTU2(hl, b) uses a
	{ E("\tcall lsr2\n"); }

gen hl := RSHIFTS2(hl, b) uses a
	{ E("\tcall asr2\n"); }

// --- 32-bit arithmetic ----------------------------------------------------

gen stk4 := ADD4(stk4, stk4) uses a|bc|de|hl
	{ E("\tcall add4\n"); }

gen stk4 := SUB4(stk4, stk4) uses a|bc|de|hl
	{ E("\tcall sub4\n"); }

gen stk4 := NEG4(stk4) uses a|bc|de|hl
	{ E("\tcall neg4\n"); }

gen stk4 := MUL4(stk4, stk4) uses a|bc|de|hl
	{ E("\tcall mul4\n"); }

gen stk4 := DIVU4(stk4, stk4) uses a|bc|de|hl
	{ E("\tcall divu4\n"); }

gen stk4 := REMU4(stk4, stk4) uses a|bc|de|hl
	{ E("\tcall remu4\n"); }

gen stk4 := DIVS4(stk4, stk4) uses a|bc|de|hl
	{ E("\tcall divs4\n"); }

gen stk4 := REMS4(stk4, stk4) uses a|bc|de|hl
	{ E("\tcall rems4\n"); }

gen stk4 := AND4(stk4, stk4) uses a|bc|de|hl
	{ E("\tcall and4\n"); }

gen stk4 := OR4(stk4, stk4) uses a|bc|de|hl
	{ E("\tcall or4\n"); }

gen stk4 := EOR4(stk4, stk4) uses a|bc|de|hl
	{ E("\tcall eor4\n"); }

gen stk4 := NOT4(stk4) uses a|bc|de|hl
	{ E("\tcall not4\n"); }

gen stk4 := LSHIFT4(stk4, b) uses a|de|hl
	{ E("\tcall asl4\n"); }

gen stk4 := RSHIFTU4(stk4, b) uses a|de|hl
	{ E("\tcall lsr4\n"); }

gen stk4 := RSHIFTS4(stk4, b) uses a|de|hl
	{ E("\tcall asr4\n"); }

// --- Branches -------------------------------------------------------------

%{
	static void bequ1(int truelabel, int falselabel, reg_t nota)
	{
		E("\tcmp %s\n", regref(nota));
		E("\tjz %s\n", labelref(truelabel));
		E("\tjnz %s\n", labelref(falselabel));
	}
%}

gen BEQU1(b|d|h:nota, a):b
	{ bequ1($b.truelabel, $b.falselabel, $nota); }

gen BEQS1(b|d|h:nota, a):b
	{ bequ1($b.truelabel, $b.falselabel, $nota); }

%{
	static void bequ1c(int truelabel, int falselabel, int c)
	{
		if (!c)
			E("\tora a\n");
		else
			E("\tcpi %d\n", c);
		E("\tjz %s\n", labelref(truelabel));
		E("\tjnz %s\n", labelref(falselabel));
	}
%}
	
gen BEQU1(a, CONSTANT():c):b
	{ bequ1c($b.truelabel, $b.falselabel, $c.value); }

gen BEQS1(a, CONSTANT():c):b
	{ bequ1c($b.truelabel, $b.falselabel, $c.value); }

gen BEQU1(CONSTANT():c, a):b
	{ bequ1c($b.truelabel, $b.falselabel, $c.value); }

gen BEQS1(CONSTANT():c, a):b
	{ bequ1c($b.truelabel, $b.falselabel, $c.value); }

gen BLTU1(a, CONSTANT():c):b
{
	E("\tcpi %d\n", $c.value);
	E("\tjc %s\n", labelref($b.truelabel));
	E("\tjmp %s\n", labelref($b.falselabel));
}

gen BLTU1(a, b|d|h:rhs):b
{
	E("\tcmp %s\n", regref($rhs));
	E("\tjc %s\n", labelref($b.truelabel));
	E("\tjmp %s\n", labelref($b.falselabel));
}

%{
	static void bequ2(int truelabel, int falselabel, reg_t lhs, reg_t rhs)
	{
		E("\tmov a, %s\n", regref(lhs));
		E("\tcmp %s\n", regref(rhs));
		E("\tjnz %s\n", labelref(falselabel));
		E("\tmov a, %s\n", regreflo(lhs));
		E("\tcmp %s\n", regreflo(rhs));
		E("\tjnz %s\n", labelref(falselabel));
		E("\tjmp %s\n", labelref(truelabel));
	}
%}

gen BEQU2(hl|bc|de:lhs, hl|bc|de:rhs):b
	{ bequ2($b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BEQS2(hl|bc|de:lhs, hl|bc|de:rhs):b
	{ bequ2($b.truelabel, $b.falselabel, $lhs, $rhs); }

%{
	static void bequ2c(int truelabel, int falselabel, reg_t lhs, int c)
	{
		if (c != 0)
		{
			E("\tlxi d, 0x%x\n", (-c) & 0xffff);
			E("\tdad d\n");
		}
		E("\tmov a, l\n");
		E("\tora h\n");
		E("\tjnz %s\n", labelref(falselabel));
		E("\tjmp %s\n", labelref(truelabel));
	}
%}

gen BEQU2(hl:lhs, CONSTANT():rhs):b uses de|a
	{ bequ2c($b.truelabel, $b.falselabel, $lhs, $rhs.value); }

gen BEQS2(hl:lhs, CONSTANT():rhs):b uses de|a
	{ bequ2c($b.truelabel, $b.falselabel, $lhs, $rhs.value); }

gen BEQU2(CONSTANT():lhs, hl:rhs):b uses de|a
	{ bequ2c($b.truelabel, $b.falselabel, $rhs, $lhs.value); }

gen BEQS2(CONSTANT():lhs, hl:rhs):b uses de|a
	{ bequ2c($b.truelabel, $b.falselabel, $rhs, $lhs.value); }

gen BLTU2(hl|bc|de:lhs, hl|bc|de:rhs):b uses a
{
	E("\tmov a, %s\n", regreflo($lhs));
	E("\tsub %s\n", regreflo($rhs));
	E("\tmov a, %s\n", regref($lhs));
	E("\tsbb %s\n", regref($rhs));
	E("\tjc %s\n", labelref($b.truelabel));
	E("\tjmp %s\n", labelref($b.falselabel));
}

%{
	static void bequ4(int truelabel, int falselabel, reg_t lhs, reg_t rhs)
	{
		E("\tcall sub4\n");
		E("\tcall cmpu4\n");
		E("\tjnz %s\n", labelref(falselabel));
		E("\tjmp %s\n", labelref(truelabel));
	}
%}

gen BEQU4(stk4:lhs, stk4:rhs):b
	{ bequ4($b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BEQS4(stk4:lhs, stk4:rhs):b
	{ bequ4($b.truelabel, $b.falselabel, $lhs, $rhs); }

// --- Casts ----------------------------------------------------------------

gen hl|bc|de := CAST12(a|b|d|h:rhs)
{
	E("\tmov %s, %s\n", regreflo($$), regref($rhs));
	E("\tmvi %s, 0\n", regref($$));
}

gen hl := CAST12(LOAD1(hl:rhs))
{
	E("\tmov %s, m\n", regreflo($$));
	E("\tmvi %s, 0\n", regref($$));
}

gen stk4 := CAST14(a:rhs) uses hl
{
	E("\tlxi h, 0\n");
	E("\tpush h\n");
	E("\tmov l, a\n");
	E("\tpush h\n");
}

gen a|b|d|h := CAST21(bc|de|hl:rhs)
	{ E("\tmov %s, %s\n", regref($$), regreflo($rhs)); }
	
gen stk4 := CAST24(hl|de:rhs) uses bc
{
	E("\tlxi b, 0\n");
	E("\tpush b\n");
	E("\tpush %s\n", regref($rhs));
}
	
gen a|d := CAST41(stk4) uses hl|bc
{
	E("\tpop b\n");
	E("\tpop h\n");
	E("\tmov %s, c\n", regref($$));
}
	
gen hl|de := CAST42(stk4) uses bc
{
	E("\tpop %s\n", regref($$));
	E("\tpop b\n");
}
	
// --- Case statements ---------------------------------------------------

gen CASE1(a, param) uses bc
{
	int exit_label = current_label++;
	E("\tlxi b, %s\n", labelref(exit_label));
	E("\tpush b\n");

	Node* n = self->n[0]->right;
	while (n->op == MIDCODE_WHEN)
	{
		if (!n->u.when.isdefault)
		{
			E("\tcpi 0x%02x\n", n->u.when.value);
			E("\tjz %s\n", subref(n->u.when.sub));
		}
		n = n->left;
	}

	n = self->n[0]->right;
	while (n->op == MIDCODE_WHEN)
	{
		if (n->u.when.isdefault)
		{
			E("\tjmp %s\n", subref(n->u.when.sub));
			break;
		}
		n = n->left;
	}

	E("%s:\n", labelref(exit_label));
}

gen param := WHEN(param);

// --- Inline assembly ------------------------------------------------------

gen ASMSTART()
{
    asmbuffer[0] = '\0';
}

gen ASMTEXT():t
{
    strlcat(asmbuffer, $t.text, sizeof(asmbuffer));
    strlcat(asmbuffer, " ", sizeof(asmbuffer));
}

gen ASMSYMBOL():s
{
	if ($s.sym->kind == VAR)
		strlcat(asmbuffer, symref($s.sym, 0), sizeof(asmbuffer));
	else
		strlcat(asmbuffer, subref($s.sym->u.sub), sizeof(asmbuffer));
    strlcat(asmbuffer, " ", sizeof(asmbuffer));
}

gen ASMEND()
{
    E("\t%s\n", asmbuffer);
}

// --- Array initialisers ------------------------------------------------

%{
	static int emit_string(const char* s)
	{
		int sid = id++;
		emitter_open_chunk();
		E("\tcseg\n");
		E("s%d:\n", sid);
		E("\tdb ");
		bool instring = false;
		bool start = true;
		for (;;)
		{
			char c = *s++;
			if (!c)
				break;
			if (!start && !instring)
				E(", ");
			start = false;
			if (isprint(c) && (c != '\"') && (c != '\\'))
			{
				if (!instring)
				{
					E("\"");
					instring = true;
				}
				E("%c", c);
			}
			else
			{
				if (instring)
				{
					E("\", ");
					instring = false;
				}
				E("%d", c);
			}
		}
		if (instring)
			E("\"");
		if (!start)
			E(", ");
		E("0\n");
		emitter_close_chunk(current_sub);
		return sid;
	}
%}

gen STARTINIT():s
{
	int sid = id++;
	$s.sym->u.var.externname = aprintf("array%d", sid);

	emitter_open_chunk();
	E("\tcseg\n"); /* yes, really */
	E("%s:\n", $s.sym->u.var.externname);
}
	
gen INIT1():c { E("\tdb %d\n", $c.value); }
gen INIT2():c { E("\tdw %d\n", $c.value); }
gen INIT4():c { E("\tdword %d\n", $c.value); }
gen INITS():s { E("\tdw s%d\n", emit_string($s.text)); }

gen ENDINIT()
{
	emitter_close_chunk(current_sub);
}

// --- Strings -----------------------------------------------------------

gen bc|de|hl := STRING():s
{
    E("\tlxi %s, s%d\n", regref($$), emit_string($s.text));
}

