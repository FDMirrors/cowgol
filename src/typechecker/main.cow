sub print_raw_type_name(type_id: uint16)
    var brackets: uint8 := 0;
    loop
        var ptr_type: [PointerThing] := find_thing(type_id) as [PointerThing];
        if ptr_type.thing_type != THING_POINTER then
            break;
        end if;
        brackets := brackets + 1;
        print_char('[');
        type_id := ptr_type.element_id;
    end loop;

    var id: uint16 := find_name_of_value(type_id);
    if id != 0 then
        show_identifier(id);
    else
        print("<anonymous>");
    end if;

    while brackets > 0 loop
        print_char(']');
        brackets := brackets - 1;
    end loop;
end sub;

sub print_type_name(type_id: uint16)
    var array_type: [ArrayThing] := find_thing(type_id) as [ArrayThing];
    if array_type.thing_type == THING_ARRAY then
        print_raw_type_name(array_type.element_id);
        print_char('[');
        print_i16(array_type.element_count);
        print_char(']');
    else
        print_raw_type_name(type_id);
    end if;
end sub;

sub check_type_assignability(src_type_id: uint16, dest_type_id: uint16)
    var src_type: [TypeThing] := find_thing(src_type_id) as [TypeThing];
    var dest_type: [TypeThing] := find_thing(dest_type_id) as [TypeThing];

    # It's legal to assign any number to any other number.
    if ((src_type.thing_type & THING_NUMERIC) != 0) and
       ((dest_type.thing_type & THING_NUMERIC) != 0) then
        return;
    end if;

    # Otherwise, the type must match exactly.
    if src_type_id != dest_type_id then
        print_type_name(src_type_id);
        print(" cannot be assigned to ");
        print_type_name(dest_type_id);
        halt();
    end if;
end sub;

sub check_type_compatibility(left_type_id: uint16, right_type_id: uint16): (result_type_id: uint16)
    var left_type: [TypeThing] := find_thing(left_type_id) as [TypeThing];
    var right_type: [TypeThing] := find_thing(right_type_id) as [TypeThing];

    if left_type_id == right_type_id then
        result_type_id := left_type_id;
    elseif ((left_type.thing_type & THING_NUMERIC) != 0) and
       ((right_type.thing_type & THING_NUMERIC) != 0) then
        if left_type.width < right_type.width then
            result_type_id := right_type_id;
        else
            result_type_id := left_type_id;
        end if;
        return;
    else
        print_type_name(left_type_id);
        print(" and ");
        print_type_name(right_type_id);
        print(" are not compatible in this context");
        halt();
    end if;
end sub;

sub must_be_simplified(node: [Node])
    if node.iop != IOP_FEX_PUSH then
        print("operation on non-simplified node");
        halt();
    end if;
end sub;

sub alloc_ea_node(ea: [EffectiveAddress]): (node: [Node])
    node := alloc_node();
    node.iop := IOP_FEX_PUSH;
    node.flags := FLAG_RVALUE;
    node.type_id := uint16_type;
    copy_ea_ref(ea, &node.left);
end sub;

sub alloc_const_node(number_id: uint16): (node: [Node])
    node := alloc_node();
    node.iop := IOP_FEX_PUSH;
    node.flags := FLAG_RVALUE;
    node.type_id := uint16_type;
    node.left.obj_id := number_id;
    node.left.type := EA_OBJVAL;
end sub;

sub alloc_thing_node(thing_id: uint16): (node: [Node])
    node := alloc_node();
    node.iop := IOP_FEX_PUSH;
    node.type_id := get_type_of_thing(thing_id);
    node.left.obj_id := thing_id;
    node.left.type := EA_OBJVAL;
    ref_temporary(thing_id);
end sub;

sub gen_operator(beiop: uint8, left: [Node], right: [Node]): (dest: [Node])
    must_be_simplified(left);
    must_be_simplified(right);

    var node: [Node] := alloc_node();
    node.iop := beiop;
    node.type_id := uint16_type;
    node.flags := FLAG_RVALUE;
    copy_ea_ref(&left.left, &node.left);
    copy_ea_ref(&right.left, &node.right);

    dest := simplify_node_to_ea_and_deref(node);
end sub;

sub process_subroutine(thing_id: uint16)
    var subroutine: [SubroutineThing] := find_thing(thing_id) as [SubroutineThing];
    init_tree();
    init_temporaries();
    current_namespace_id := subroutine.namespace_id;

    sub fex_push(iop: [FEPushIop])
        var thing: [Thing] := find_thing(iop.thing_id);
        if thing.thing_type == THING_IDENTIFIER then
            iop.thing_id := deref_symbol_or_fail(iop.thing_id);
            thing := find_thing(iop.thing_id);
        end if;

        var node: [Node] := push_empty_node();

        node.iop := IOP_FEX_PUSH;
        node.left.obj_id := iop.thing_id;
        node.left.type := EA_OBJVAL;
        if thing.thing_type == THING_NUMBER then
            node.type_id := numeric_type;
            node.flags := FLAG_RVALUE;
        elseif thing.thing_type == THING_STRING then
            node.type_id := pointer_of(int8_type);
            node.flags := FLAG_RVALUE;
        elseif (thing.thing_type & THING_TYPED) != 0 then
            var typed_thing: [TypedThing] := thing as [TypedThing];
            if typed_thing.type_id == 0 then
                print("forward reference to type inferred value");
                halt();
            end if;
            node.type_id := typed_thing.type_id;

            var type: [Thing] := find_thing(typed_thing.type_id);
            if (type.thing_type == THING_ARRAY) or (type.thing_type == THING_RECORD) then
                node.left.type := EA_OBJADR;
            end if;
        else
            print("can't push things of type 0x");
            print_hex_i8(thing.thing_type);
            halt();
        end if;
    end sub;

    sub fe_swap()
        var n1: [Node] := pop();
        var n2: [Node] := pop();
        push_node(n1);
        push_node(n2);
    end sub;

    sub fe_assign()
        var src: [Node] := pop();
        var dest: [Node] := simplify_node_to_ea_and_deref(pop());

        if (dest.flags & FLAG_RVALUE) != 0 then
            print("cannot assign to rvalue");
            halt();
        end if;

        check_type_assignability(src.type_id, dest.type_id);
        dest := simplify_node_to_ea_and_deref(dest);
        arch_simplify_node_to(src, dest);
        deref_node(src);
        deref_node(dest);
    end sub;

    sub fe_simple_alu2op(beiop: uint8)
        var right: [Node] := simplify_node_to_ea_and_deref(pop());
        var left: [Node] := simplify_node_to_ea_and_deref(pop());

        var node: [Node] := push_empty_node();
        node.iop := beiop;
        node.flags := FLAG_RVALUE;
        copy_ea_ref(&left.left, &node.left);
        copy_ea_ref(&right.left, &node.right);
        # if you change this, change the non-pointer case in addsub as well
        node.type_id := check_type_compatibility(left.type_id, right.type_id);

        deref_node(right);
        deref_node(left);
    end sub;

    sub fe_simple_alu1op(beiop: uint8)
        var left: [Node] := simplify_node_to_ea_and_deref(pop());

        var left_type: [TypeThing] := find_thing(left.type_id) as [TypeThing];
        if ((left_type.thing_type & THING_NUMERIC) == 0) then
            print("can't do this to non-numeric type ");
            print_type_name(left.type_id);
            halt();
        end if;

        left.iop := beiop;
        left.flags := FLAG_RVALUE;
        push_node(left);
    end sub;

    sub maybe_signed_biop(signed_beiop: uint8, unsigned_beiop: uint8): (beiop: uint8)
        var right: [Node] := peek(1);
        var left: [Node] := peek(2);

        var left_type: [TypeThing] := find_thing(left.type_id) as [TypeThing];
        var right_type: [TypeThing] := find_thing(right.type_id) as [TypeThing];

        var left_signedness: uint8;
        if ((left_type.thing_type == THING_SIGNED) or (left_type.thing_type == THING_NUMERIC))
            and ((right_type.thing_type == THING_SIGNED) or (right_type.thing_type == THING_NUMERIC))
        then
            beiop := signed_beiop;
        else
            beiop := unsigned_beiop;
        end if;
    end sub;

    sub fe_addsub(kind: uint8)
        var right: [Node] := simplify_node_to_ea_and_deref(pop());
        var left: [Node] := simplify_node_to_ea_and_deref(pop());

        var node: [Node] := push_empty_node();
        node.iop := kind;
        node.flags := FLAG_RVALUE;
        copy_ea_ref(&left.left, &node.left);
        copy_ea_ref(&right.left, &node.right);

        var left_type: [PointerThing] := find_thing(left.type_id) as [PointerThing];
        var right_type: [PointerThing] := find_thing(right.type_id) as [PointerThing];
        if left_type.thing_type != THING_POINTER then
            # this is the same as simple_alu2op above
            node.type_id := check_type_compatibility(left.type_id, right.type_id);
        elseif (kind == IOP_BE_SUB)
                and (left_type.thing_type == THING_POINTER)
                and (right_type.thing_type == THING_POINTER) then
            # Pointer difference.
            node.type_id := uint16_type;
        elseif (kind == IOP_BE_ADD)
                and (left_type.thing_type == THING_POINTER)
                and ((right_type.thing_type & THING_NUMERIC) != 0) then
            # Pointer offsetting.
            node.type_id := left.type_id;
        else
            halt();
        end if;

        deref_node(right);
        deref_node(left);
    end sub;

    sub fe_index()
        var right: [Node] := simplify_node_to_ea_and_deref(pop());
        var left: [Node] := simplify_node_to_ea_and_deref(pop());

        var left_type: [WithElementsThing] := find_thing(left.type_id) as [WithElementsThing];
        if (left_type.thing_type != THING_POINTER) and (left_type.thing_type != THING_ARRAY) then
            print_type_name(left.type_id);
            print(" is not indexable");
            halt();
        end if;
        var right_type: [TypeThing] := find_thing(right.type_id) as [TypeThing];
        var element_type: [TypeThing] := find_thing(left_type.element_id) as [TypeThing];

        if (right_type.thing_type & THING_NUMERIC) == 0 then
            print("index must be numeric");
            halt();
        end if;

        var node: [Node] := push_empty_node();
        node.iop := IOP_FEX_PUSH;
        node.type_id := left_type.element_id;

        if (left_type.thing_type != THING_POINTER) and (left_type.thing_type != THING_ARRAY) then
            print("only pointers or arrays can be indexed");
            halt();
        end if;

        print("* left has ea ");
        print_ea(&left.left);
        print_newline();

        copy_ea_ref(&left.left, &node.left);
        if node.left.type == EA_OBJADR then
            node.left.type := EA_OBJVAL;
        elseif (node.left.type == EA_OBJVAL) or (node.left.type == EA_PTRVAL) then
            node := simplify_node_to_var_and_deref(node);
            node.left.type := EA_PTRVAL;
        elseif node.left.type == EA_PTRADR then
            node.left.type := EA_PTRVAL;
        end if;

        print("* result base has ea ");
        print_ea(&node.left);
        print_newline();

        if (right_type.thing_type == THING_NUMERIC) then
            node.left.numoff_id := add_number_by_value(
                get_value_of_number(left.left.numoff_id) +
                    get_value_of_number(right.left.obj_id) * element_type.width);
        else
            var new_delta_node: [Node];
            var delta_node: [Node] := alloc_ea_node(&right.left);
            if element_type.width != 1 then
                var num_node: [Node] := alloc_const_node(add_number_by_value(element_type.width));
                new_delta_node := gen_operator(IOP_BE_MUL, delta_node, num_node);
                deref_node(num_node);
                deref_node(delta_node);
                delta_node := new_delta_node;
            end if;

            if left.left.varoff_id != 0 then
                var old_delta_node: [Node] := alloc_thing_node(left.left.varoff_id);

                print("* calculating new delta from ");
                print_ea(&old_delta_node.left);
                print(" and ");
                print_ea(&delta_node.left);
                print_newline();

                new_delta_node := gen_operator(IOP_BE_ADD, old_delta_node, delta_node);
                deref_node(old_delta_node);
                deref_node(delta_node);
                delta_node := new_delta_node;
            end if;

            delta_node := simplify_node_to_var_and_deref(delta_node);
            node.left.varoff_id := delta_node.left.obj_id;
            ref_temporary(node.left.varoff_id);
            deref_node(delta_node);
        end if;
        deref_node(right);
        deref_node(left);
    end sub;

    sub fe_addressof()
        var node: [Node] := simplify_node_to_ea_and_deref(pop());

        if (node.flags & FLAG_RVALUE) != 0 then
            print("cannot take the address of an rvalue");
            halt();
        end if;

        node.type_id := pointer_of(node.type_id);
        if (node.left.type & EA_DEREF_AFTER) != 0 then
            node.left.type := node.left.type & (EA_DEREF_AFTER ^ -1);
        end if;

        push_node(node);
    end sub;

    sub fex_memberof(iop: [FEMemberIop])
        var node: [Node] := simplify_node_to_ea_and_deref(pop());
        var node_type: [TypeThing] := find_thing(node.type_id) as [TypeThing];

        var type_id: uint16 := node.type_id;
        var type: [Thing] := find_thing(type_id);
        if type.thing_type == THING_POINTER then
            var pointer_type: [PointerThing] := type as [PointerThing];
            type_id := pointer_type.element_id;
            type := find_thing(type_id);

            if (node.left.type & EA_DEREF_AFTER) != 0 then
                node := simplify_node_to_var_and_deref(node);
                node.left.type := EA_PTRVAL;
            end if;
        end if;
        if type.thing_type != THING_RECORD then
            print_type_name(type_id);
            print(" is not a record type or a pointer to a record type");
            halt();
        end if;
        var record_type: [RecordThing] := type as [RecordThing];

        var symbol_id: uint16 := find_symbol_recursively(iop.thing_id, record_type.namespace_id);
        if symbol_id == 0 then
            show_identifier(iop.thing_id);
            print(" is not a member of ");
            print_type_name(type_id);
            halt();
        end if;
        var symbol: [SymbolThing] := find_thing(symbol_id) as [SymbolThing];
        var member: [MemberThing] := find_thing(symbol.value_id) as [MemberThing];
        var member_type_thing: [Thing] := find_thing(member.type_id);

        if (member_type_thing.thing_type == THING_ARRAY)
            or (member_type_thing.thing_type == THING_RECORD)
        then
            node.left.type := node.left.type & (EA_DEREF_AFTER ^ -1);
        else
            node.left.type := node.left.type | EA_DEREF_AFTER;
        end if;

        node.left.numoff_id := add_number_by_value(
            get_value_of_number(node.left.numoff_id) +
                member.offset);
        node.type_id := member.type_id;

        push_node(node);
    end sub;

    sub fex_parameter(direction: uint8, iop: [FEParameterIop])
        var thing_id: uint16 := iop.subroutine_id;
        var thing: [Thing] := find_thing(thing_id);
        if thing.thing_type == THING_IDENTIFIER then
            thing_id := deref_symbol_or_fail(thing_id);
            thing := find_thing(thing_id);
        end if;
        if thing.thing_type != THING_SUBROUTINE then
            print("subroutine_id not a subroutine");
            halt();
        end if;

        var parameter_id: uint16 := find_nth_parameter(
            thing_id, direction, iop.parameter);
        if parameter_id == 0 then
            print("invalid parameter id");
            halt();
        end if;
        var parameter: [ParameterThing] := find_thing(parameter_id) as [ParameterThing];

        var node: [Node] := push_empty_node();
        print("found subroutine 0x");
        print_hex_i16(thing_id);
        print(" direction ");
        print_i8(direction);
        print_newline();
        node.iop := IOP_FEX_PUSH;
        node.type_id := parameter.type_id;
        node.left.obj_id := parameter_id;
    end sub;

    sub fe_materialise()
        var src: [Node] := pop();

        var dest: [Node] := push_empty_node();
        dest.iop := IOP_FEX_PUSH;
        dest.flags := FLAG_RVALUE;
        dest.type_id := src.type_id;
        dest.left.obj_id := alloc_temporary(get_width_of(src));

        arch_simplify_node_to(src, dest);
        deref_node(src);
    end sub;

    sub fe_conditional(iopkind: uint8, iop: [FEConditionalIop])
        var right: [Node] := simplify_node_to_ea_and_deref(pop());
        var left: [Node] := simplify_node_to_ea_and_deref(pop());

        var type_id: uint16 := check_type_compatibility(left.type_id, right.type_id);

        var beiop: BEConditionalIop;
        zero_memory(&beiop as [int8], BEConditionalIop@bytes);
        beiop.iop_size := BEConditionalIop@bytes;
        beiop.iop_kind := iopkind;
        beiop.width := get_width_of_type(type_id);
        beiop.iftrue_label_id := iop.iftrue_label_id;
        beiop.iffalse_label_id := iop.iffalse_label_id;
        copy_ea_ref(&left.left, &beiop.left);
        copy_ea_ref(&right.left, &beiop.right);

        arch_simplify_conditional_iop(&beiop);

        deref_temporary(beiop.left.obj_id);
        deref_temporary(beiop.left.varoff_id);
        deref_temporary(beiop.right.obj_id);
        deref_temporary(beiop.right.varoff_id);
        deref_node(left);
        deref_node(right);
    end sub;

    sub fe_cast(iop: [FECastIop])
        var node: [Node] := simplify_node_to_ea_and_deref(pop());

        var input_type: [TypeThing] := find_thing(node.type_id) as [TypeThing];
        var output_type: [TypeThing] := find_thing(iop.type_id) as [TypeThing];
        if (input_type.thing_type != THING_NUMERIC) and (input_type.width != output_type.width) then
            if output_type.thing_type == THING_SIGNED then
                node.iop := IOP_BE_SEXT;
            else
                node.iop := IOP_BE_ZEXT;
            end if;
        end if;
        node.type_id := iop.type_id;
        node.flags := FLAG_RVALUE;
        push_node(node);
    end sub;

    sub fe_shift(signed_beiop: uint8, unsigned_beiop: uint8)
        var right: [Node] := simplify_node_to_ea_and_deref(pop());
        var left: [Node] := simplify_node_to_ea_and_deref(pop());

        var left_type: [TypeThing] := find_thing(left.type_id) as [TypeThing];
        if ((left_type.thing_type & THING_NUMERIC) == 0) then
            print("can't shift non-numeric type ");
            print_type_name(left.type_id);
            halt();
        end if;

        var right_type: [TypeThing] := find_thing(right.type_id) as [TypeThing];
        if ((right_type.thing_type & THING_NUMERIC) == 0) then
            print("can't shift by non-numeric type ");
            print_type_name(left.type_id);
            halt();
        end if;

        var node: [Node] := push_empty_node();
        if ((left_type.thing_type == THING_SIGNED) or (left_type.thing_type == THING_NUMERIC)) then
            node.iop := signed_beiop;
        else
            node.iop := unsigned_beiop;
        end if;
        node.flags := FLAG_RVALUE;
        copy_ea_ref(&left.left, &node.left);
        copy_ea_ref(&right.left, &node.right);
        node.type_id := left.type_id;

        deref_node(left);
        deref_node(right);
    end sub;

    sub fe_call(iop: [CallIop])
        var thing: [SubroutineThing] := find_thing(iop.thing_id) as [SubroutineThing];
        if thing.thing_type == THING_IDENTIFIER then
            iop.thing_id := deref_symbol_or_fail(iop.thing_id);
            thing := find_thing(iop.thing_id) as [SubroutineThing];
        end if;
        if thing.thing_type != THING_SUBROUTINE then
            print("subroutine_id not pointing at subroutine");
            halt();
        end if;

        if (thing.input_parameter_count != iop.input_parameter_count)
                or (thing.output_parameter_count != iop.output_parameter_count) then
            show_name_of(iop.thing_id);
            print(" has ");
            print_i8(thing.input_parameter_count);
            print(" inputs and ");
            print_i8(thing.output_parameter_count);
            print(" outputs, but was called with ");
            print_i8(iop.input_parameter_count);
            print(" and ");
            print_i8(iop.output_parameter_count);
            halt();
        end if;

        write_iop(iop as [Iop]);
    end sub;

    loop
        var iop: [Iop] := read_iop();
        var ioptype: uint8 := iop.iop_kind & IOP_TYPE_MASK;
        print_newline();
        print_stack();
        print("* read iop 0x");
        print_hex_i8(iop.iop_kind);
        print_newline();

        if iop.iop_kind == IOP_END then
            break;
        elseif iop.iop_kind == IOP_CALL then
            fe_call(iop as [CallIop]);
        elseif ioptype == IOP_TYPE_UNTYPED then
            write_iop(iop);
        elseif iop.iop_kind == IOP_FE_SWAP then
            fe_swap();
        elseif iop.iop_kind == IOP_FEX_PUSH then
            fex_push(iop as [FEPushIop]);
        elseif iop.iop_kind == IOP_FE_ASSIGN then
            fe_assign();
        elseif iop.iop_kind == IOP_FE_ADD then
            fe_addsub(IOP_BE_ADD);
        elseif iop.iop_kind == IOP_FE_SUB then
            fe_addsub(IOP_BE_SUB);
        elseif iop.iop_kind == IOP_FE_MUL then
            fe_simple_alu2op(IOP_BE_MUL);
        elseif iop.iop_kind == IOP_FE_AND then
            fe_simple_alu2op(IOP_BE_AND);
        elseif iop.iop_kind == IOP_FE_OR then
            fe_simple_alu2op(IOP_BE_OR);
        elseif iop.iop_kind == IOP_FE_EOR then
            fe_simple_alu2op(IOP_BE_EOR);
        elseif iop.iop_kind == IOP_FE_DIV then
            fe_simple_alu2op(maybe_signed_biop(IOP_BE_DIVS, IOP_BE_DIVU));
        elseif iop.iop_kind == IOP_FE_MOD then
            fe_simple_alu2op(maybe_signed_biop(IOP_BE_MODS, IOP_BE_MODU));
        elseif iop.iop_kind == IOP_FE_NEG then
            fe_simple_alu1op(IOP_BE_NEG);
        elseif iop.iop_kind == IOP_FE_NOT then
            fe_simple_alu1op(IOP_BE_NOT);
        elseif (iop.iop_kind == IOP_FE_LSHIFT) then
            fe_shift(IOP_BE_LSL, IOP_BE_LSL);
        elseif (iop.iop_kind == IOP_FE_RSHIFT) then
            fe_shift(IOP_BE_ASR, IOP_BE_LSR);
        elseif iop.iop_kind == IOP_FE_INDEX then
            fe_index();
        elseif iop.iop_kind == IOP_FEX_INPUTPARAM then
            fex_parameter(DIRECTION_IN, iop as [FEParameterIop]);
        elseif iop.iop_kind == IOP_FEX_OUTPUTPARAM then
            fex_parameter(DIRECTION_OUT, iop as [FEParameterIop]);
        elseif iop.iop_kind == IOP_FE_MATERIALISE then
            fe_materialise();
        elseif iop.iop_kind == IOP_FE_ADDRESSOF then
            fe_addressof();
        elseif iop.iop_kind == IOP_FEX_MEMBEROF then
            fex_memberof(iop as [FEMemberIop]);
        elseif iop.iop_kind == IOP_FEX_BEQ then
            fe_conditional(IOP_BE_BEQ, iop as [FEConditionalIop]);
        elseif iop.iop_kind == IOP_FEX_BGT then
            fe_conditional(maybe_signed_biop(IOP_BE_BGTS, IOP_BE_BGTU),
                iop as [FEConditionalIop]);
        elseif iop.iop_kind == IOP_FEX_BLT then
            fe_conditional(maybe_signed_biop(IOP_BE_BLTS, IOP_BE_BLTU),
                iop as [FEConditionalIop]);
        elseif iop.iop_kind == IOP_FEX_CAST then
            fe_cast(iop as [FECastIop]);
        else
            print("unsupported iop 0x");
            print_hex_i8(iop.iop_kind);
            halt();
        end if;
    end loop;
    write_untyped_iop(IOP_END);
end sub;

sub process()
    loop
        var iheader: [IHeader] := read_iop_header();
        if iheader.thing_id == 0 then
            break;
        end if;

        write_iop_header(iheader);
        process_subroutine(iheader.thing_id);
    end loop;
    write_terminating_iop_header();
end sub;

process();
save_thing_table("things.dat");
