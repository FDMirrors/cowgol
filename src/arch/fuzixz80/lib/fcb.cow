const FCB_BLOCK_SIZE := 512;

record FCB
    fd: int8;

    address: [int8]; # PUBLIC
    count: uint16; # PUBLIC
    
    block: uint16;
    bufferptr: uint16;
    buffer: int8[FCB_BLOCK_SIZE];
    mode: uint8;
    dirty: uint8;
end record;

sub fcb_i_blockin(fcb: [FCB])
    zero_memory(&fcb.buffer[0], FCB_BLOCK_SIZE);
    var offset: uint32 := lseek(fcb.fd, (fcb.block as uint32)<<9, SEEK_SET);
    var result: int16 := read(fcb.fd, &fcb.buffer[0], FCB_BLOCK_SIZE);
    fcb.dirty := 0;
end sub;

sub fcb_i_blockout(fcb: [FCB])
    if fcb.dirty != 0 then
        var offset: uint32 := lseek(fcb.fd, (fcb.block as uint32)<<9, SEEK_SET);
        var result: int16 := write(fcb.fd, &fcb.buffer[0], FCB_BLOCK_SIZE);
        fcb.dirty := 0;
    end if;
end sub;

sub fcb_i_changeblock(fcb: [FCB], newblock: uint16)
    if newblock != fcb.block then
        fcb_i_blockout(fcb);
        fcb.block := newblock;
        fcb_i_blockin(fcb);
    end if;
end sub;

sub fcb_i_open(fcb: [FCB], filename: [int8], mode: uint16): (err: uint8)
    zero_memory(fcb as [int8], FCB@bytes);
    fcb.fd := open(filename, mode, 0o446);
    if fcb.fd == -1 then
        err := errno;
    else
        err := 0;
    end if;
end sub;

sub fcb_openin(fcb: [FCB], filename: [int8]): (err: uint8)
    err := fcb_i_open(fcb, filename, O_RDONLY);
    if err == 0 then
        fcb_i_blockin(fcb);
    end if;
end sub;

sub fcb_openup(fcb: [FCB], filename: [int8]): (err: uint8)
    err := fcb_i_open(fcb, filename, O_RDWR);
    if err == 0 then
        fcb_i_blockin(fcb);
    end if;
end sub;

sub fcb_openout(fcb: [FCB], filename: [int8]): (err: uint8)
    err := fcb_i_open(fcb, filename, O_RDWR|O_CREAT|O_TRUNC);
    if err == 0 then
        fcb_i_blockin(fcb);
    end if;
end sub;

sub fcb_close(fcb: [FCB])
    fcb_i_blockout(fcb);
    var status: int8 := close(fcb.fd);
end sub;

sub fcb_getchar(fcb: [FCB]): (c: int8)
    c := fcb.buffer[fcb.bufferptr];
    if fcb.bufferptr == (FCB_BLOCK_SIZE-1) then
        fcb_i_changeblock(fcb, fcb.block+1);
        fcb.bufferptr := 0;
    else
        fcb.bufferptr := fcb.bufferptr + 1;
    end if;
end sub;

sub fcb_putchar(fcb: [FCB], c: int8)
    fcb.dirty := 1;
    fcb.buffer[fcb.bufferptr] := c;
    if fcb.bufferptr == (FCB_BLOCK_SIZE-1) then
        fcb_i_changeblock(fcb, fcb.block+1);
        fcb.bufferptr := 0;
    else
        fcb.bufferptr := fcb.bufferptr + 1;
    end if;
end sub;

sub fcb_seek(fcb: [FCB], pos: uint32)
    var newblock: uint16 := (pos >> 9) as uint16;
    var newptr: uint16 := (pos as uint16) & (FCB_BLOCK_SIZE-1);

    fcb_i_changeblock(fcb, newblock);
    fcb.bufferptr := newptr;
end sub;

sub fcb_tell(fcb: [FCB]): (pos: uint32)
    pos := ((fcb.block as uint32) << 9) | (fcb.bufferptr as uint32);
end sub;

sub fcb_ext(fcb: [FCB]): (len: uint32)
    len := lseek(fcb.fd, 0, SEEK_END);
end sub;

sub fcb_read(fcb: [FCB])
    zero_memory(fcb.address, fcb.count);
    while fcb.count != 0 loop
        fcb.address[0] := fcb_getchar(fcb);
        fcb.count := fcb.count - 1;
        fcb.address := fcb.address + 1;
    end loop;
end sub;

sub fcb_write(fcb: [FCB])
    while fcb.count != 0 loop
        fcb_putchar(fcb, fcb.address[0]);
        fcb.count := fcb.count - 1;
        fcb.address := fcb.address + 1;
    end loop;
end sub;
