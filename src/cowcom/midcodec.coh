
sub CountParameters(param: [Symbol]): (count: uint8)
	count := 0;
	while param != (0 as [Symbol]) loop
		count := count + 1;
		param := param.vardata.next_parameter;
	end loop;
end sub;

sub GetInputParameter(subr: [Subroutine], count: uint8): (param: [Symbol])
	param := subr.first_input_parameter;
	while count != 0 loop
		param := param.vardata.next_parameter;
		count := count - 1;
	end loop;
end sub;

sub GetOutputParameter(subr: [Subroutine], count: uint8): (param: [Symbol])
	param := subr.first_output_parameter;
	while count != 0 loop
		param := param.vardata.next_parameter;
		count := count - 1;
	end loop;
end sub;

sub BadNodeWidth(width: uint8)
	print("bad midcode width ");
	print_i8(width);
	print_nl();
	ExitWithError();
end sub;

sub WidthToIndex(width: uint8): (index: uint8)
	case width is
		when 4: index := 3;
		when 8: index := 4;
		when else: index := width;
	end case;
end sub;

include "midcodes.coh";

# Free up the node tree rooted in the parameter. This is more exciting than it
# should be because we don't have recursion.
sub Discard(node: [Node])
	var pending := node;
	while pending != (0 as [Node]) loop
		node := pending;
		pending := node.dlink;

		# Unlink and push any children.
		if node.left != (0 as [Node]) then
			node.left.dlink := pending;
			pending := node.left;
		end if;
		if node.right != (0 as [Node]) then
			node.right.dlink := pending;
			pending := node.right;
		end if;

		# Now free this node.
		Free(node as [uint8]);
	end loop;
end sub;

sub NodeWidth(node: [Node]): (width: uint8)
	width := 0;
	if node.type != (0 as [Symbol]) then
		width := node.type.typedata.width as uint8;
	end if;
end sub;

sub FoldConstant(op: uint8, lhs: Arith, rhs: Arith): (result: Arith)
	case op is
		when MIDCODE_ADD0: result := lhs + rhs;
		#when MIDCODE_SUB0: result := lhs - rhs;
		when MIDCODE_MUL0: result := lhs * rhs;
		#when MIDCODE_DIVU0: result := ((lhs as uint32) / (rhs as uint32)) as Arith;
		#when MIDCODE_DIVS0: result := (lhs as int32) / (rhs as int32);
		#when MIDCODE_REMU0: result := ((lhs as uint32) % (rhs as uint32)) as Arith;
		#when MIDCODE_REMS0: result := (lhs as int32) % (rhs as int32);
		when MIDCODE_AND0: result := lhs & rhs;
		when MIDCODE_OR0:  result := lhs | rhs;
		when MIDCODE_EOR0: result := lhs ^ rhs;
		#when MIDCODE_NOT0: result := ~lhs;
		#when MIDCODE_NEG0: result := -lhs;
		when else:
			print("bad fold");
			ExitWithError();
	end case;
end sub;

# Called before commutative operators.
sub RotateParameters(baseop: uint8, lhs: [Node], rhs: [Node]): (newlhs: [Node], newrhs: [Node])
	# Ensure that x=1+y becomes x=y+1, which is easier to generate code for.
	var lop := lhs.op;
	if lop == MIDCODE_CONSTANT then
		newlhs := lhs;
		newrhs := rhs;
		return;
	end if;

	# Ensure that x=(y+1)+2 becomes x=y+(1+2).
	if (rhs.op == MIDCODE_CONSTANT)
			and (lhs.op >= baseop) and (lhs.op <= (baseop+4))
			and (lhs.right.op == MIDCODE_CONSTANT)
	then
		newlhs := lhs.left;
		lhs.left := 0 as [Node];

		newrhs := MidConstant(
			FoldConstant(baseop, lhs.right.constant.value, rhs.constant.value));
		Discard(lhs);
		Discard(rhs);
		return;
	end if;

	newlhs := lhs;
	newrhs := rhs;
end sub;

sub MidCNeg(width: uint8, lhs: [Node]): (result: [Node])
	if lhs.op == MIDCODE_CONSTANT then
		lhs.constant.value := -lhs.constant.value;
		result := lhs;
	else
		result := MidNeg(width, lhs);
	end if;
end sub;

sub MidCNot(width: uint8, lhs: [Node]): (result: [Node])
	if lhs.op == MIDCODE_CONSTANT then
		lhs.constant.value := ~lhs.constant.value;
		result := lhs;
	else
		result := MidNot(width, lhs);
	end if;
end sub;

sub MidCAnd(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	(lhs, rhs) := RotateParameters(MIDCODE_AND0, lhs, rhs);
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value := lhs.constant.value & rhs.constant.value;
		Discard(rhs);
		result := lhs;
	else
		result := MidAnd(width, lhs, rhs);
	end if;
end sub;

sub MidCOr(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	(lhs, rhs) := RotateParameters(MIDCODE_OR0, lhs, rhs);
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value := lhs.constant.value | rhs.constant.value;
		Discard(rhs);
		result := lhs;
	else
		result := MidOr(width, lhs, rhs);
	end if;
end sub;

sub MidCEor(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	(lhs, rhs) := RotateParameters(MIDCODE_EOR0, lhs, rhs);
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value := lhs.constant.value ^ rhs.constant.value;
		Discard(rhs);
		result := lhs;
	else
		result := MidEor(width, lhs, rhs);
	end if;
end sub;

sub MidCAdd(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	(lhs, rhs) := RotateParameters(MIDCODE_ADD0, lhs, rhs);
	if rhs.op == MIDCODE_CONSTANT then
		result := lhs;
		if lhs.op == MIDCODE_CONSTANT then
			lhs.constant.value := lhs.constant.value + rhs.constant.value;
			Discard(rhs);
			return;
		elseif lhs.op == MIDCODE_ADDRESS then
			lhs.address.off := lhs.address.off + (rhs.constant.value as Size);
			Discard(rhs);
			return;
		elseif rhs.constant.value == 0 then
			Discard(rhs);
			return;
		end if;
	end if;
	result := MidAdd(width, lhs, rhs);
end sub;

sub MidCSub(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value := lhs.constant.value - rhs.constant.value;
		Discard(rhs);
		result := lhs;
	elseif rhs.op == MIDCODE_CONSTANT then
		if rhs.constant.value == 0 then
			result := lhs;
			Discard(rhs);
		else
			rhs.constant.value := -rhs.constant.value;
			result := MidAdd(width, lhs, rhs);
		end if;
	else
		result := MidSub(width, lhs, rhs);
	end if;
end sub;

sub GetPowerOfTwo(value: int32): (exp: uint8)
	exp := 0;
	if (value > 0) and ((value & (value - 1)) == 0) then
		while value != 0 loop
			exp := exp + 1;
			value := value >> 1;
		end loop;
	end if;
end sub;

sub MidCMul(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	(lhs, rhs) := RotateParameters(MIDCODE_MUL0, lhs, rhs);
	if rhs.op == MIDCODE_CONSTANT then
		if lhs.op == MIDCODE_CONSTANT then
			lhs.constant.value := lhs.constant.value * rhs.constant.value;
			Discard(rhs);
			result := lhs;
			return;
		else
			sub shift(amount: uint8)
				Discard(rhs);
				result := MidLshift(width, lhs, MidConstant(amount as int32));
			end sub;

			var value := rhs.constant.value;
			var exp := GetPowerOfTwo(value);
			if exp != 0 then
				shift(exp-1);
				return;
			elseif value == 0 then
				Discard(lhs);
				Discard(rhs);
				result := MidConstant(0);
				return;
			end if;
		end if;
	end if;
	result := MidMul(width, lhs, rhs);
end sub;
		
sub MidCDivu(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value :=
			((lhs.constant.value as uint32) / (rhs.constant.value as uint32)) as int32;
		Discard(rhs);
		result := lhs;
	else
		result := MidDivu(width, lhs, rhs);
	end if;
end sub;

sub MidCDivs(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value := lhs.constant.value / rhs.constant.value;
		Discard(rhs);
		result := lhs;
	else
		result := MidDivs(width, lhs, rhs);
	end if;
end sub;

sub MidCRems(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value :=
			((lhs.constant.value as uint32) % (rhs.constant.value as uint32)) as int32;
		Discard(rhs);
		result := lhs;
	else
		result := MidRems(width, lhs, rhs);
	end if;
end sub;

sub MidCRemu(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value := lhs.constant.value % rhs.constant.value;
		Discard(rhs);
		result := lhs;
	else
		result := MidRemu(width, lhs, rhs);
	end if;
end sub;

sub MidCCast(width: uint8, lhs: [Node], issigned: uint8): (result: [Node])
	if lhs.op == MIDCODE_CONSTANT then
		result := lhs;
		return;
	end if;
	var srcwidth := lhs.type.typedata.width as uint8;
	if srcwidth == width then
		result := lhs;
	else
		case srcwidth is
			when 1: result := MidCast1(width, lhs, issigned);
			when 2: result := MidCast2(width, lhs, issigned);
			when 4: result := MidCast4(width, lhs, issigned);
			when 8: result := MidCast8(width, lhs, issigned);
		end case;
	end if;
end sub;

