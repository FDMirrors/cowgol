# Note that for VALUEs, any offset gets baked into the pointer. For DEREFs, the
# pointer points to the base and you need to apply the offset yourself.
sub make_pointer(ea: [EffectiveAddress], ptrea: [EffectiveAddress])
    copy_ea(ea, ptrea);
    if ea.flags == EA_VALUE then
        ptrea.flags := EA_LEA;

        # If we ever take the address of a number, ensure that the number will
        # get written out as a data value.
        if is_number_thing(ea.obj_id) != 0 then
            var thing: [NumberThing] := find_thing(ea.obj_id) as [NumberThing];
            thing.segment := SEGMENT_CONST;
        end if;
    else
        ptrea.flags := EA_VALUE;
        ptrea.numoff_id := 0;
    end if;
end sub;

# Given an ea, loads a pointer to it, adding any extra offset. Returns the
# pointer and any extra offset which needs adding in the dereference. The
# rules are inconsistent and a bit weird:
#
#  index registers: pointer+residual does not include extraoffset
#  other registers: pointer does include extraoffset, residual=0
#
# There are reasons for this, honest. 
sub setup_pointer(candidates: RegSet, ea: [EffectiveAddress], extraoffset: uint8):
        (reg: RegSet, residualoffset: int16)
    $if DEBUG
        print("* constructing a pointer to ");
        print_ea(ea);
        print(" in ");
        print_regs(candidates);
        print_newline();
    $endif

    var indea: EffectiveAddress;
    make_pointer(ea, &indea);

    if get_value_of_number(ea.numoff_id) != 0 then
        candidates := candidates & (REG_HL|REG_DE|REG_IX|REG_IY);
    end if;
    reg := reg_find_or_load(candidates, &indea);

    if ea.flags == EA_DEREF then
        residualoffset := get_value_of_number(ea.numoff_id) as int16;
    else
        residualoffset := 0;
    end if;
    if (reg & REG_INDEX) == 0 then
        residualoffset := residualoffset + (extraoffset as int16);
        if residualoffset != 0 then
            $if DEBUG
                print("* offsetting ");
                print_regs(reg);
                print(" by 0x");
                print_hex_i16(residualoffset as uint16);
                print_newline();
            $endif

            var offea: EffectiveAddress;
            offea.type_id := uint16_type;
            offea.obj_id := add_number_by_value(residualoffset as int32);

            var offreg: RegSet := reg_find_or_load(REG_HL|REG_BC|REG_DE, &offea);
            reg_evict(reg);
            var regnum: uint8 := get_z80_regnum(offreg);
            if reg == REG_DE then
                write_byte(0xEB); # ex hl, de
                if offreg == REG_HL then
                    write_byte(0x19); # add hl, de
                elseif offreg == REG_BC then
                    write_byte(0x09); # add hl, bc
                else
                    print("can't happen");
                    halt();
                end if;
                write_byte(0xEB); # ex hl, de
            elseif reg == REG_HL then
                write_byte(0x09 | regnum); # add hl, bc
            else
                print("can't offset this register");
                halt();
            end if;
            reg_free(offreg);

            residualoffset := 0;
        end if;
    end if;
end sub;

# Returns half a register pair.
sub halfof_reg(reg16: RegSet, offset: uint8): (reg8: RegSet)
    if reg16 == REG_HL then
        reg8 := REG_L;
    elseif reg16 == REG_BC then
        reg8 := REG_C;
    elseif reg16 == REG_DE then
        reg8 := REG_E;
    elseif reg16 == REG_A then
        reg8 := REG_A;
        return;
    else
        print("bad register: ");
        print_regs(reg16);
        halt();
    end if;
    reg8 := reg8 >> offset;
end sub;
