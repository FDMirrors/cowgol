record IHeader
    thing_id: uint16;
    section: uint8;
end record;

record Iop
    iop_size: uint8;
    iop_kind: uint8;
    payload: int8[0];
end record;

const IOP_END := 0;

# Important note with regard to the stack machine: there is no DUP instruction.
# The code generator relies on every value on the stack being pushed exactly
# once and popped exactly once (so as to make it easy to determine the lifespan
# of nodes in the operator tree).

const IOP_TYPE_MASK        := 0b1110_0000;

const IOP_TYPE_CONDITIONAL := 0b0010_0000;
const IOP_BEQ              := 0b0010_0000;
const IOP_BLTU             := 0b0010_0001;
const IOP_BGTU             := 0b0010_0010;
const IOP_BLTS             := 0b0010_0011;
const IOP_BGTS             := 0b0010_0100;

const IOP_TYPE_SIMPLE2OP   := 0b0100_0000;
const IOP_MULOP            := 0b0100_0001;
const IOP_MODSOP           := 0b0100_0010;
const IOP_MODUOP           := 0b0100_0011;
const IOP_ANDOP            := 0b0100_0100;
const IOP_OROP             := 0b0100_0101;
const IOP_EOROP            := 0b0100_0110;
const IOP_LSLOP            := 0b0100_0111;
const IOP_LSROP            := 0b0100_1000;
const IOP_ASROP            := 0b0100_1001;
const IOP_DIVSOP           := 0b0100_1010;
const IOP_DIVUOP           := 0b0100_1011;

const IOP_TYPE_UNTYPED     := 0b0110_0000;
const IOP_LABEL            := 0b0110_0000;
const IOP_STRING           := 0b0110_0001;
const IOP_RETURN           := 0b0110_0010;
const IOP_GOTO             := 0b0110_0011;
const IOP_FILENAME         := 0b0110_0100;
const IOP_LINENUMBER       := 0b0110_0101;
const IOP_BYTES            := 0b0110_0110;
const IOP_WORD             := 0b0110_0111;
const IOP_SWAP             := 0b0110_1000; # not understood by type checker

const IOP_TYPE_SIMPLE1OP   := 0b1000_0000;
const IOP_NEGOP            := 0b1000_0001;
const IOP_NOTOP            := 0b1000_0010;
const IOP_MATERIALISE      := 0b1000_0011;
const IOP_ZEXTOP           := 0b1000_0100;
const IOP_SEXTOP           := 0b1000_0101;

const IOP_TYPE_FAKE        := 0b1010_0000;
const IOP_BLT              := 0b1010_0001; # rewritten to BLTU or BLTS
const IOP_BGT              := 0b1010_0010; # rewritten to BGTU or BGTS
const IOP_MODOP            := 0b1010_0011; # rewritten to MODS or MODU
const IOP_DIVOP            := 0b1010_0100; # rewritten to DIVS or DIVU
const IOP_CASTOP           := 0b1010_0101; # rewritten to ZEXT or SEXT
const IOP_MEMBEROP         := 0b1010_0110; # takes identifier; rewritten to INDEXU
const IOP_SINDEXOP         := 0b1010_0111; # apply non-constant scaled offset; rewritten to INDEXS or INDEXU
const IOP_INPUTPARAM       := 0b1010_1000; # push input parameter; rewritten to THING
const IOP_OUTPUTPARAM      := 0b1010_1001; # push output parameter; rewritten to THING
const IOP_RSHIFTOP         := 0b1010_1010; # rewritten to LSR or ASR

const IOP_TYPE_CODEGEN     := 0b1110_0000;
const IOP_CG_COPY1         := 0b1110_0000;
const IOP_CG_COPY2         := 0b1110_0001;
const IOP_CG_COPY4         := 0b1110_0010;
const IOP_CG_6502_MEM      := 0b1110_0011;
const IOP_CG_6502_ZEROPAGE := 0b1110_0100;
const IOP_CG_6502_COND     := 0b1110_0101;

const IOP_THING       := 0x01;
const IOP_ASSIGN      := 0x02; # ( dest src -- )
const IOP_ASSIGNTO    := 0x03; # ( src dest -- )
const IOP_CALL        := 0x04;
const IOP_ADDOP       := 0x05;
const IOP_SUBOP       := 0x06;
const IOP_ADDRESSOP   := 0x07;
const IOP_BYTESOP     := 0x08;
const IOP_SIZEOP      := 0x09;
const IOP_OFFSETOP    := 0x0a; # apply constant byte offset to EA
const IOP_INDEXSOP    := 0x0b; # apply variable signed byte offset to EA
const IOP_INDEXUOP    := 0x0c; # apply variable unsigned byte offset to EA
const IOP_LOAD        := 0x0d; # turn EA to pointer into EA to thing being pointed at

record FilenameIop: Iop
    thing_id: uint16;
end record;

record LinenumberIop: Iop
    line_number: uint16;
end record;

record LabelIop: Iop
    label_id: uint16;
end record;

record SectionIop: Iop
    section: uint8;
end record;

record StringIop: Iop
    string_id: uint16;
end record;

record CallIop: Iop
    thing_id: uint16;
    input_parameter_count: uint8;
    output_parameter_count: uint8;
end record;

record ParameterIop: Iop
    subroutine_id: uint16;
    parameter: uint8;
end record;

record GotoIop: Iop
    label_id: uint16;
end record;

record TypedIop: Iop
    type_id: uint16;
end record;

record ConditionalIop: TypedIop
    iftrue_label_id: uint16;
    iffalse_label_id: uint16;
end record;

record ThingIop: TypedIop
    thing_id: uint16;
end record;

record OffsetIop: TypedIop
    offset: int16;
end record;

record MemberIop: Iop
    thing_id: uint16;
end record;

record BytesIop: Iop
    byte_count: uint8;
    bytes: uint8[8];
end record;

record WordIop: Iop
    thing_id: uint16;
    offset_id: uint16;
end record;

record CGCopyNIop: Iop
    opcode: uint8;
    src_thing_id: uint16;
    src_offset_id: uint16;
    dest_thing_id: uint16;
    dest_offset_id: uint16;
end record;

record CG6502MemIop: Iop
    opcode: uint8;
    thing_id: uint16;
    offset_id: uint16;
end record;

record CG6502ZeroPageIop: Iop
    thing_id: uint16;
    offset_id: uint16;
end record;

record CG6502ConditionalIop: Iop
    opcode: uint8;
    label_id: uint16;
end record;

record BiggestIop: BytesIop
end record;

sub resolve_label_id(ref_id: uint16): (label_id: uint16)
    label_id := ref_id;
    loop
        var label: [LabelThing] := find_thing(label_id) as [LabelThing];
        if label.thing_type == THING_LABEL then
            break;
        end if;

        label_id := label.target;
    end loop;
end sub;

