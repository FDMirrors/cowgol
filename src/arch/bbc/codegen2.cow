sub arch_gen_before(ea: [EffectiveAddress])
    if (ea.obj_id != 0) and (ea.type == EA_PTRVAL) then
        print("* writing back precious values because of pointer access: ");
        print_ea(ea);
        print_newline();

        write_back_precious_values(REG_MASK);
    end if;
end sub;

sub arch_gen_after(ea: [EffectiveAddress])
    if (ea.obj_id != 0) and (ea.type == EA_PTRVAL) then
        print("* flushing cached values because of pointer access: ");
        print_ea(ea);
        print_newline();

        flush_cached_values(REG_MASK);
    end if;
end sub;

sub arch_gen_beginning_of_instruction()
    locked_registers := 0;
end sub;

sub arch_gen_return()
    flush_cached_values(REG_MASK);
    write_byte(0x60); # RTS
end sub;

sub arch_gen_call(iop: [CallIop])
    flush_cached_values(REG_MASK);
    write_byte(0x20); # JSR
    write_address_iop(IOP_ADDRESS, iop.thing_id, 0);
end sub;

sub arch_gen_label(iop: [LabelIop])
    flush_cached_values(REG_MASK);
    write_iop(iop as [Iop]);
end sub;

sub arch_gen_goto(iop: [GotoIop])
    flush_cached_values(REG_MASK);
    write_cg_6502_conditional_iop(0x80, iop.label); # BRA (actually a 65C102 opcode)
end sub;

sub arch_gen_copy_byte(iop: [BEIop])
    var location: uint8 := find_or_load_value(&iop.left, REG_A|REG_X|REG_Y);
    make_value_precious_or_save_now(location, &iop.dest);
end sub;

sub gen_regular_alu(iop: [BEIop], opcode: uint8)
    var location: uint8 := find_or_load_value(&iop.left, REG_A);
    value_in_location_will_be_replaced_with(location, &iop.dest);

    if iop.right.type == EA_OBJVAL then
        # do nothing, the opcode is already right
    else
        print("can't add ");
        print_ea(&iop.right);
        print(" yet");
        print_newline();
    end if;

    print("gen_regular_alu");
    halt();
    #write_6502_regular_op(opcode, &iop.right);

    make_value_precious_or_save_now(location, &iop.dest);
end sub;

sub gen_incdec(iop: [BEIop], value: int8)
    var location: uint8 := find_or_load_value(&iop.left, REG_X|REG_Y);
    value_in_location_will_be_replaced_with(location, &iop.dest);

    var opcode: uint8;
    if value == 1 then
        if location == REG_X then
            opcode := 0xE8; # INX
        else
            opcode := 0xC8; # INY
        end if;
    else
        if location == REG_X then
            opcode := 0xCA; # INX
        else
            opcode := 0x88; # INY
        end if;
    end if;
    write_byte(opcode);

    make_value_precious_or_save_now(location, &iop.dest);
end sub;

sub arch_gen_add_byte(iop: [BEIop])
    var location: uint8;
    var opcode: uint8;

    if is_number_thing(iop.right.obj_id) != 0 then
        var value: int32 := get_value_of_number(iop.right.obj_id);
        if (value == 1) or (value == -1) then
            gen_incdec(iop, value);
            return;
        end if;
    end if;

    write_byte(0x18); # CLC
    gen_regular_alu(iop, 0x6D); # ADC abs
end sub;

sub arch_gen_sub_byte(iop: [BEIop])
    var location: uint8;
    var opcode: uint8;

    if is_number_thing(iop.right.obj_id) != 0 then
        var value: int32 := get_value_of_number(iop.right.obj_id);
        if (value == 1) or (value == -1) then
            gen_incdec(iop, 0-value);
            return;
        end if;
    end if;

    write_byte(0x18); # CLC
    gen_regular_alu(iop, 0xED); # SBC abs
end sub;

sub arch_gen_copy_word(iop: [BEIop])
    sub address_of()
        var candidates: uint8;
        if iop.dest.type == EA_PTRVAL then
            candidates := REG_A;
        else
            candidates := REG_A|REG_X;
        end if;

        var location: uint8 := allocate_reg(candidates);
        ld_imm_adr_lo(location, &iop.left);
        save_value_with_index_or_offset(location, &iop.dest, 0);
        ld_imm_adr_hi(location, &iop.left);
        save_value_with_index_or_offset(location, &iop.dest, 1);
    end sub;

    if is_number_thing(iop.left.obj_id) != 0 then
        var value: int32 := get_value_of_number(iop.left.obj_id);
        var candidates: uint8;
        if iop.dest.type == EA_PTRVAL then
            candidates := REG_A;
        else
            candidates := REG_A|REG_X;
        end if;

        var location: uint8 := find_or_load_int(value, candidates);
        save_value_with_index_or_offset(location, &iop.dest, 0);
        free_reg(location);
        location := find_or_load_int(value >> 8, candidates);
        save_value_with_index_or_offset(location, &iop.dest, 1);
    elseif is_string_thing(iop.left.obj_id) != 0 then
        address_of();
    elseif is_typed_thing(iop.left.obj_id) != 0 then
        if iop.left.type == EA_OBJADR then
            address_of();
        else
            find_or_load_fixed_int(1, REG_Y);
            allocate_fixed_reg(REG_A);

            var label: uint16 := create_label();
            write_label_iop(label);
            load_value_with_index(REG_A, &iop.left, REG_Y);
            save_value_with_index(REG_A, &iop.dest, REG_Y);
            write_byte(0x88); # DEY
            write_cg_6502_conditional_iop(0x30, label); # BMI

            flush_cached_values(REG_Y);
        end if;
    else
        print("don't know how to load ");
        print_ea(&iop.left);
        halt();
    end if;
end sub;

sub arch_gen_sext_word(iop: [BEIop])
    find_or_load_fixed_int(0, REG_X);

    find_or_load_fixed_value_with_flags(&iop.left, REG_A);
    write_byte(0x10); # BPL rel
    write_byte(0x01); # skip one byte
    write_byte(0xCA); # DEX

    save_value_with_offset(REG_A, &iop.dest, 0);
    save_value_with_offset(REG_X, &iop.dest, 1);
end sub;

sub arch_gen_zext_word(iop: [BEIop])
    var location: uint8 := find_or_load_value(&iop.left, REG_A|REG_X|REG_Y);
    save_value_with_offset(location, &iop.dest, 0);

    location := find_or_load_int(0, REG_A|REG_X|REG_Y);
    save_value_with_offset(location, &iop.dest, 1);
end sub;

sub arch_gen_cmp_byte(ciop: [BEConditionalIop], liop: [LabelIop])
    write_back_precious_values(REG_MASK);

    var swapped: uint8 := 0;
    var signed: uint8 := 0;
    var opcode: uint8;
    # The opcodes below assume we're jumping to the *true* label ---
    # if not, we adjust things later.
    if ciop.iop_kind == IOP_BE_BEQ then
        opcode := 0xF0; # BEQ rel --- branch if zero clear
    elseif ciop.iop_kind == IOP_BE_BLTU then
        opcode := 0x90; # BCC rel
    elseif ciop.iop_kind == IOP_BE_BGTU then
        opcode := 0x90; # BCC rel
        swapped := 1;
    elseif ciop.iop_kind == IOP_BE_BLTS then
        opcode := 0x30; # BMI rel
        signed := 1;
    elseif ciop.iop_kind == IOP_BE_BGTS then
        opcode := 0x30; # BMI rel
        signed := 1;
        swapped := 1;
    else
        print("unsupported comparison");
        halt();
    end if;

    sub emit_comparison(ea: [EffectiveAddress])
        if signed != 0 then
            write_byte(0x38); # SEC
            aluop_value(ea, 0xED); # SBC abs
            write_word_iop(0x0250); # BVC .+2
            write_word_iop(0x8049); # EOR #80
        else
            aluop_value(ea, 0xCD); # CMP abs
        end if;
    end sub;

    if swapped == 0 then
        find_or_load_fixed_value(&ciop.left, REG_A);
        emit_comparison(&ciop.right);
    else
        find_or_load_fixed_value(&ciop.right, REG_A);
        emit_comparison(&ciop.left);
    end if;

    var destlabel: uint16;
    if liop.label == ciop.iftrue_label then
        destlabel := ciop.iffalse_label;
        opcode := opcode ^ 0x20;
    elseif liop.label == ciop.iffalse_label then
        destlabel := ciop.iftrue_label;
    else
        print("bad conditional");
        halt();
    end if;

    write_cg_6502_conditional_iop(opcode, destlabel);
    flush_cached_values(REG_MASK);
end sub;
