%{
	#include "globals.h"
	#include "emitter.h"
	#include "midcodes.h"
	#include "compiler.h"
	#include <bsd/string.h>
	#include <ctype.h>

	#define IMPL
	#include "codegen.h"

	#define E emitter_printf
	static char asmbuffer[80];

	struct subarch
	{
		int id;
	};

	static int id = 1;

	void arch_init_types(void)
	{
		make_number_type("uint32", 4, false);
		make_number_type("int32", 4, true);
		intptr_type = make_number_type("uint16", 2, false);
		make_number_type("int16", 2, true);
		uint8_type = make_number_type("uint8", 1, false);
		make_number_type("int8", 1, true);

		add_alias(NULL, "intptr", intptr_type);
	}

	void arch_init_subroutine(struct subroutine* sub)
	{
		sub->arch = calloc(1, sizeof(struct subarch));
		sub->arch->id = id++;
	}

	void arch_init_variable(struct symbol* var)
	{
		/* All variables get allocated from workspace 0. */
		current_sub->workspace[0] += var->u.var.type->u.type.width;
	}

	static const char* regref(reg_t reg)
	{
		switch (reg)
		{
			case REG_A: return "a";
			case REG_B: return "b";
			case REG_D: return "d";
			case REG_H: return "h";
			case REG_BC: return "b";
			case REG_DE: return "d";
			case REG_HL: return "h";
			default: fatal("unknown register id 0x%x", reg);
		}
	}

	static const char* stkref(reg_t reg)
	{
		if (reg == REG_A)
			return "psw";
		return regref(reg);
	}

	static const char* regreflo(reg_t reg)
	{
		switch (reg)
		{
			case REG_BC: return "c";
			case REG_DE: return "e";
			case REG_HL: return "l";
			default: assert(false);
		}
	}

	static const char* subref(Subroutine* sub)
	{
		if (sub->externname)
			return sub->externname;
		
		static char buffer[32];
		snprintf(buffer, sizeof(buffer), "f%d", sub->arch->id);
		return buffer;
	}

	static const char* symref(Symbol* sym, int32_t off)
	{
		static char buffer[32];
		snprintf(buffer, sizeof(buffer), "w%d%+d",
			sym->u.var.sub->arch->id,
			sym->u.var.offset + off);
		return buffer;
	}

	static const char* labelref(int label)
	{
		static char buffer[32];
		snprintf(buffer, sizeof(buffer), "x%d", label);
		return buffer;
	}

	/* Note! This is allowed to destroy the source register. */
	void arch_emit_move(reg_t src, reg_t dest)
	{
		if (!src)
			E("\tpop %s\n", stkref(dest));
		else if (!dest)
			E("\tpush %s\n", stkref(src));
		else
		{
			if (((src == REG_HL) && (dest == REG_DE)) ||
			    ((src == REG_DE) && (dest == REG_HL)))
				E("\txchg\n");
			else
			{
				E("\tmov %s, %s\n", regref(dest), regref(src));
				if (src & (REG_HL|REG_BC|REG_DE))
					E("\tmov %s, %s\n", regreflo(dest), regreflo(src));
			}
		}
	}

	void arch_emit_comment(const char* text, ...)
	{
		va_list ap;
		va_start(ap, text);
		emitter_printf("\t; ");
		emitter_vprintf(text, ap);
		emitter_printf("\n");
		va_end(ap);
	}
%}

register a b d h hl de bc;
register stk4 param;

regdata a compatible a|b|d|h;
regdata b uses bc compatible a|b|d|h;
regdata d uses de compatible a|b|d|h;
regdata h uses hl compatible a|b|d|h;
regdata bc uses bc compatible bc|de|hl;
regdata de uses de compatible bc|de|hl;
regdata hl uses hl compatible bc|de|hl;
regdata stk4 stacked;
regdata param stacked;

gen STARTFILE()
{
    emitter_open_chunk();
    E("\textrn add4\n");
    E("\textrn sub4\n");
    E("\textrn neg4\n");
    E("\textrn cpy4\n");
    E("\textrn asl1\n");
    E("\textrn asl2\n");
	E("\textrn lsr1\n");
	E("\textrn lsr2\n");
	E("\textrn lsr4\n");
	E("\textrn asr1\n");
	E("\textrn asr2\n");
	E("\textrn cmpu4\n");
    emitter_close_chunk();
}

gen ENDFILE();

gen STARTSUB():s
{
    emitter_open_chunk();
    E("\n");
    E("; %s\n", $s.sub->name);
    E("\tcseg\n");
    if ($s.sub->externname)
        E("\tpublic %s\n", $s.sub->externname);
    E("\tpublic %s\n", subref($s.sub));
    E("%s:\n", subref($s.sub));

    if ($s.sub->inputparameters != 0)
    {
        E("\tpop b\n");
        for (int i=$s.sub->inputparameters-1; i>=0; i--)
        {
			Symbol* param = get_input_parameters($s.sub);
			for (int j=0; j<i; j++)
				param = param->next;

			switch (param->u.var.type->u.type.width)
			{
				case 1:
					E("\tpop psw\n");
					E("\tsta %s\n", symref(param, 0));
					break;

				case 2:
					E("\tpop h\n");
					E("\tshld %s\n", symref(param, 0));
					break;

				case 4:
					E("\tpop h\n");
					E("\tshld %s\n", symref(param, 0));
					E("\tpop h\n");
					E("\tshld %s\n", symref(param, 2));
					break;

				default:
					assert(false);
			}
        }
        E("\tpush b\n");
    }
}

gen ENDSUB():s
{
	E("end_%s:\n", subref($s.sub));
	if ($s.sub->outputparameters != 0)
	{
		E("\tpop h\n");
		E("\txchg\n"); /* put return address in DE */

		for (int i=0; i<$s.sub->outputparameters; i++)
		{
			struct symbol* param = $s.sub->namespace.firstsymbol;
			for (int j=0; j<(i + $s.sub->inputparameters); j++)
				param = param->next;

			if (param->u.var.type->u.type.width == 1)
			{
				E("\tlda %s\n", symref(param, 0));
				E("\tpush psw\n");
			}
			else
			{
				E("\tlhld %s\n", symref(param, 0));
				E("\tpush h\n");
			}
		}

		E("\txchg\n");
		E("\tpchl\n");
	}
	else
		E("\tret\n");

    E("\tdseg\n");
	E("w%d: ds %d\n", $s.sub->arch->id, $s.sub->workspace[0]);
    emitter_close_chunk();
}

// --- Control flow ------------------------------------------------------

gen RETURN()
{
	E("\tjmp end_%s\n", subref(current_sub));
}

gen LABEL():b
{
	E("%s:\n", labelref($b.label));
}

gen JUMP():j
{
	E("\tjmp %s\n", labelref($j.label));
}

// --- Subroutines -------------------------------------------------------

// SETPARAM leaves the parameter on the top of the stack, where the
// code generator loses track of it.

gen param := END();

gen param := PUSHPARAM1(param, a|b|d|h:lhs)
	{ E("\tpush %s\n", stkref($lhs)); }

gen param := PUSHPARAM2(param, bc|de|hl:lhs)
	{ E("\tpush %s\n", stkref($lhs)); }

gen param := PUSHPARAM4(param, stk4);

%{
	static void call(Subroutine* sub)
	{
		if (sub->externname)
		{
			emitter_open_chunk();
			E("\textrn %s\n", sub->externname);
			emitter_close_chunk();
		}

		arch_emit_comment("subroutine with %d input parameters", sub->inputparameters);
		E("\tcall %s\n", subref(sub));
	}
%}

gen param := CALL0(param):c
	{ call($c.sub); }

gen CALL0(param):c
	{ call($c.sub); }

gen a|b|d|h := CALL1(param):c
{
	call($c.sub);
	E("\tpop %s\n", stkref($$));
}

gen bc|de|hl := CALL2(param):c
{
	call($c.sub);
	E("\tpop %s\n", stkref($$));
}

gen POPPARAM1(param, ADDRESS():a) uses a
{
	E("\tpop psw\n");
	E("\tsta %s\n", symref($a.sym, $a.off));
}

gen param := POPPARAM1(param, ADDRESS():a) uses a
{
	E("\tpop psw\n");
	E("\tsta %s\n", symref($a.sym, $a.off));
}

gen POPPARAM2(param, ADDRESS():a) uses hl
{
	E("\tpop hl\n");
	E("\tshld %s\n", symref($a.sym, $a.off));
}

gen param := POPPARAM2(param, ADDRESS():a) uses hl
{
	E("\tpop hl\n");
	E("\tshld %s\n", symref($a.sym, $a.off));
}

// --- Loads and stores --------------------------------------------------

gen a := LOAD1(bc|de|hl:lhs)
{
	switch ($lhs)
	{
		case REG_BC:
			E("\tldax b\n");
			break;

		case REG_DE:
			E("\tldax d\n");
			break;

		case REG_HL:
			E("\tmov a, m\n");
			break;

		default:
			assert(false);
	}
}

gen a := LOAD1(ADDRESS():a)
	{ E("\tlda %s\n", symref($a.sym, $a.off)); }

gen hl|bc|de := LOAD2(hl:lhs) uses a
{
	if ($$ == REG_HL)
	{
		E("\tmov a, m\n");
		E("\tinx h\n");
		E("\tmov h, m\n");
		E("\tmov l, a\n");
	}
	else
	{
		E("\tmov %s, m\n", regreflo($$));
		E("\tinx h\n");
		E("\tmov %s, m\n", regref($$));
	}
}

gen hl := LOAD2(ADDRESS():a)
	{ E("\tlhld %s\n", symref($a.sym, $a.off)); }

gen stk4 := LOAD4(ADDRESS():a) uses hl
{
	E("\tlhld %s\n", symref($a.sym, $a.off+2));
	E("\tpush h\n");
	E("\tlhld %s\n", symref($a.sym, $a.off+0));
	E("\tpush h\n");
}

gen STORE1(bc|de|hl:lhs, a)
{
	switch ($lhs)
	{
		case REG_BC:
			E("\tstax b\n");
			break;

		case REG_DE:
			E("\tstax d\n");
			break;

		case REG_HL:
			E("\tmov m, a\n");
			break;

		default:
			assert(false);
	}
}

gen STORE2(hl, bc|de:rhs) uses a
{
	E("\tmov m, %s\n", regreflo($rhs));
	E("\tinx h\n");
	E("\tmov m, %s\n", regref($rhs));
}

gen STORE1(ADDRESS():lhs, a)
	{ E("\tsta %s\n", symref($lhs.sym, $lhs.off)); }

gen STORE2(ADDRESS():lhs, hl)
	{ E("\tshld %s\n", symref($lhs.sym, $lhs.off)); }

gen STORE4(ADDRESS():lhs, stk4) uses hl
{
	E("\tpop h\n"); 
	E("\tshld %s\n", symref($lhs.sym, $lhs.off+0));
	E("\tpop h\n"); 
	E("\tshld %s\n", symref($lhs.sym, $lhs.off+2));
}

gen a := CONSTANT(value==0)
	{ E("\txra a\n"); }

gen a|b|d|h := CONSTANT():rhs
	{ E("\tmvi %s, %d\n", regref($$), $rhs.value); }

gen bc|de|hl := CONSTANT():rhs
	{ E("\tlxi %s, %d\n", regref($$), $rhs.value); }

gen bc|de|hl := ADDRESS():rhs
	{ E("\tlxi %s, %s\n", regref($$), symref($rhs.sym, $rhs.off)); }

gen stk4 := CONSTANT():c uses hl
{
	E("\tlxi h, %d\n", $c.value >> 16);
	E("\tpush h\n");
	E("\tlxi h, %d\n", $c.value & 0xffff);
	E("\tpush h\n");
}

// --- 8-bit arithmetic -----------------------------------------------------

gen a := ADD1(a, b|d|h:rhs)
	{ E("\tadd %s\n", regref($rhs)); }

gen a := ADD1(a, CONSTANT():rhs)
	{ E("\tadi %d\n", $rhs.value); }

gen a := ADD1(a|b|d|h:lhs, CONSTANT(value==1))
	{ E("\tinc %s\n", regref($lhs)); }

gen a := ADD1(a|b|d|h:lhs, CONSTANT(value==2))
{
	E("\tinc %s\n", regref($lhs));
	E("\tinc %s\n", regref($lhs));
}

gen a := ADD1(a|b|d|h:lhs, CONSTANT(value==-1))
	{ E("\tdec %s\n", regref($lhs)); }

gen a := ADD1(a|b|d|h:lhs, CONSTANT(value==-2))
{
	E("\tdec %s\n", regref($lhs));
	E("\tdec %s\n", regref($lhs));
}

gen a := SUB1(a, b|d|h:rhs)
	{ E("\tsub %s\n", regref($rhs)); }

gen a := SUB1(a, CONSTANT():rhs)
	{ E("\tsbi %d\n", $rhs.value); }

gen a := SUB1(a|b|d|h:lhs, CONSTANT(value==1))
	{ E("\tdec %s\n", regref($lhs)); }

gen a := SUB1(a|b|d|h:lhs, CONSTANT(value==-1))
	{ E("\tinc %s\n", regref($lhs)); }

gen a := NEG1(b|d|h:lhs)
{
	E("\txra a\n");
	E("\tsub %s\n", regref($lhs));
}

gen a := LSHIFT1(a, b) uses bc
	{ E("\tcall asl1\n"); }

gen a := RSHIFTU1(a, b) uses bc
	{ E("\tcall lsr1\n"); }

gen a := RSHIFTS1(a, b) uses bc
	{ E("\tcall asr1\n"); }

// --- 16-bit arithmetic ----------------------------------------------------

gen hl := ADD2(hl|bc|de:lhs, hl|bc|de:rhs)
{ 
	if (($rhs != REG_HL) && ($lhs != REG_HL))
	{
		if ($rhs == REG_DE)
		{
			E("\txchg\n");
			$rhs = REG_HL;
		}
		else if ($lhs == REG_DE)
		{
			E("\txchg\n");
			$lhs = REG_HL;
		}
		else
		{
			E("\tmov h, %s\n", regref($lhs));
			E("\tmov l, %s\n", regreflo($lhs));
			$lhs = REG_HL;
		}
	}
		
	E("\tdad %s\n", regref(($lhs != REG_HL) ? $lhs : $rhs));
}

gen hl := ADD2(hl, CONSTANT(value==1))
	{ E("\tinx h\n"); }

gen hl := ADD2(hl, CONSTANT(value==2))
{
	E("\tinx h\n");
	E("\tinx h\n");
}

gen hl := ADD2(hl, CONSTANT(value==-1))
	{ E("\tdcx h\n"); }

gen hl := ADD2(hl, CONSTANT(value==-2))
{
	E("\tdcx h\n");
	E("\tdcx h\n");
}

gen bc|de|hl := SUB2(bc|de|hl:lhs, bc|de|hl:rhs) uses a
{
    E("\tmov a, %s\n", regreflo($lhs));
    E("\tsub %s\n", regreflo($rhs));
    E("\tmov %s, a\n", regreflo($$));
    E("\tmov a, %s\n", regref($lhs));
    E("\tsbb %s\n", regref($rhs));
    E("\tmov %s, a\n", regref($$));
}

gen bc|de|hl := NEG2(bc|de|hl:lhs) uses a
{
    E("\txra a\n");
    E("\tsub %s\n", regreflo($lhs));
    E("\tmov %s, a\n", regreflo($$));
	E("\tsbb a\n");
    E("\tsub %s\n", regref($lhs));
    E("\tmov %s, a\n", regref($$));
}

gen hl := LSHIFT2(hl, b) uses a
	{ E("\tcall asl2\n"); }

gen hl := RSHIFTU2(hl, b) uses a
	{ E("\tcall lsr2\n"); }

gen hl := RSHIFTS2(hl, b) uses a
	{ E("\tcall asr2\n"); }

// --- 32-bit arithmetic ----------------------------------------------------

gen stk4 := ADD4(stk4, stk4)
	{ E("\tcall add4\n"); }

gen stk4 := SUB4(stk4, stk4)
	{ E("\tcall sub4\n"); }

gen stk4 := NEG4(stk4)
	{ E("\tcall neg4\n"); }

gen stk4 := RSHIFTU4(stk4, b)
	{ E("\tcall lsr4\n"); }

// --- Branches -------------------------------------------------------------

%{
	static void bequ1(int truelabel, int falselabel, reg_t nota)
	{
		E("\tcmp %s\n", regref(nota));
		E("\tjz %s\n", labelref(truelabel));
		E("\tjnz %s\n", labelref(falselabel));
	}
%}

gen BEQU1(b|d|h:nota, a):b
	{ bequ1($b.truelabel, $b.falselabel, $nota); }

gen BEQS1(b|d|h:nota, a):b
	{ bequ1($b.truelabel, $b.falselabel, $nota); }

%{
	static void bequ1c(int truelabel, int falselabel, int c)
	{
		if (!c)
			E("\tora a\n");
		else
			E("\tcpi %d\n", c);
		E("\tjz %s\n", labelref(truelabel));
		E("\tjnz %s\n", labelref(falselabel));
	}
%}
	
gen BEQU1(a, CONSTANT():c):b
	{ bequ1c($b.truelabel, $b.falselabel, $c.value); }

gen BEQS1(a, CONSTANT():c):b
	{ bequ1c($b.truelabel, $b.falselabel, $c.value); }

gen BEQU1(CONSTANT():c, a):b
	{ bequ1c($b.truelabel, $b.falselabel, $c.value); }

gen BEQS1(CONSTANT():c, a):b
	{ bequ1c($b.truelabel, $b.falselabel, $c.value); }

gen BLTU1(a, CONSTANT():c):b
{
	E("\tcpi %d\n", $c.value);
	E("\tjc %s\n", labelref($b.truelabel));
	E("\tjmp %s\n", labelref($b.falselabel));
}

%{
	static void bequ2(int truelabel, int falselabel, reg_t lhs, reg_t rhs)
	{
		E("\tmov a, %s\n", regref(lhs));
		E("\tcmp %s\n", regref(rhs));
		E("\tjnz %s\n", labelref(falselabel));
		E("\tmov a, %s\n", regreflo(lhs));
		E("\tcmp %s\n", regreflo(rhs));
		E("\tjnz %s\n", labelref(falselabel));
		E("\tjmp %s\n", labelref(truelabel));
	}
%}

gen BEQU2(hl|bc|de:lhs, hl|bc|de:rhs):b
	{ bequ2($b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BEQS2(hl|bc|de:lhs, hl|bc|de:rhs):b
	{ bequ2($b.truelabel, $b.falselabel, $lhs, $rhs); }

%{
	static void bequ2c(int truelabel, int falselabel, reg_t lhs, int c)
	{
		E("\tlxi d, 0x%x\n", (-c) & 0xffff);
		E("\tdad d\n");
		E("\tmov a, l\n");
		E("\tora h\n");
		E("\tjnz %s\n", labelref(falselabel));
		E("\tjmp %s\n", labelref(truelabel));
	}
%}

gen BEQU2(hl:lhs, CONSTANT():rhs):b uses de|a
	{ bequ2c($b.truelabel, $b.falselabel, $lhs, $rhs.value); }

gen BEQS2(hl:lhs, CONSTANT():rhs):b uses de|a
	{ bequ2c($b.truelabel, $b.falselabel, $lhs, $rhs.value); }

gen BEQU2(CONSTANT():lhs, hl:rhs):b uses de|a
	{ bequ2c($b.truelabel, $b.falselabel, $rhs, $lhs.value); }

gen BEQS2(CONSTANT():lhs, hl:rhs):b uses de|a
	{ bequ2c($b.truelabel, $b.falselabel, $rhs, $lhs.value); }

gen BLTU2(hl|bc|de:lhs, hl|bc|de:rhs):b uses a
{
	E("\tmov a, %s\n", regreflo($lhs));
	E("\tsub %s\n", regreflo($rhs));
	E("\tmov a, %s\n", regref($lhs));
	E("\tsbb %s\n", regref($rhs));
	E("\tjc %s\n", labelref($b.truelabel));
	E("\tjmp %s\n", labelref($b.falselabel));
}

%{
	static void bequ4(int truelabel, int falselabel, reg_t lhs, reg_t rhs)
	{
		E("\tcall sub4\n");
		E("\tcall cmpu4\n");
		E("\tjnz %s\n", labelref(falselabel));
		E("\tjmp %s\n", labelref(truelabel));
	}
%}

gen BEQU4(stk4:lhs, stk4:rhs):b
	{ bequ4($b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BEQS4(stk4:lhs, stk4:rhs):b
	{ bequ4($b.truelabel, $b.falselabel, $lhs, $rhs); }

// --- Casts ----------------------------------------------------------------

gen a|b|d|h := CAST21(bc|de|hl:rhs)
	{ E("\tmov %s, %s\n", regref($$), regref($rhs)); }
	
gen stk4 := CAST24(hl|de:rhs) uses bc
{
	E("\tlxi b, 0\n");
	E("\tpush b\n");
	E("\tpush %s\n", regref($rhs));
}
	
gen a|d := CAST41(stk4) uses hl|bc
{
	E("\tpop b\n");
	E("\tpop h\n");
	E("\tmov %s, c\n", regref($$));
}
	
gen hl|de := CAST41(stk4) uses bc
{
	E("\tpop b\n");
	E("\tpop %s\n", regref($$));
}
	
// --- Inline assembly ------------------------------------------------------

gen ASMSTART()
{
    asmbuffer[0] = '\0';
}

gen ASMTEXT():t
{
    strlcat(asmbuffer, $t.text, sizeof(asmbuffer));
    strlcat(asmbuffer, " ", sizeof(asmbuffer));
}

gen ASMSYMBOL():s
{
    strlcat(asmbuffer, symref($s.sym, 0), sizeof(asmbuffer));
    strlcat(asmbuffer, " ", sizeof(asmbuffer));
}

gen ASMEND()
{
    E("\t%s\n", asmbuffer);
}

// --- Strings -----------------------------------------------------------

gen bc|de|hl := STRING():s
{
    int sid = id++;
    emitter_open_chunk();
    E("\tcseg\n");
    E("s%d:\n", sid);
    E("\tdb ");
    bool instring = false;
    bool start = true;
	const char* s = $s.text;
    for (;;)
    {
        char c = *s++;
        if (!c)
            break;
        if (!start && !instring)
            E(", ");
        start = false;
        if (isprint(c) && (c != '\"') && (c != '\\'))
        {
            if (!instring)
            {
                E("\"");
                instring = true;
            }
            E("%c", c);
        }
        else
        {
            if (instring)
            {
                E("\", ");
                instring = false;
            }
            E("%d", c);
        }
    }
    if (instring)
        E("\"");
    if (!start)
        E(", ");
    E("0\n");
    emitter_close_chunk();

    E("\tlxi %s, s%d\n", regref($$), sid);
}

