%{
    const VARMEM_WS := 0;
    const VARSTACK_WS := 1;

	var varsp: uint8 := 0;

    record ArchSubroutine is
        end_label: LabelRef;
		var_stack: uint8;
    end record;

	record Extern is
		name: string;
		id: uint16;
		next: [Extern];
	end record;

	record MemOp is
		sym: [Symbol];
		off: Size;
	end record;
		
	record ImmOp is
		value: Arith;
	end record;

	record VsOp is
		sp: uint8;
	end record;

	record XIndOp is
		off: uint16;
	end record;

	record Operand is
		mem @at(0): MemOp;
		xind @at(0): XIndOp;
		imm @at(0): ImmOp;
		vs @at(0): VsOp;
	end record;

	var externs: [Extern] := (0 as [Extern]);

	sub ArchAlignUp(value: Size, alignment: uint8): (newvalue: Size) is
		newvalue := value;
	end sub;

	sub E_symref(sym: [Symbol], off: Size) is
		if sym.wsid == WSID_STATIC then
			E_wsref(sym.subr.id, sym.wsid, sym.off);
			if off != 0 then
				E_i16(off as int16);
			end if;
		else
			E_wsref(sym.subr.id, sym.wsid, sym.off + off);
		end if;
	end sub;

	sub R_flushall() is
		RegCacheFlush(ALL_REGS);
	end sub;

	sub R_flush(reg: RegId) is
		RegCacheFlush(FindConflictingRegisters(reg));
	end sub;

	sub AllocPLabel(): (lid: uint16) is
		# Cheap and cheerful way to allocate a label which won't overlap the
		# frontend's numbering.
		lid := -AllocLabel();
	end sub;

	sub E_label(label: LabelRef) is
		R_flushall();
		E_labelref(label);
		E(" = *\n");
	end sub;

	sub E_insn(insn: string) is
		E_tab();
		E(insn);
		E_space();
	end sub;

	sub E_insn_simple(insn: string) is
		E_tab();
		E(insn);
		E_nl();
	end sub;

	sub E_const() is
		E("#");
	end sub;

	sub E_db() is E_insn("db"); end sub;
	sub E_dw() is E_insn("dw"); end sub;
	sub E_dl() is E_insn("dl"); end sub;

	sub E_jump(insn: string, label: LabelRef) is
		R_flushall();
		E_insn(insn);
		E_labelref(label);
		E_nl();
	end sub;

	sub E_jmp(label: LabelRef) is E_jump("jmp", label); end sub;

	sub E_acc(ainsn: string, binsn: string, reg: RegId) is
		E_tab();
		if reg == REG_A then
			E(ainsn);
		elseif reg == REG_B then
			E(binsn);
		else
			SimpleError("bad accumulator register");
		end if;
		E_space();
	end sub;

	sub E_st(reg: RegId) is
		if reg == REG_A then
			E_insn("staa");
		elseif reg == REG_B then
			E_insn("stab");
		elseif reg == REG_D then
			E_insn("std");
		elseif reg == REG_X then
			E_insn("stx");
		else
			SimpleError("bad accumulator register");
		end if;
	end sub;

	sub E_ld(reg: RegId) is
		R_flush(reg);
		if reg == REG_A then
			E_insn("ldaa");
		elseif reg == REG_B then
			E_insn("ldab");
		elseif reg == REG_D then
			E_insn("ldd");
		elseif reg == REG_X then
			E_insn("ldx");
		else
			SimpleError("bad accumulator register");
		end if;
	end sub;

	sub E_ldx() is
		R_flush(REG_X);
		E_insn("ldx");
	end sub;

	sub E_ldd() is
		R_flush(REG_D);
		E_insn("ldd");
	end sub;

	sub E_add(reg: RegId) is
		R_flush(reg);
		E_acc("adda", "addb", reg);
	end sub;

	sub E_sub(reg: RegId) is
		R_flush(reg);
		E_acc("suba", "subb", reg);
	end sub;

	sub E_op(reg: RegId, operand: [Operand]) is
		case reg is
			when REG_MEM:  E_symref(operand.mem.sym, operand.mem.off);
			when REG_IMM:  E_const(); E_i32(operand.imm.value);
			when REG_X:    E(",x");
			when REG_XIND: E_u16(operand.xind.off); E(",x");

			when REG_VS1:
				E_wsref(current_subr.id, VARSTACK_WS, operand.vs.sp as uint16);
				varsp := varsp - 1;

			when else:
				SimpleError("bad operand");
		end case;
		Free(operand as [uint8]);
	end sub;

	# Note that this *destroys* the source register.
	sub ArchEmitMove(src: RegId, dest: RegId) is
		if (src == REG_A) and (dest == REG_B) then
			E_insn_simple("tab");
		elseif (src == REG_B) and (dest == REG_A) then
			E_insn_simple("tba");
		elseif (src == REG_X) and (dest == REG_D) then
			E_insn_simple("pshx");
			E_insn_simple("popa");
			E_insn_simple("popb");
		elseif (src == REG_D) and (dest == REG_X) then
			E_insn_simple("pshb");
			E_insn_simple("psha");
			E_insn_simple("popx");
		elseif dest == 0 then
			case src is
				when REG_A: E_insn_simple("psha");
				when REG_B: E_insn_simple("pshb");
				when REG_X: E_insn_simple("pshx");
				when REG_D: E_insn_simple("pshb"); E_insn_simple("psha");
			end case;
		elseif src == 0 then
			case dest is
				when REG_A: E_insn_simple("popa");
				when REG_B: E_insn_simple("popb");
				when REG_X: E_insn_simple("popx");
				when REG_D: E_insn_simple("popa"); E_insn_simple("popb");
			end case;
		else
			StartError();
			print("bad move: ");
			print_hex_i16(src);
			print(" -> ");
			print_hex_i16(dest);
			EndError();
		end if;
	end sub;

	sub ArchEndInstruction() is
	end sub;

	sub ArchEndGroup() is
	end sub;
%}

wordsize uint16;

register a; // 001
register b; // 002
register d; // 004
register x; // 008
register vs1; // 010
register vs2; // 020
register param; // 040

operand imm; // 080
operand mem; // 100
operand xind; // 200

regdata a uses d       compatible a|b;
regdata b uses d       compatible a|b;
regdata d uses a|b     compatible d|x;
regdata x              compatible d|x;
regdata param stacked;

regdata xind uses x;

// --- Core things ----------------------------------------------------------

gen STARTFILE();
gen ENDFILE();

gen LABEL():b
{
	E_label($b.label);
}

gen JUMP():j
{
	E_jmp($j.label);
}

// --- Subroutines ----------------------------------------------------------

gen STARTSUB()
{
    current_subr.arch := InternalAlloc(@bytesof ArchSubroutine) as [ArchSubroutine];
    current_subr.arch.end_label := AllocPLabel();

    EmitterOpenStream(current_subr);

    E("\n\n\t; ");
    E(current_subr.name);
    E_nl();

#	E("\t.align 2\n");
    E_b8(COO_ESCAPE_THISSUB);
    E(":\n");
#
#    var count := current_subr.num_input_parameters;
#    while count != 0 loop
#        count := count - 1;
#        var param := GetInputParameter(current_subr, count) as [Symbol];
#
#        case param.width is
#            when 1: E_store1(param, 0);
#			when 2: E_store2(param, 0);
#			when 4: E_store4(param, 0);
#        end case;
#    end loop;
}

gen ENDSUB()
{
	E_label(current_subr.arch.end_label);

#    var i: uint8 := 0;
#    var count := current_subr.num_output_parameters;
#    while i != count loop
#        var param := GetOutputParameter(current_subr, i) as [Symbol];
#
#        var cache: RegId;
#        case param.width is
#            when 1: E_load1(param, 0);
#            when 2: E_load2(param, 0);
#            when 4: E_load4(param, 0);
#		end case;
#
#        i := i + 1;
#    end loop;
#
#	E_callhelper("exit");

    EmitterCloseStream();

    EmitterDeclareWorkspace(current_subr.id, VARSTACK_WS, current_subr.arch.var_stack as uint16);
	Free(current_subr.arch as [uint8]);
}

gen RETURN()
{
	E_insn("jmp");
	E_labelref(current_subr.arch.end_label);
	E_nl();
}

// --- Values ---------------------------------------------------------------

gen mem := ADDRESS():a
{
	var op := InternalAlloc(@bytesof Operand) as [Operand];
	op.mem.sym := &$a.sym;
	op.mem.off := $a.off;
	self.n[0].operand := op;
}

gen xind := ADD2(x, CONSTANT():c) cost 5
{
	var op := InternalAlloc(@bytesof Operand) as [Operand];
	op.xind.off := $c.value as uint16;
	self.n[0].operand := op;
}

gen imm := CONSTANT():c
{
	var op := InternalAlloc(@bytesof Operand) as [Operand];
	op.imm.value := $c.value;
	self.n[0].operand := op;
}

gen vs1 := FALLBACK(a|b:lhs)
{
	E_st($lhs);
	E_wsref(current_subr.id, VARSTACK_WS, varsp as uint16);
	E_nl();

	var op := InternalAlloc(@bytesof Operand) as [Operand];
	op.vs.sp := varsp;
	varsp := varsp + 1;
	if current_subr.arch.var_stack < varsp then
		current_subr.arch.var_stack := varsp;
	end if;
	self.n[0].operand := op;
}

gen vs2 := FALLBACK(d|x:lhs)
{
	E_st($lhs);
	E_wsref(current_subr.id, VARSTACK_WS, varsp as uint16);
	E_nl();

	var op := InternalAlloc(@bytesof Operand) as [Operand];
	op.vs.sp := varsp;
	varsp := varsp + 2;
	if current_subr.arch.var_stack < varsp then
		current_subr.arch.var_stack := varsp;
	end if;
	self.n[0].operand := op;
}

gen x|d := ADDRESS():a
{
	var cache := RegCacheFindAddress(&$a.sym, $a.off) & $$;
	if (cache & $$) != 0 then
		# The value is already in the desired register.
		return;
	end if;

	if $$ == REG_X then
		E_ldx();
	else
		E_ldd();
	end if;
	E_const();
	E_symref(&$a.sym, $a.off);
	E_nl();

	RegCacheLeavesAddress($$, &$a.sym, $a.off);
}

gen a|b|x := CONSTANT():c
{
	var cache := RegCacheFindConstant($c.value as uint16) & $$;
	if (cache & $$) != 0 then
		# The value is already in the desired register.
		return;
	end if;

	E_ld($$);
	E_const();
	E_i16($c.value as int16);
	E_nl();

	RegCacheLeavesConstant($$, $c.value as uint16);
}

// --- Loads and stores -----------------------------------------------------

gen STORE1(a|b:lhs, mem|xind|x:rhs)
{
	var o := $@rhs.operand;
	if $rhs == REG_MEM then
		RegCacheLeavesValue($lhs, o.mem.sym, o.mem.off);
	end if;

	E_st($lhs);
	E_op($rhs, o);
	E_nl();
}

gen a|b := LOAD1(mem|xind|x:rhs)
{
	if $rhs == REG_MEM then
		var cache := RegCacheFindValue(self.n[1].operand.mem.sym, self.n[1].operand.mem.off) & $$;
		if (cache & $$) != 0 then
			# The value is already in the desired register.
			Free($@rhs.operand as [uint8]);
			return;
		end if;
	end if;

	E_ld($$);
	if $rhs == REG_MEM then
		RegCacheLeavesValue($$, $@rhs.operand.mem.sym, $@rhs.operand.mem.off);
	end if;
	E_op($rhs, $@rhs.operand);
	E_nl();
}

gen STORE2(x|d:lhs, mem|xind|x:rhs)
{
	var o := $@rhs.operand;
	if $rhs == REG_MEM then
		RegCacheLeavesValue($lhs, o.mem.sym, o.mem.off);
	end if;

	E_st($lhs);
	E_op($rhs, o);
	E_nl();
}

gen d|x := LOAD2(mem|xind|x:rhs)
{
	var o := $@rhs.operand;
	if $rhs == REG_MEM then
		var cache := RegCacheFindValue(o.mem.sym, o.mem.off) & $$;
		if (cache & $$) != 0 then
			# The value is already in the desired register.
			Free(o as [uint8]);
			return;
		end if;
	end if;

	E_ld($$);
	if $rhs == REG_MEM then
		RegCacheLeavesValue($$, o.mem.sym, o.mem.off);
	end if;
	E_op($rhs, o);
	E_nl();
}

// --- 8-bit arithmetic -----------------------------------------------------

gen a|b := ADD1($$:lhs, LOAD1(mem|xind|x:rhs))
{
	RegCacheFlush($$);
	E_add($$);
	E_op($rhs, $@rhs.operand);
	E_nl();
}

gen a|b := ADD1($$:lhs, imm|vs1|b:rhs)
{
	RegCacheFlush($$);
	if ($rhs == REG_B) and ($lhs == REG_A) then
		E_insn_simple("aba");
	else
		E_add($$);
		E_op($rhs, $@rhs.operand);
		E_nl();
	end if;
}

gen a|b := SUB1($$:lhs, LOAD1(mem|xind|x:rhs))
{
	RegCacheFlush($$);
	E_sub($$);
	E_op($rhs, $@rhs.operand);
	E_nl();
}

gen a|b := SUB1($$:lhs, imm|vs1|b:rhs)
{
	RegCacheFlush($$);
	if ($rhs == REG_B) and ($lhs == REG_A) then
		E_insn_simple("sba");
	else
		E_sub($$);
		E_op($rhs, $@rhs.operand);
		E_nl();
	end if;
}

// --- 16-bit arithmetic ----------------------------------------------------

gen d := ADD2($$:lhs, LOAD2(mem|xind|x:rhs))
{
	RegCacheFlush($$);
	E_insn("addd");
	E_op($rhs, $@rhs.operand);
	E_nl();
}

gen d := ADD2($$:lhs, imm:rhs)
{
	RegCacheFlush($$);
	E_insn("addd");
	E_op($rhs, $@rhs.operand);
	E_nl();
}

%{
	sub is_byte(value: int32): (result: uint8) is
		if (value & 0xffffff00) == 0 then
			result := 1;
		else
			result := 0;
		end if;
	end sub;
%}

gen x := ADD2($$:lhs, CONSTANT(value is byte):c) uses b
{
	var cache := RegCacheFindConstant($c.value as uint16) & $$;
	if (cache & $$) != 0 then
		# The value is already in the desired register.
	else
		RegCacheFlush(REG_B);
		E_insn("ldab #");
		E_u8($c.value as uint8);
		E_nl();
		RegCacheLeavesConstant($$, $c.value as uint16);
	end if;

	RegCacheFlush($$);
	E_insn_simple("abx");
}

gen x := ADD2($$:lhs, CONSTANT(value == 1)) cost 1
{
	RegCacheFlush($$);
	E_insn_simple("inx");
}

gen x := ADD2($$:lhs, CONSTANT(value == -1)) cost 1
{
	RegCacheFlush($$);
	E_insn_simple("dex");
}

// --- Conditionals ---------------------------------------------------------

gen BEQ0(CONSTANT():lhs, CONSTANT():rhs):b
{
    var label := $b.falselabel;
    if $lhs.value == $rhs.value then
        label := $b.truelabel;
    end if;
    if label != $b.fallthrough then
        E_jmp(label);
    end if;
}

// --- Strings --------------------------------------------------------------

%{
    sub E_string(data: string): (lid: uint16) is
        lid := AllocPLabel();

        EmitterOpenStream(current_subr);

        E_label(lid);
        E_db();

        loop
            var c := [data];
            if c == 0 then
                break;
            end if;
            data := data + 1;
            
            E_u8(c);
            E_comma();
        end loop;
        E("0\n");
        EmitterCloseStream();
    end sub;
%}

// --- Initialisers ---------------------------------------------------------

gen STARTINIT():s
{
    EmitterOpenStream(current_subr);
	E_symref(&$s.sym, 0);
    E(":\n");
}

gen ENDINIT()
{
    EmitterCloseStream();
}

gen INIT1():c
{
    E_db();
    E_u8($c.value as uint8);
    E_nl();
}

gen INIT2():c
{
    E_dw();
    E_u16($c.value as uint16);
    E_nl();
}

gen INIT4():c
{
    E_dl();
    E_u32($c.value as uint32);
    E_nl();
}

gen INITADDRESS():a
{
	E_symref(&$a.sym, $a.off);
}

gen INITSUBREF():a
{
	E_subref($a.subr);
}

gen INITSTRING():s
{
    var sid := E_string($s.text);

    E_dw();
    E_labelref(sid);
    E_nl();
}

// --- Inline assembly ------------------------------------------------------

gen ASMGROUPSTART();
gen ASMGROUPEND();

gen ASMSTART()
{
    E_tab();
}

gen ASMTEXT():t
{
    E($t.text);
    E_space();
}

gen ASMSYMBOL():s
{
	E_symref(&$s.sym, 0);
    E_space();
}

gen ASMSUBREF():s
{
	E_subref($s.subr);
    E_space();
}

gen ASMVALUE():c
{
    E_openp();
    E_i32($c.value);
    E_closep();
}

gen ASMEND()
{
    E_nl();
}

// vim: sw=4 ts=4 et

