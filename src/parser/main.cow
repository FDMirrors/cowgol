const LEX_TOP := 0;
const LEX_SUBROUTINE := 1;

var lexical_stack: uint16[32];
var lexical_stack_ptr: uint8 := 0;

var current_namespace_id: uint16;
var current_subroutine_id: uint16;

sub halt()
    print(" at ");
    if filename_id != 0 then
        print_string_thing(filename_id);
    else
        print("?");
    end if;
    print_char(':');
    print_i16(line_no);
    print_newline();
    exit(1);
end sub;

sub lexical_push(value: uint16)
    if lexical_stack_ptr == lexical_stack'size then
        print("lexical stack overflow");
        halt();
    end if;

    lexical_stack[lexical_stack_ptr] := value;
    lexical_stack_ptr := lexical_stack_ptr + 1;
end sub;

sub lexical_pop(out value: uint16)
    if lexical_stack_ptr == 0 then
        print("lexical stack underflow");
        halt();
    end if;

    lexical_stack_ptr := lexical_stack_ptr - 1;
    value := lexical_stack[lexical_stack_ptr];
end sub;

sub lexical_pop_scope_type(type: uint16)
    if lexical_pop() != type then
        print("mismatched lexical scope terminator");
        halt();
    end if;
end sub;

sub create_function(out subroutine_id: uint16, out namespace_id: uint16)
    subroutine_id := create_thing(THING_SUBROUTINE, SubroutineThing'bytes);
    namespace_id := create_thing(THING_NAMESPACE, NamespaceThing'bytes);
    var namespace: [NamespaceThing] := find_thing(namespace_id) as [NamespaceThing];
    namespace.previous_namespace := current_namespace_id;
    var subroutine: [SubroutineThing] := find_thing(subroutine_id) as [SubroutineThing];
    subroutine.namespace := namespace_id;
end sub;

sub push_subroutine()
    lexical_push(current_subroutine_id);
    lexical_push(current_namespace_id);
    lexical_push(LEX_SUBROUTINE);
end sub;

sub pop_subroutine()
    lexical_pop_scope_type(LEX_SUBROUTINE);
    current_namespace_id := lexical_pop();
    current_subroutine_id := lexical_pop();
end sub;

sub init_parser()
    current_namespace_id := 0;
    lexical_push(LEX_TOP);

    create_function(current_subroutine_id, current_namespace_id);
end sub;

sub expect_token(expected: uint16)
    if current_token != expected then
        print("expected 0x");
        print_hex_i16(expected);
        print(" but got 0x");
        print_hex_i16(current_token);
    end if;
    next_token_without_whitespace();
end sub;

sub expect_identifier(out id: uint16)
    if (current_token & TOKEN_TYPE_MASK) != TOKEN_TYPE_IDENTIFIER then
        print("missing identifier");
        halt();
    end if;

    id := current_token & TOKEN_VALUE_MASK;
    next_token_without_whitespace();
end sub;

sub find_symbol_in_namespace(identifier_id: uint16, namespace_id: uint16, out symbol_id: uint16)
    var namespace: [NamespaceThing] := find_thing(namespace_id) as [NamespaceThing];
    symbol_id := namespace.first_symbol;

    while symbol_id != 0 loop
        var symbol: [SymbolThing] := find_thing(symbol_id) as [SymbolThing];
        if symbol.name == identifier_id then
            return;
        end if;
        symbol_id := symbol.next_symbol;
    end loop;

    symbol_id := 0;
end sub;

sub find_symbol(identifier_id: uint16, out symbol_id: uint16)
    var namespace_id: uint16 := current_namespace_id;

    while namespace_id != 0 loop
        symbol_id := find_symbol_in_namespace(identifier_id, namespace_id);
        if symbol_id != 0 then
            return;
        end if;

        var namespace: [NamespaceThing] := find_thing(namespace_id) as [NamespaceThing];
        namespace_id := namespace.previous_namespace;
    end loop;

    print("symbol with identifier 0x");
    print_hex_i16(identifier_id);
    print(" not found in any scope");
    halt();
end sub;

sub name_symbol(identifier_id: uint16, symbol_id: uint16, namespace_id: uint16)
    var symbol: [SymbolThing] := find_thing(symbol_id) as [SymbolThing];
    var namespace: [NamespaceThing] := find_thing(namespace_id) as [NamespaceThing];

    if find_symbol_in_namespace(identifier_id, namespace_id) != 0 then
        print("symbol with identifier 0x");
        print_hex_i16(identifier_id);
        print(" is already defined in this namespace");
        halt();
    end if;

    symbol.next_symbol := namespace.first_symbol;
    namespace.first_symbol := symbol_id;
    symbol.name := identifier_id;
end sub;

sub do_sub()
    var old_namespace_id: uint16 := current_namespace_id;

    push_subroutine();
    expect_token(TOKEN_SUB);
    var id: uint16 := expect_identifier();

    create_function(current_subroutine_id, current_namespace_id);
    name_symbol(id, current_subroutine_id, old_namespace_id);
end sub;

sub do_end()
    expect_token(TOKEN_END);
    expect_token(TOKEN_SUB);
    pop_subroutine();
end sub;

init_parser();
init_tokeniser();

while current_token != 0 loop
    if current_token == TOKEN_SUB then
        do_sub();
    elseif current_token == TOKEN_END then
        do_end();
    else
        print("unknown token 0x");
        print_hex_i16(current_token);
        halt();
    end if;
    next_token_without_whitespace();
end loop;

print("thing table size: ");
print_i16(thing_table_top);
print_newline();
save_thing_table("things.dat");
