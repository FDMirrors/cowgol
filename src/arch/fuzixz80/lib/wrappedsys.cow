const O_RDONLY := 0;
const O_WRONLY := 1;
const O_RDWR   := 2;
const O_CREAT  := 256;
const O_TRUNC  := 1024;

const SEEK_SET := 0;
const SEEK_CUR := 1;
const SEEK_END := 2;

sub exit(status: int16)
    @bytes 0x2a, &status;                 # ld hl, (status)
    @bytes 0xe5;                          # push hl
    @bytes 0x2e, 0;                       # ld l, #0
    @bytes 0xe5;                          # push hl
    @bytes 0xf7;                          # rst #0x30
    # No need to clean up, we're exiting.
end sub;

sub lseek(fd: int8, offsetin: uint32, whence: uint16): (offsetout: uint32)
    offsetout := offsetin;
    var result: int8 := _lseek(fd, &offsetout, whence);
    if result != 0 then
        offsetout := -1;
    end if;
end sub;

var __printbuf: int8[32];
var __printbufpos: uint8 := 0;

sub print_char(c: int8)
    __printbuf[__printbufpos] := c;
    if (__printbufpos == (__printbuf@bytes-1)) or (c == '\n') or (c == '\r') then
        var status: int16 := write(0, &__printbuf[0], (__printbufpos+1) as uint16);
        __printbufpos := 0;
    else
        __printbufpos := __printbufpos + 1;
    end if;
end sub;

sub print_newline()
    print_char('\n');
end sub;

