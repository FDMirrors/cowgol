var current_token: uint16;
var filename_id: uint16 := 0;

var debug_option: uint8 := 0;

sub skip_whitespace()
	loop
		var type: int8 := classify_char_type(current_byte);
		if (type != NEWLINE) and (type != WHITESPACE) and (type != '#') then
			break;
		end if;
		next_byte();
		if current_byte == '#' then
			while (current_byte != -1) and (current_byte != '\n') loop
				next_byte();
			end loop;
		end if;
	end loop;
end sub;

sub read_raw_identifier()
	buffer_index := 0;
    loop
        input_buffer[buffer_index] := current_byte;
        buffer_index := buffer_index + 1;

        var type: int8 := classify_char_type(peeked_byte);
        if (type != ALPHABETIC) and (type != DIGIT) then
            break;
        end if;
        next_byte();
    end loop;

	input_buffer[buffer_index] := 0;
end sub;

sub read_identifier()
	read_raw_identifier();

    var string_id: uint16 := lookup_string(&input_buffer[0], buffer_index);
    current_token := find_token_by_string(string_id);
    if current_token == 0 then
        var buf: IdentifierThing[1];
        buf[0].thing_type := THING_IDENTIFIER;
        buf[0].thing_size := IdentifierThing@bytes;
        buf[0].string_id := string_id;
        current_token := add_thing_by_value(&buf[0] as [Thing]);
    end if;
end sub;

sub read_number()
    loop
        input_buffer[buffer_index] := current_byte;
        buffer_index := buffer_index + 1;

        var type: int8 := classify_char_type(peeked_byte);
        if (type != ALPHABETIC) and (type != DIGIT) then
            break;
        end if;
        next_byte();
    end loop;

    var base: uint8 := 10;
    var ptr: [int8] := &input_buffer[0];
    if (buffer_index >= 2) and (input_buffer[0] == '0') then
        if input_buffer[1] == 'x' then
            base := 16;
            ptr := &input_buffer[2];
        elseif input_buffer[1] == 'o' then
            base := 8;
            ptr := &input_buffer[2];
        elseif input_buffer[1] == 'b' then
            base := 2;
            ptr := &input_buffer[2];
        end if;
    end if;

    input_buffer[buffer_index] := 0;
    var value: int32 := string_to_number(ptr, base);
    current_token := add_number_by_value(value);
end sub;

sub read_comment()
    while current_byte != 10 loop
        next_byte();
    end loop;
end sub;

sub is_double_char_symbol(left: int8, right: int8): (yes: uint8)
    if ((left == '!') or (left == ':') or (left == '=') or (left == '<') or (left == '>'))
        and (right == '=')
    then
        yes := 1;
    elseif ((left == '<') or (left == '>')) and (left == right) then
        yes := 1;
    else
        yes := 0;
    end if;
end sub;

sub read_symbol()
    input_buffer[0] := current_byte;
    if is_double_char_symbol(current_byte, peeked_byte) != 0 then
        input_buffer[1] := peeked_byte;
        buffer_index := 2;
        next_byte();
    else
        buffer_index := 1;
    end if;

    input_buffer[buffer_index] := 0;
    var string_id: uint16 := lookup_string(&input_buffer[0], buffer_index);
    current_token := find_token_by_string(string_id);
    if current_token == 0 then
        print("unrecognised symbol '");
        print(&input_buffer[0]);
        print_char('\'');
        error_with_location();
    end if;
end sub;

sub decode_escaped_char()
    if current_byte == 'n' then
        current_byte := 10;
    elseif current_byte == 'r' then
        current_byte := 13;
    elseif current_byte == '0' then
        current_byte := 0;
    elseif (current_byte == '\\') or (current_byte == '"') or (current_byte == '\'') then
    else
        print("unrecognised string escape \\");
        print_char(current_byte);
        error_with_location();
    end if;
end sub;

sub add_string_thing(string_id: uint16): (token_id: uint16)
    var buf: StringThing[1];
    buf[0].thing_type := THING_STRING;
    buf[0].thing_size := StringThing@bytes;
    buf[0].string_id := string_id;
    buf[0].string_size := buffer_index;
    token_id := add_thing_by_value(&buf[0] as [Thing]);
end sub;

sub read_string()
    next_byte();
    loop
        if current_byte == '"' then
            break;
        elseif current_byte == '\\' then
            next_byte();
            decode_escaped_char();
        end if;
        input_buffer[buffer_index] := current_byte;
        buffer_index := buffer_index + 1;
        next_byte();
    end loop;

    var string_id: uint16 := lookup_string(&input_buffer[0], buffer_index);
    current_token := add_string_thing(string_id);
end sub;

sub read_char_constant()
    next_byte();
    if current_byte == '\\' then
        next_byte();
        decode_escaped_char();
    end if;

    var buf: NumberThing[1];
    buf[0].thing_type := THING_NUMBER;
    buf[0].thing_size := NumberThing@bytes;
    buf[0].value := current_byte as int32;

    current_token := add_thing_by_value(&buf[0] as [Thing]);

    next_byte();
    if current_byte != '\'' then
        print("invalid character constant");
        error_with_location();
    end if;
end sub;

var in_if: uint8 := 0;
sub do_compilation_option()
	next_byte();

	read_raw_identifier();
	next_byte();

	if compare_strings(&input_buffer[0], "if") == 0 then
		if in_if != 0 then
			print("can't nest $if (yet)");
			error_with_location();
		end if;
		in_if := 1;

		var inverted_case: uint8 := 0;
		skip_whitespace();
		if current_byte == '!' then
			inverted_case := 1;
			next_byte();
			skip_whitespace();
		end if;

		read_raw_identifier();
		next_byte();
		if compare_strings(&input_buffer[0], "DEBUG") != 0 then
			print("only DEBUG is supported here (now)");
			error_with_location();
		end if;

		if inverted_case == debug_option then
			while current_byte != '$' loop
				if current_byte == -1 then
					print("end of file in $if");
					error_with_location();
				end if;
				next_byte();
			end loop;
		end if;
	elseif compare_strings(&input_buffer[0], "endif") == 0 then
		if in_if == 0 then
			print("$endif without $if");
			error_with_location();
		end if;
		in_if := 0;
	else
		print("unknown directive '");
		print(&input_buffer[0]);
		print("'");
		error_with_location();
	end if;
end sub;

sub next_token()
    if current_byte == -1 then
        current_token := 0;
        return;
    end if;

	buffer_index := 0;
	loop
		skip_whitespace();
		if current_byte == '$' then
			do_compilation_option();
		else
			break;
		end if;
	end loop;
	if current_byte == -1 then
		current_token := 0;
		return;
	end if;

	var type: int8 := classify_char_type(current_byte);
    if current_byte == '"' then
        read_string();
    elseif current_byte == '\'' then
        read_char_constant();
    elseif (type == ALPHABETIC) or (current_byte == '@') then
        read_identifier();
    elseif type == SYMBOL then
        read_symbol();
    elseif type == DIGIT then
        read_number();
    else
        print("unknown char '");
        print_char(current_byte);
        print("'");
        error_with_location();
    end if;
    next_byte();
end sub;

sub init_tokeniser()
    next_byte();
    next_byte();
    next_token();
end sub;

sub install_root_thing()
    var id: uint16 := create_thing(THING_ROOT, RootThing@bytes);
    root := find_thing(1) as [RootThing];
end sub;

sub install_identifier(name: [int8], id: uint16, thingtype: uint8, token_flags: uint8)
    copy_string(name, &input_buffer[0]);
    buffer_index := string_length(&input_buffer[0]) as uint8;

    var string_id: uint16 := lookup_string(&input_buffer[0], buffer_index);
    var buf: TokenThing[1];
    buf[0].thing_type := thingtype;
    buf[0].string_id := string_id;
    if thingtype == THING_TOKEN then
        buf[0].thing_size := TokenThing@bytes;
        buf[0].token_flags := token_flags;
    else
        buf[0].thing_size := IdentifierThing@bytes;
    end if;
    var token_id: uint16 := add_thing(&buf[0] as [Thing]);

    if token_id != id then
        print("token id mismatch (internal error); wanted 0x");
        print_hex_i16(id);
        print(", got 0x");
        print_hex_i16(token_id);
        print_newline();
        exit(1);
    end if;
end sub;
