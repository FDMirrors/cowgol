var iop_out_fd: uint8;
var old_filename_id: uint16;
var old_linenumber: uint16;

sub init_iop_writer(filename: [int8])
    iop_out_fd := file_openout(filename);
end sub;

sub write_iop_header(header: [IHeader])
    file_putblock(iop_out_fd, header as [int8], IHeader@bytes);
    old_filename_id := 0;
    old_linenumber := 0;
end sub;

sub write_terminating_iop_header()
    var buf: IHeader[1];
    buf[0].thing_id := 0;
    buf[0].section := 0;
    write_iop_header(&buf[0]);
end sub;

sub write_iop(iop: [Iop])
    if current_filename_id != old_filename_id then
        var fbuf: FilenameIop[1];
        fbuf[0].iop_size := FilenameIop@bytes;
        fbuf[0].iop_kind := IOP_FILENAME;
        fbuf[0].thing_id := current_filename_id;
        file_putblock(iop_out_fd, &fbuf[0] as [int8], FilenameIop@bytes);
        old_filename_id := current_filename_id;
    end if;

    if current_linenumber != old_linenumber then
        var lbuf: LinenumberIop[1];
        lbuf[0].iop_size := LinenumberIop@bytes;
        lbuf[0].iop_kind := IOP_LINENUMBER;
        lbuf[0].line_number := current_linenumber;
        file_putblock(iop_out_fd, &lbuf[0] as [int8], LinenumberIop@bytes);
        old_linenumber := current_linenumber;
    end if;

    file_putblock(iop_out_fd, iop as [int8], iop.iop_size);
end sub;

sub write_untyped_iop(kind: uint8)
    var obuf: Iop[1];
    obuf[0].iop_kind := kind;
    obuf[0].iop_size := Iop@bytes;
    write_iop(&obuf[0] as [Iop]);
end sub;

sub write_offset_iop(offset: int16, type_id: uint16)
    var obuf: OffsetIop[1];
    obuf[0].iop_kind := IOP_OFFSETOP;
    obuf[0].iop_size := OffsetIop@bytes;
    obuf[0].offset := offset;
    obuf[0].type_id := type_id;
    write_iop(&obuf[0] as [Iop]);
end sub;

sub write_push_number_iop(value: uint32, type_id: uint16)
    var obuf: ThingIop[1];
    obuf[0].iop_kind := IOP_THING;
    obuf[0].iop_size := ThingIop@bytes;
    obuf[0].thing_id := add_number_by_value(value);
    obuf[0].type_id := type_id;
    write_iop(&obuf[0] as [Iop]);
end sub;

sub write_typed_iop(kind: uint8, type_id: uint16)
    var obuf: TypedIop[1];
    obuf[0].iop_kind := kind;
    obuf[0].iop_size := TypedIop@bytes;
    obuf[0].type_id := type_id;
    write_iop(&obuf[0] as [Iop]);
end sub;

sub write_end_iop()
    var buf: Iop[1];
    buf[0].iop_size := Iop@bytes;
    buf[0].iop_kind := IOP_END;
    write_iop(&buf[0]);
end sub;

sub write_bytes_iop(byte_count: uint8, bytes: [uint8])
    var buf: BytesIop[1];
    buf[0].iop_size := BytesIop@bytes;
    buf[0].iop_kind := IOP_BYTES;
    buf[0].byte_count := byte_count;
    copy_memory(bytes as [int8], &buf[0].bytes[0] as [int8], byte_count);
    write_iop(&buf[0] as [Iop]);
end sub;

sub write_word_iop(thing_id: uint16, offset_id: uint16)
    var buf: WordIop[1];
    buf[0].iop_size := WordIop@bytes;
    buf[0].iop_kind := IOP_WORD;
    buf[0].thing_id := thing_id;
    buf[0].offset_id := offset_id;
    write_iop(&buf[0] as [Iop]);
end sub;

sub write_cg_copy_iop(iop: uint8, opcode: uint8, src_thing_id: uint16, src_offset_id: int16,
        dest_thing_id: uint16, dest_offset_id: uint16)
    var buf: CGCopyNIop[1];
    buf[0].iop_size := CGCopyNIop@bytes;
    buf[0].iop_kind := iop;
    buf[0].opcode := opcode;
    buf[0].src_thing_id := src_thing_id;
    buf[0].src_offset_id := src_offset_id;
    buf[0].dest_thing_id := dest_thing_id;
    buf[0].dest_offset_id := dest_offset_id;
    write_iop(&buf[0] as [Iop]);
end sub;

sub write_cg_6502_mem_iop(opcode: uint8, thing_id: uint16, offset_id: int16)
    var buf: CG6502MemIop[1];
    buf[0].iop_size := CG6502MemIop@bytes;
    buf[0].iop_kind := IOP_CG_6502_MEM;
    buf[0].opcode := opcode;
    buf[0].thing_id := thing_id;
    buf[0].offset_id := offset_id;
    write_iop(&buf[0] as [Iop]);
end sub;

sub write_cg_6502_zeropage_iop(thing_id: uint16, offset_id: uint16)
    var buf: CG6502ZeroPageIop[1];
    buf[0].iop_size := CG6502ZeroPageIop@bytes;
    buf[0].iop_kind := IOP_CG_6502_ZEROPAGE;
    buf[0].thing_id := thing_id;
    buf[0].offset_id := offset_id;
    write_iop(&buf[0] as [Iop]);
end sub;

sub write_cg_6502_conditional_iop(opcode: uint8, label_id: uint16)
    var buf: CG6502ConditionalIop[1];
    buf[0].iop_size := CG6502ConditionalIop@bytes;
    buf[0].iop_kind := IOP_CG_6502_COND;
    buf[0].opcode := opcode;
    buf[0].label_id := label_id;
    write_iop(&buf[0] as [Iop]);
end sub;

