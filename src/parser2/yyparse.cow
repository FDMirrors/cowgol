sub yyparse(): (result: int8)
    type State := uint8;

    var stack: StackEntry[STACK_SIZE];
    var ps: [StackEntry];
    var rule: int16;
    var h: int16;
    var state: State;
    var n: int16;
    var tk: int16;

    ps := &stack[0];
    state := INITIAL_STATE;
    ps.state := state;
    tk := -1;

do_loop:
    n := state_to_displacement[state];
    if (tk < 0) and (n > -NUMBER_OF_TOKENS) then
        tk := yylex();
    end if;
    n := n + tk;
    if (n < 0) or (n >= actions_and_gotos@size) or (checking_table[n as checking_table@index] != tk) then
        rule := state_to_reduce[state];
        if rule < 0 then
            result := -1;
            return;
        end if;
        goto do_reduce;
    end if;

    n := actions_and_gotos[n as actions_and_gotos@index];
    if n == -1 then
        result := -1;
        return;
    end if;
    if n < 0 then
        rule := 0 - (n+2);
        goto do_reduce;
    end if;

    tk := -1;
    copy_yystype(&yylval, &yyval);
do_stack:
    ps := ps + 1;
    if ps >= &stack[STACK_SIZE] then
        result := -2;
        return;
    end if;
    state := n as State;
    ps.state := state;
    copy_yystype(&yyval, &ps.val);
    goto do_loop;

do_reduce:
    ps := ps - rule_to_arity_table[rule as rule_to_arity_table@index];
    h := rule_to_symbol[rule as rule_to_symbol@index];
    state := ps.state;
    n := nt_to_displacement[h as nt_to_displacement@index] + (state as int16);
    if (n < 0) or (n >= actions_and_gotos@size) or (checking_table[n as checking_table@index] != (NUMBER_OF_TOKENS+h)) then
        n := nt_to_goto[h as nt_to_goto@index];
    else
        n := actions_and_gotos[n as actions_and_gotos@index];
    end if;

    parser_action(rule);
    if rule == 0 then
        result := 0;
        return;
    end if;
    goto do_stack;
end sub;
