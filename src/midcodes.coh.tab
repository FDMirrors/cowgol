# In order from left to right: has sizes, number of inputs, number of outputs,
# instruction definition.
- 0 0 END()
- 0 0 STARTFILE()
- 0 0 ENDFILE()
- 0 0 STARTSUB(subr: [Subroutine]) = ("%s", $$.subr.name)
- 0 0 ENDSUB(subr: [Subroutine]) = ("%s", $$.subr.name)

- 0 0 STARTINIT(sym: [Symbol]) = ("%s", $$.sym.name)
y 0 0 INIT(value: int32) = ("%d", $$.value)
- 0 0 INITS(text: string) = ("...")
- 0 0 ENDINIT()

- 0 0 ASMSTART()
- 0 0 ASMTEXT(text: string) = ("%s", $$.text)
- 0 0 ASMSYMBOL(sym: [Symbol]) = ("%s", $$.sym.name)
- 0 0 ASMVALUE(value: int32) = ("%d", $$.value)
- 0 0 ASMEND()

# This one is used internally for bookkeeping and the backend should never see it.
- 2 1 PAIR()

- 0 0 LABEL(label: uint16) = ("%d", $$.label)
- 0 0 JUMP(label: uint16) = ("%d", $$.label)
- 1 0 CALLS()
- 0 0 CALL(subr: [Subroutine]) = ("%s", $$.subr.name)
- 0 0 RETURN()

- 0 1 CONSTANT(value: int32) = ("%d", $$.value)
- 0 1 STRING(text: string) = ("...")
- 0 1 ADDRESS(sym: [Symbol], off: Size) = ("%s%+d", $$.sym.name, $$.off)

y 1 1 LOAD()
y 2 0 STORE() # left is value, right is address

y 2 0 BEQS(truelabel: LabelRef, falselabel: LabelRef, fallthrough: LabelRef, negated: uint8) = ("true=%d false=%d, fallthrough=%d negated=%d", $$.truelabel, $$.falselabel, $$.fallthrough, $$.negated)
y 2 0 BLTS(truelabel: LabelRef, falselabel: LabelRef, fallthrough: LabelRef, negated: uint8) = ("true=%d false=%d, fallthrough=%d negated=%d", $$.truelabel, $$.falselabel, $$.fallthrough, $$.negated)
y 2 0 BEQU(truelabel: LabelRef, falselabel: LabelRef, fallthrough: LabelRef, negated: uint8) = ("true=%d false=%d, fallthrough=%d negated=%d", $$.truelabel, $$.falselabel, $$.fallthrough, $$.negated)
y 2 0 BLTU(truelabel: LabelRef, falselabel: LabelRef, fallthrough: LabelRef, negated: uint8) = ("true=%d false=%d, fallthrough=%d negated=%d", $$.truelabel, $$.falselabel, $$.fallthrough, $$.negated)

y 2 0 STARTCASE() # left is value, right is when chain
- 1 0 WHENCASE(isdefault: uint8, value: int32, label: uint16) = ("%s %d => %d", $$.isdefault ? "default" : "", $$.value, $$.label) # left is chain

# These produce all combinations of source and destination widths.
y 1 1 CAST1()
y 1 1 CAST2()
y 1 1 CAST4()
y 1 1 CAST8()

y 1 0 PUSHARG(subr: [Subroutine], arg: uint8)
y 2 1 POPARG() # left is chain, right is lvalue

y 2 1 ADD()
y 2 1 SUB()
y 2 1 MUL()
y 2 1 DIVU()
y 2 1 DIVS()
y 2 1 REMU()
y 2 1 REMS()
y 2 1 AND()
y 2 1 OR()
y 2 1 EOR()
y 1 1 NOT()
y 1 1 NEG()
y 2 1 LSHIFT()
y 2 1 RSHIFTU()
y 2 1 RSHIFTS()

