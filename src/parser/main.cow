
sub create_function(out subroutine_id: uint16, out namespace_id: uint16)
    subroutine_id := create_thing(THING_SUBROUTINE, SubroutineThing@bytes);
    namespace_id := create_thing(THING_NAMESPACE, NamespaceThing@bytes);
    var namespace: [NamespaceThing] := find_thing(namespace_id) as [NamespaceThing];
    namespace.previous_namespace := current_namespace_id;
    var subroutine: [SubroutineThing] := find_thing(subroutine_id) as [SubroutineThing];
    subroutine.namespace := namespace_id;
end sub;

sub create_label(out label_id: uint16)
    label_id := create_thing(THING_LABEL, LabelThing@bytes);
end sub;

sub push_subroutine()
    lexical_push(current_subroutine_id);
    lexical_push(current_namespace_id);
    lexical_push(ioptab_size);
    lexical_push(TOKEN_SUB);
end sub;

sub pop_subroutine()
    lexical_pop_scope_type(TOKEN_SUB);

    var iop: [Iop] := emit(IOP_END, Iop@bytes);

    flush_iops(lexical_pop());
    current_namespace_id := lexical_pop();
    current_subroutine_id := lexical_pop();
end sub;

sub create_bootstrap_type(identifier_id: uint16, out type: [NumericThing])
    var type_id: uint16 := create_thing(THING_NUMERIC, NumericThing@bytes);
    name_symbol(identifier_id, type_id, current_namespace_id);
    type := find_thing(type_id) as [NumericThing];
end sub;

sub init_parser()
    current_namespace_id := 0;
    lexical_push(LEX_TOP);

    create_function(current_subroutine_id, current_namespace_id);

    var type: [NumericThing];
    type := create_bootstrap_type(TOKEN_INT8);
    type.thing_type := THING_SIGNED;
    type.width := 1;

    type := create_bootstrap_type(TOKEN_UINT8);
    type.thing_type := THING_UNSIGNED;
    type.width := 1;

    type := create_bootstrap_type(TOKEN_INT16);
    type.thing_type := THING_SIGNED;
    type.width := 2;

    type := create_bootstrap_type(TOKEN_UINT16);
    type.thing_type := THING_UNSIGNED;
    type.width := 2;

    type := create_bootstrap_type(TOKEN_INT32);
    type.thing_type := THING_SIGNED;
    type.width := 4;

    type := create_bootstrap_type(TOKEN_UINT32);
    type.thing_type := THING_UNSIGNED;
    type.width := 4;
end sub;

sub expect_token(expected: uint16)
    if current_token != expected then
        print("expected ");
        show_identifier(expected);
        print(" but got ");
        show_identifier(current_token);
        halt();
    end if;
    next_token();
end sub;

sub expect_identifier(out id: uint16)
    var thing: [Thing] := find_thing(current_token);
    if thing.thing_type != THING_IDENTIFIER then
        print("missing identifier");
        halt();
    end if;

    id := current_token;
    next_token();
end sub;

sub read_type(out type_id: uint16)
    var identifier_id: uint16 := expect_identifier();
    type_id := find_symbol(identifier_id);
    var type: [TypeThing] := find_thing(type_id) as [TypeThing];
    if (type.thing_type & THING_TYPE) != THING_TYPE then
        print("identifier 0x");
        print_hex_i16(identifier_id);
        print(" does not refer to a type");
    end if;
end sub;

sub do_sub()
    var old_namespace_id: uint16 := current_namespace_id;

    push_subroutine();
    expect_token(TOKEN_SUB);
    var id: uint16 := expect_identifier();
    create_function(current_subroutine_id, current_namespace_id);
    name_symbol(id, current_subroutine_id, old_namespace_id);

    expect_token(TOKEN_OPENPAREN);

    while current_token != TOKEN_CLOSEPAREN loop
        var inout: uint16 := TOKEN_IN;
        if (current_token == TOKEN_IN) | (current_token == TOKEN_OUT) | (current_token == TOKEN_INOUT) then
            inout := current_token;
            next_token();
        end if;

        id := expect_identifier();
        expect_token(TOKEN_COLON);
        var type_id: uint16 := read_type();

        var parameter_id: uint16 := create_thing(THING_PARAMETER, ParameterThing@bytes);
        name_symbol(id, parameter_id, current_namespace_id);
        var parameter: [ParameterThing] := find_thing(parameter_id) as [ParameterThing];
        parameter.inout := inout;
        parameter.type := type_id;

        if current_token != TOKEN_COMMA then
            break;
        end if;
        next_token();
    end loop;
    expect_token(TOKEN_CLOSEPAREN);
end sub;

sub do_var()
    expect_token(TOKEN_VAR);
    var id: uint16 := expect_identifier();
    expect_token(TOKEN_COLON);
    var type_id: uint16 := read_type();

    var variable_id: uint16 := create_thing(THING_VARIABLE, VariableThing@bytes);
    name_symbol(id, variable_id, current_namespace_id);
    var variable: [VariableThing] := find_thing(variable_id) as [VariableThing];
    variable.type := type_id;

    if current_token == TOKEN_ASSIGN then
        var thing_iop: [ThingIop] := emit(IOP_THING, ThingIop@bytes) as [ThingIop];
        thing_iop.thing_id := variable_id;

        next_token();
        do_expression();
        emit_simple(IOP_ASSIGN);
    end if;

    expect_token(TOKEN_SEMICOLON);
end sub;

sub do_end()
    expect_token(TOKEN_END);
    if current_token != lexical_peek() then
        print("can't close a 0x");
        print_hex_i16(lexical_peek());
        print(" with a 0x");
        print_hex_i16(current_token);
        halt();
    end if;
    if current_token == TOKEN_SUB then
        expect_token(TOKEN_SUB);
        pop_subroutine();
    else
        print("can't close 0x");
        print_hex_i16(current_token);
        print(" yet");
        halt();
    end if;
    expect_token(TOKEN_SEMICOLON);
end sub;

sub do_label()
    var id: uint16 := expect_identifier();
    expect_token(TOKEN_COLON);

    var label_id: uint16 := create_label();
    name_symbol(id, label_id, current_namespace_id);

    var iop: [LabelIop] := emit(IOP_LABEL, LabelIop@bytes) as [LabelIop];
    iop.label_id := label_id;
end sub;

sub do_assignment()
    do_expression();
    expect_token(TOKEN_ASSIGN);
    do_expression();
    expect_token(TOKEN_SEMICOLON);

    emit_simple(IOP_ASSIGN);
end sub;

sub do_goto()
    next_token();
    var id: uint16 := expect_identifier();
    var thing_iop: [ThingIop] := emit(IOP_THING, ThingIop@bytes) as [ThingIop];
    thing_iop.thing_id := id;
    expect_token(TOKEN_SEMICOLON);

    emit_simple(IOP_GOTO);
end sub;

load_thing_table("things.dat");
init_parser();
init_tokenreader("tokens.dat");

open_iopfile("iops.dat");
while current_token != 0 loop
    var thing: [Thing] := find_thing(current_token);
    if thing.thing_type == THING_IDENTIFIER then
        if peeked_token == TOKEN_COLON then
            do_label();
        elseif peeked_token == TOKEN_OPENPAREN then
            print("can't do function calls yet");
            halt();
        else
            do_assignment();
        end if;
    elseif current_token == TOKEN_SUB then
        do_sub();
    elseif current_token == TOKEN_VAR then
        do_var();
    elseif current_token == TOKEN_END then
        do_end();
    elseif current_token == TOKEN_GOTO then
        do_goto();
    else
        print("unknown token ");
        show_identifier(current_token);
        halt();
    end if;
end loop;
var iop: [Iop] := emit(IOP_END, Iop@bytes);
flush_iops(0);
close_iopfile();

print("thing table size: ");
print_i16(thing_table_top);
print_newline();
save_thing_table("things.dat");
