%{
	var uint32_type: [Symbol];
	var int32_type: [Symbol];
	var uint16_type: [Symbol];
	var int16_type: [Symbol];
	var uint8_type: [Symbol];
	var int8_type: [Symbol];
	var intptr_type: [Symbol];

	sub ArchAlignUp(value: Size, alignment: uint8): (newvalue: Size)
		newvalue := value;
	end sub;

	sub ArchGuessIntType(min: Arith, max: Arith): (symbol: [Symbol])
		if (min >= 0) and (max <= 255) then
			symbol := uint8_type;
		elseif (min >= -128) and (max <= 127) then
			symbol := int8_type;
		elseif (min >= 0) and (max <= 65535) then
			symbol := uint16_type;
		elseif (min >= -32768) and (max <= 32767) then
			symbol := int16_type;
		elseif (min >= 0) then
			symbol := uint32_type;
		else
			symbol := int32_type;
		end if;
	end sub;

	sub ArchInitVariable(symbol: [Symbol])
		var subr := symbol.vardata.subr;
		var offset := subr.workspace[0];
		symbol.vardata.offset := offset;
		subr.workspace[0] := offset + symbol.vardata.type.typedata.width;
	end sub;

	sub ArchInitMember(containing: [Symbol], member: [Symbol], position: Size)
		member.vardata.offset := position;
		position := position + member.vardata.type.typedata.width;
		if position > containing.typedata.width then
			containing.typedata.width := position;
		end if;
	end sub;

	sub E_labelref(labelid: uint16)
		E("x");
		E_u16(labelid);
	end sub;

	sub E_subref(subr: [Subroutine])
		if subr.externname != (0 as string) then
			E(subr.externname);
		else
			E("f");
			E_u16(subr.id);
		end if;
	end sub;

	sub E_symref(sym: [Symbol], off: Size)
		EmitByte('w');
		E_u16(sym.vardata.subr.id);
		EmitByte('+');
		E_u16(sym.vardata.offset + off);
	end sub;

	sub E_space()
		EmitByte(' ');
	end sub;

	sub E_comma()
		EmitByte(',');
	end sub;

	sub E_tab()
		EmitByte('\t');
	end sub;

	sub E_nl();
		EmitByte('\n');
	end sub;

	sub E_label(label: LabelRef)
		E_labelref(label);
		E(":\n");
	end sub;

	sub E_jump(insn: string, label: LabelRef)
		E_tab();
		E(insn);
		E_space();
		E_labelref(label);
		E_nl();
	end sub;

	sub E_call(subr: [Subroutine])
		E_tab();
		E("call ");
		E_subref(subr);
		E_nl();
	end sub;

	sub E_reg(reg: RegId)
		case reg is
			when REG_A: EmitByte('a');
			when REG_B: EmitByte('b');
			when REG_D: EmitByte('d');
			when REG_H: EmitByte('h');
			when REG_BC: EmitByte('b');
			when REG_DE: EmitByte('d');
			when REG_HL: EmitByte('h');
			when else:
				StartError();
				print("invalid register 0x");
				print_hex_i16(reg);
				EndError();
		end case;
	end sub;

	sub E_reglo(reg: RegId)
		case reg is
			when REG_A:  EmitByte('a');
			when REG_BC: EmitByte('c');
			when REG_DE: EmitByte('e');
			when REG_HL: EmitByte('l');
			when else:
				StartError();
				print("invalid reglo register 0x");
				print_hex_i16(reg);
				EndError();
		end case;
	end sub;

	sub E_movlo(src: RegId, dest: RegId)
		E_tab();
		E("mov ");
		E_reglo(dest);
		E_comma();
		E_reglo(src);
		E_nl();
	end sub;

	sub E_movhi(src: RegId, dest: RegId)
		E_tab();
		E("mov ");
		E_reg(dest);
		E_comma();
		E_reg(src);
		E_nl();
	end sub;

	sub E_mvi(reg: RegId, value: int32)
		E("\tmvi ");
		E_reg(reg);
		E_comma();
		E_u8(value as uint8);
		E_nl();
	end sub;

	sub E_alu(insn: string, rhs: RegId)
		E_tab();
		E(insn);
		E_space();
		E_reg(rhs);
		E_nl();
	end sub;

	sub E_alulo(insn: string, rhs: RegId)
		E_tab();
		E(insn);
		E_space();
		E_reglo(rhs);
		E_nl();
	end sub;

	sub E_alui(insn: string, value: int32)
		E_tab();
		E(insn);
		E_space();
		E_u8(value as uint8);
		E_nl();
	end sub;

	sub E_lxi(reg: RegId, value: int32);
		E("\tlxi ");
		E_reg(reg);
		E_comma();
		E_u16(value as uint16);
		E_nl();
	end sub;

	sub E_lxia(reg: RegId, sym: [Symbol], off: Size)
		E("\tlxi ");
		E_reg(reg);
		E_comma();
		E_symref(sym, off);
		E_nl();
	end sub;

	sub E_lda(sym: [Symbol], off: Size)
		E("\tlda ");
		E_symref(sym, off);
		E_nl();
	end sub;

	sub E_sta(sym: [Symbol], off: Size)
		E("\tsta ");
		E_symref(sym, off);
		E_nl();
	end sub;

	sub E_lhld(sym: [Symbol], off: Size)
		E("\tlhld ");
		E_symref(sym, off);
		E_nl();
	end sub;

	sub E_shld(sym: [Symbol], off: Size)
		E("\tshld ");
		E_symref(sym, off);
		E_nl();
	end sub;

	sub E_loadm(reg: RegId)
		E("\tmov ");
		E_reg(reg);
		E(",m\n");
	end sub;

	sub E_loadmlo(reg: RegId)
		E("\tmov ");
		E_reglo(reg);
		E(",m\n");
	end sub;

	sub E_storem(reg: RegId)
		E("\tmov m,");
		E_reg(reg);
		E_nl();
	end sub;

	sub E_storemlo(reg: RegId)
		E("\tmov m,");
		E_reglo(reg);
		E_nl();
	end sub;

	sub E_stax(ptr: RegId)
		E("\tstax ");
		E_reg(ptr);
		E_nl();
	end sub;

	sub E_ldax(ptr: RegId)
		E("\tldax ");
		E_reg(ptr);
		E_nl();
	end sub;

	sub E_stackreg(reg: RegId)
		if reg == REG_A then
			E("psw");
		else
			E_reg(reg);
		end if;
	end sub;

	sub E_inc(reg: RegId)
		E("\tinc ");
		E_reg(reg);
		E_nl();
	end sub;

	sub E_inx(reg: RegId)
		E("\tinx ");
		E_reg(reg);
		E_nl();
	end sub;

	sub E_dcx(reg: RegId)
		E("\tdcx ");
		E_reg(reg);
		E_nl();
	end sub;

	sub E_xchg()
		E("\txchg\n");
	end sub;

	sub E_pchl()
		E("\tpchl\n");
	end sub;

	sub E_cma()
		E("\tcma\n");
	end sub;

	sub E_dad(reg: RegId)
		E("\tdad ");
		E_reg(reg);
		E_nl();
	end sub;

	sub E_callhelper(name: string)
		E("\tcall ");
		E(name);
		E_nl();
	end sub;

	var stringid: uint16 := 0;

	sub E_string(data: string)
		var sid := stringid;
		stringid := stringid + 1;

		EmitterPushChunk();
		E_h16(current_subr.id);

		E("\tcseg\n");
		E("s");
		E_u16(sid);
		E(":\n\tdb ");

		loop
			var c := [data];
			if c == 0 then
				break;
			end if;
			data := data + 1;
			
			E_u8(c);
			E_comma();
		end loop;
		E("0\n");
		EmitterPopChunk('S');

		E("s");
		E_u16(sid);
	end sub;

	sub ArchEmitMove(src: RegId, dest: RegId)
		if src == 0 then
			E("\tpop ");
			E_stackreg(dest);
		elseif dest == 0 then
			E("\tpush ");
			E_stackreg(src);
		else
			sub mov()
				E("\tmov ");
			end sub;
			mov();
			E_reg(dest);
			E_comma();
			E_reg(src);

			if (src & (REG_HL|REG_BC|REG_DE)) != 0 then
				E_nl();
				mov();
				E_reglo(dest);
				E_comma();
				E_reglo(src);
			end if;
		end if;
		E_nl();
	end sub;
%}

register a b d h hl de bc;
register stk4 param;

regdata a compatible a|b|d|h;
regdata b uses bc compatible a|b|d|h;
regdata d uses de compatible a|b|d|h;
regdata h uses hl compatible a|b|d|h;
regdata bc uses bc compatible bc|de|hl;
regdata de uses de compatible bc|de|hl;
regdata hl uses hl compatible bc|de|hl;
regdata stk4 stacked;
regdata param stacked;

// --- Core things ----------------------------------------------------------

gen STARTFILE()
{
	EmitterPushChunk();
	E_h16(0);
	E("\tinclude \"rt/cpm/cowgol.inc\"\n");
	EmitterPopChunk('S');
}

gen ENDFILE()
{
	EmitterPushChunk();
	E_h16(0);
	E("\tinclude \"rt/cpm/tail.inc\"\n");
	EmitterPopChunk('S');
}

gen LABEL():b
{
	E_label($b.label);
}

gen JUMP():j
{
	E_jump("jmp", $j.label);
}

// --- Subroutines ----------------------------------------------------------

gen STARTSUB():s
{
	EmitterPushChunk();
	E_h16($s.subr.id);

	E("\n\n\t; ");
	E($s.subr.name);
	E_nl();

	E("\tcseg\n");
	E_subref($s.subr);
	E(":\n");

	var count := $s.subr.num_input_parameters;
    if count != 0 then
		ArchEmitMove(0, REG_BC);
		while count != 0 loop
			count := count - 1;
			var param := GetInputParameter($s.subr, count);

			case param.vardata.type.typedata.width is
				when 1:
					ArchEmitMove(0, REG_A);
					E_sta(param, 0);

				when 2:
					ArchEmitMove(0, REG_HL);
					E_shld(param, 0);

				when 4:
					ArchEmitMove(0, REG_HL);
					E_shld(param, 0);
					ArchEmitMove(0, REG_HL);
					E_shld(param, 2);
			end case;
		end loop;
		ArchEmitMove(REG_BC, 0);
	end if;
}

gen ENDSUB():s
{
	E("end_");
	E_subref($s.subr);
	E(":\n");

    if $s.subr.num_output_parameters != 0 then
		ArchEmitMove(0, REG_DE);
		var count: uint8 := 0;
		while count != $s.subr.num_output_parameters loop
			var param := GetOutputParameter($s.subr, count);

			case param.vardata.type.typedata.width is
				when 1:
					E_lda(param, 0);
					ArchEmitMove(REG_A, 0);

				when 2:
					E_lhld(param, 0);
					ArchEmitMove(REG_HL, 0);

				when 4:
					E_lhld(param, 2);
					ArchEmitMove(REG_HL, 0);
					E_lhld(param, 0);
					ArchEmitMove(REG_HL, 0);
			end case;

			count := count + 1;
		end loop;
		E_xchg();
		E_pchl();
	else
		E("\tret\n");
	end if;

	EmitterDeclareWorkspace($s.subr, 0, $s.subr.workspace[0]);
	EmitterPopChunk('S');
}

gen CALL():s
{
	E_call($s.subr);
}
	
gen a := CALLE1():s
{
	E_call($s.subr);
	ArchEmitMove(0, REG_A);
}

gen hl := CALLE2():s
{
	E_call($s.subr);
	ArchEmitMove(0, REG_HL);
}

gen PUSHARG1(a|b|d|h:lhs)
{
	ArchEmitMove($lhs, 0);
}
	
gen PUSHARG2(bc|de|hl:lhs)
{
	ArchEmitMove($lhs, 0);
}

gen PUSHARG4(stk4); // already stacked

gen POPARG1(hl) uses a
{
	ArchEmitMove(0, REG_A);
	E_storem(REG_A);
}

gen POPARG1(ADDRESS():a) uses a
{
	ArchEmitMove(0, REG_A);
	E_sta($a.sym, $a.off);
}

gen POPARG2(hl) uses de
{
	ArchEmitMove(0, REG_DE);
	E_storemlo(REG_DE);
	E_inx(REG_HL);
	E_storem(REG_DE);
}

gen POPARG2(ADDRESS():a) uses hl
{
	ArchEmitMove(0, REG_HL);
	E_shld($a.sym, $a.off);
}

gen POPARG4(hl) uses bc|de
{
	E_callhelper("store4");
}

gen RETURN()
{
	E("\tjmp end_");
	E_subref(current_subr);
	E("\n");
}

// --- Constants ------------------------------------------------------------

gen a|b|d|h := CONSTANT():rhs
{
	E_mvi($$, $rhs.value);
}

gen bc|de|hl := CONSTANT():rhs
{
	E_lxi($$, $rhs.value);
}

gen stk4 := CONSTANT():rhs uses hl
{
	E_lxi(REG_HL, $rhs.value >> 16);
	ArchEmitMove(REG_HL, 0);
	E_lxi(REG_HL, $rhs.value);
	ArchEmitMove(REG_HL, 0);
}

gen bc|de|hl := ADDRESS():a
{
	E_lxia($$, $a.sym, $a.off);
}

// --- 8-bit loads and stores -----------------------------------------------

gen a := LOAD1(ADDRESS():a)
{
	E_lda($a.sym, $a.off);
}

gen a := LOAD1(bc|de|hl:ptr)
{
	if $ptr == REG_HL then
		E_loadm(REG_A);
	else
		E_ldax($ptr);
	end if;
}

gen STORE1(a, ADDRESS():a)
{
	E_sta($a.sym, $a.off);
}

gen STORE1(a, bc|de|hl:ptr)
{
	if $ptr == REG_HL then
		E_storem(REG_A);
	else
		E_stax($ptr);
	end if;
}

// --- 16-bit loads and stores ----------------------------------------------

gen hl := LOAD2(ADDRESS():a)
{
	E_lhld($a.sym, $a.off);
}

gen bc|de := LOAD2(hl)
{
	E_loadmlo($$);
	E_inx(REG_HL);
	E_loadm($$);
}

gen STORE2(hl, ADDRESS():a)
{
	E_shld($a.sym, $a.off);
}

gen STORE2(bc|de:val, hl) uses a
{
	E_storemlo($val);
	E_inx(REG_HL);
	E_storem($val);
}

// --- 32-bit loads and stores ----------------------------------------------

gen stk4 := LOAD4(hl)
{
	E_callhelper("load4");
}

gen STORE4(stk4, hl)
{
	E_callhelper("store4");
}

// --- 8-bit arithmetic -----------------------------------------------------

gen a := ADD1(a, b|d|h:rhs)
		{ E_alu("add", $rhs); }

gen a := ADD1(a, CONSTANT(value==1))
		{ E_inc(REG_A); }

gen a := ADD1(a, CONSTANT():c)
		{ E_alui("adi", $c.value); }

gen a := SUB1(a, b|d|h:rhs)
		{ E_alu("sub", $rhs); }

gen a := SUB1(a, CONSTANT():c)
		{ E_alui("sbi", $c.value); }

gen a := MUL1(b, d)
		{ E_callhelper("mul1"); }

gen a := NOT1(a)
		{ E_cma(); }

gen a := NEG1(b|d|h:lhs)
{
	E_alu("xra", REG_A);
	E_alu("sub", $lhs);
}

gen a := OR1(a, b|d|h:lhs)
		{ E_alu("ora", $lhs); }

gen a := AND1(a, b|d|h:lhs)
		{ E_alu("ana", $lhs); }

gen a := EOR1(a, b|d|h:lhs)
		{ E_alu("xra", $lhs); }

gen b := DIVU1(b, d) uses a
		{ E_callhelper("dvrmu1"); }

gen a := REMU1(b, d)
		{ E_callhelper("dvrmu1"); }

gen b := DIVS1(b, d) uses a
		{ E_callhelper("dvrms1"); }

gen a := REMS1(b, d)
		{ E_callhelper("dvrms1"); }

gen a := RSHIFTU1(a, b) uses bc
		{ E_callhelper("lsr1"); }

gen a := LSHIFT1(a, b) uses bc
		{ E_callhelper("asl1"); }

// --- 16-bit arithmetic ----------------------------------------------------

gen hl|bc|de := ADD2($$, CONSTANT(value==1))
{
	E_inx($$);
}

gen hl|bc|de := ADD2($$, CONSTANT(value==2))
{
	E_inx($$);
	E_inx($$);
}

gen hl|bc|de := ADD2($$, CONSTANT(value==-1))
{
	E_dcx($$);
}

gen hl|bc|de := ADD2($$, CONSTANT(value==-2))
{
	E_dcx($$);
	E_dcx($$);
}

gen hl := ADD2(hl|bc|de:lhs, hl|bc|de:rhs)
{
	if ($lhs != REG_HL) and ($rhs != REG_HL) then
		if $rhs == REG_DE then
			E_xchg();
			$rhs := REG_HL;
		else
			if $lhs == REG_DE then
				E_xchg();
			else
				ArchEmitMove($lhs, REG_HL);
			end if;
			$lhs := REG_HL;
		end if;
	end if;

	if $lhs == REG_HL then
		E_dad($rhs);
	else
		E_dad($lhs);
	end if;
}

gen de := DIVU2(de, bc) uses a
		{ E_callhelper("dvrmu2"); }

gen hl := REMU2(de, bc) uses a
		{ E_callhelper("dvrmu2"); }

gen de := DIVS2(de, bc) uses a
		{ E_callhelper("dvrms2"); }

gen hl := REMS2(de, bc) uses a
		{ E_callhelper("dvrms2"); }

gen hl := MUL2(hl, de) uses a|bc
		{ E_callhelper("mul2"); }

%{
	sub logic2(lhs: RegId, rhs: RegId, dest: RegId, insn: string)
		E_movlo(lhs, REG_A);
		E_alulo(insn, rhs);
		E_movlo(REG_A, dest);
		E_movhi(lhs, REG_A);
		E_alu(insn, rhs);
		E_movhi(REG_A, dest);
	end sub;
%}

gen bc|de|hl := OR2(bc|de|hl:lhs, bc|de|hl:rhs) uses a
		{ logic2($lhs, $rhs, $$, "ora"); }

gen bc|de|hl := AND2(bc|de|hl:lhs, bc|de|hl:rhs) uses a
		{ logic2($lhs, $rhs, $$, "ana"); }

gen bc|de|hl := EOR2(bc|de|hl:lhs, bc|de|hl:rhs) uses a
		{ logic2($lhs, $rhs, $$, "xra"); }

gen bc|de|hl := NOT2(bc|de|hl:lhs) uses a
{
	E_movlo($lhs, REG_A);
	E_cma();
	E_movlo(REG_A, $$);
	E_movhi($lhs, REG_A);
	E_cma();
	E_movhi(REG_A, $$);
}

gen hl := RSHIFTU2(hl, b) uses a
		{ E_callhelper("lsr2"); }

gen hl := RSHIFTS2(hl, b) uses a
		{ E_callhelper("asr2"); }

gen hl := LSHIFT2(hl, b) uses a
		{ E_callhelper("asl2"); }

// --- 32-bit arithmetic ----------------------------------------------------

gen stk4 := ADD4(stk4, stk4) uses a|bc|de|hl
        { E_callhelper("add4"); }

gen stk4 := SUB4(stk4, stk4) uses a|bc|de|hl
        { E_callhelper("sub4"); }

gen stk4 := NEG4(stk4) uses a|bc|de|hl
        { E_callhelper("neg4"); }

gen stk4 := MUL4(stk4, stk4) uses a|bc|de|hl
        { E_callhelper("mul4"); }

gen stk4 := DIVU4(stk4, stk4) uses a|bc|de|hl
        { E_callhelper("divu4"); }

gen stk4 := REMU4(stk4, stk4) uses a|bc|de|hl
        { E_callhelper("remu4"); }

gen stk4 := DIVS4(stk4, stk4) uses a|bc|de|hl
        { E_callhelper("divs4"); }

gen stk4 := REMS4(stk4, stk4) uses a|bc|de|hl
        { E_callhelper("rems4"); }

gen stk4 := AND4(stk4, stk4) uses a|bc|de|hl
        { E_callhelper("and4"); }

gen stk4 := OR4(stk4, stk4) uses a|bc|de|hl
        { E_callhelper("or4"); }

gen stk4 := EOR4(stk4, stk4) uses a|bc|de|hl
        { E_callhelper("eor4"); }

gen stk4 := NOT4(stk4) uses a|bc|de|hl
        { E_callhelper("not4"); }

gen stk4 := LSHIFT4(stk4, b) uses a|de|hl
        { E_callhelper("asl4"); }

gen stk4 := RSHIFTU4(stk4, b) uses a|de|hl
        { E_callhelper("lsr4"); }

gen stk4 := RSHIFTS4(stk4, b) uses a|de|hl
        { E_callhelper("asr4"); }



// --- Conditionals ---------------------------------------------------------

%{
	sub E_jumps_with_fallthrough(trueinsn: string, falseinsn: string, node: [Node])
		if node.beqs0.truelabel != node.beqs0.fallthrough then
			E_jump(trueinsn, node.beqs0.truelabel);
		end if;
		if node.beqs0.falselabel != node.beqs0.fallthrough then
			E_jump(falseinsn, node.beqs0.falselabel);
		end if;
	end sub;

	sub bequ1(node: [Node], nota: RegId)
		E_alu("cmp", nota);
		E_jumps_with_fallthrough("jz", "jnz", node);
	end sub;

	sub bequ2(node: [Node])
		E_callhelper("cmpeq2");
		E_jumps_with_fallthrough("jz", "jnz", node);
	end sub;

	sub bequ4(node: [Node])
		E_callhelper("cmpu4");
		E_jumps_with_fallthrough("jz", "jnz", node);
	end sub;

	sub beqc(node: [Node], lhs: Arith, rhs: Arith)
		var label := node.beqs0.falselabel;
		if lhs == rhs then
			label := node.beqs0.truelabel;
		end if;
		if label != node.beqs0.fallthrough then
			E_jump("jmp", label);
		end if;
	end sub;
%}

gen BEQU0(CONSTANT():c1, CONSTANT():c2):b
{
	beqc(self.n[0], $c1.value, $c2.value);
}

gen BEQS0(CONSTANT():c1, CONSTANT():c2):b
{
	beqc(self.n[0], $c1.value, $c2.value);
}

gen BEQU1(b|d|h:nota, a):b
{
	bequ1(self.n[0], $nota);
}

gen BEQS1(b|d|h:nota, a):b
{
	bequ1(self.n[0], $nota);
}

gen BLTU1(b|d|h:nota, a):b
{
	E_alu("cmp", $nota);
	E_jumps_with_fallthrough("jc", "jnc", self.n[0]);
}

gen BEQU2(de, hl):a
{
	bequ2(self.n[0]);
}

gen BEQS2(de, hl):a
{
	bequ2(self.n[0]);
}

gen BLTU2(hl|bc|de:lhs, hl|bc|de:rhs):b uses a
{
	E_movlo($lhs, REG_A);
	E("\tsub ");
	E_reglo($rhs);
	E_nl();

	E_movhi($lhs, REG_A);
	E("\tsbb ");
	E_reg($rhs);
	E_nl();

	E_jumps_with_fallthrough("jc", "jnc", self.n[0]);
}

gen BEQU4(stk4:lhs, stk4:rhs) uses a|hl|bc|de
{
	bequ4(self.n[0]);
}

gen BEQS4(stk4:lhs, stk4:rhs) uses a|hl|bc|de
{
	bequ4(self.n[0]);
}

gen BLTU4(stk4:lhs, stk4:rhs):b uses a|hl|bc|de
{
	E_callhelper("cmpu4");
	E_jumps_with_fallthrough("jc", "jnc", self.n[0]);
}

gen BLTS4(stk4:lhs, stk4:rhs):b uses a|hl|bc|de
{
	E_callhelper("cmps4");
	E_jumps_with_fallthrough("jc", "jnc", self.n[0]);
}

// --- Casts ----------------------------------------------------------------

gen hl := CAST12(a, sext==0)
{
	E_movlo(REG_A, REG_HL);
	E_mvi(REG_HL, 0);
}

gen stk4 := CAST14(a:rhs, sext==0) uses hl
{
	E_lxi(REG_HL, 0);
	ArchEmitMove(REG_HL, 0);
	E("\tmov l, a\n");
	ArchEmitMove(REG_HL, 0);
}

gen a := CAST21(hl|bc|de:rhs)
{
	E_movlo($rhs, REG_A);
}

gen stk4 := CAST24(hl|de:rhs, sext==0) uses bc
{
	E_lxi(REG_BC, 0);
	ArchEmitMove(REG_BC, 0);
	ArchEmitMove(REG_HL, 0);
}

gen a := CAST41(stk4) uses hl
{
	ArchEmitMove(0, REG_HL);
	E("\tmov a, l\n");
	ArchEmitMove(0, REG_HL);
}

// --- Strings --------------------------------------------------------------

gen bc|de|hl := STRING():s
{
	E("\tlxi ");
	E_reg($$);
	E_comma();
	E_string($s.text);
	E_nl();
}

// --- Inline assembly ------------------------------------------------------

gen ASMSTART()
{
	E_tab();
}

gen ASMTEXT():t
{
	E($t.text);
	E_space();
}

gen ASMSYMBOL():s
{
	if $s.sym.kind == VAR then
		E_symref($s.sym, 0);
	else
		E_subref($s.sym.subr);
	end if;
	E_space();
}

gen ASMEND()
{
    E_nl();
}


