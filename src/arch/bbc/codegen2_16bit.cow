sub arch_gen_copy_word(iop: [BEIop])
    sub address_of()
        var candidates: uint8;
        if iop.dest.flags == EA_DEREF then
            candidates := REG_A;
        else
            candidates := REG_A|REG_X;
        end if;

        var location: uint8 := allocate_reg(candidates);
        ld_imm_adr_lo(location, &iop.left);
        save_value_with_index_or_offset(location, &iop.dest, 0);
        ld_imm_adr_hi(location, &iop.left);
        save_value_with_index_or_offset(location, &iop.dest, 1);
    end sub;

    check_wide_ea(&iop.left);
    check_wide_ea(&iop.right);
    if is_number_thing(iop.left.obj_id) != 0 then
        var value: int32 := get_value_of_number(iop.left.obj_id);
        var candidates: uint8;
        if iop.dest.flags == EA_DEREF then
            candidates := REG_A;
        else
            candidates := REG_A|REG_X;
        end if;

        var location: uint8 := find_or_load_int(value, candidates);
        save_value_with_index_or_offset(location, &iop.dest, 0);
        free_reg(location);
        location := find_or_load_int(value >> 8, candidates);
        save_value_with_index_or_offset(location, &iop.dest, 1);
    elseif is_string_thing(iop.left.obj_id) != 0 then
        address_of();
    elseif is_typed_thing(iop.left.obj_id) != 0 then
        if iop.left.flags == EA_LEA then
            address_of();
        else
            arch_gen_copy_wide(iop);
        end if;
    else
        print("don't know how to load ");
        print_ea(&iop.left);
        halt();
    end if;
end sub;

sub do_2op_helper(iop: [BEIop])
    if (iop.left.flags != EA_VALUE) or (iop.dest.flags != EA_VALUE) then
        print("unimplemented");
        halt();
    end if;

    check_wide_ea(&iop.left);
    check_wide_ea(&iop.dest);

    write_back_precious_values(REG_MASK);

    write_byte(0x20); # JSR abs
    write_address_iop(IOP_ADDRESS, find_bootstrap_symbol(TOKEN_LOAD4BYTES), 0);
    write_address_iop(IOP_ADDRESS, iop.left.obj_id, get_value_of_number(iop.left.numoff_id));
    write_address_iop(IOP_ADDRESS, iop.dest.obj_id, get_value_of_number(iop.dest.numoff_id));

    flush_cached_values(REG_MASK);
end sub;

sub do_3op_helper(iop: [BEIop])
    if (iop.left.flags != EA_VALUE) or (iop.right.flags != EA_VALUE)
        or (iop.dest.flags != EA_VALUE)
    then
        print("unimplemented");
        halt();
    end if;

    check_wide_ea(&iop.left);
    check_wide_ea(&iop.right);
    check_wide_ea(&iop.dest);

    write_back_precious_values(REG_MASK);

    write_byte(0x20); # JSR abs
    write_address_iop(IOP_ADDRESS, find_bootstrap_symbol(TOKEN_LOAD6BYTES), 0);
    write_address_iop(IOP_ADDRESS, iop.left.obj_id, get_value_of_number(iop.left.numoff_id));
    write_address_iop(IOP_ADDRESS, iop.right.obj_id, get_value_of_number(iop.right.numoff_id));
    write_address_iop(IOP_ADDRESS, iop.dest.obj_id, get_value_of_number(iop.dest.numoff_id));

    flush_cached_values(REG_MASK);
end sub;

sub arch_gen_lsl_word(iop: [BEIop])
    do_2op_helper(iop);

    find_or_load_fixed_value(&iop.right, REG_A);
    if is_number_thing(iop.right.obj_id) == 0 then
        write_byte(0x29); # AND imm
        write_byte(0x07);
    end if;
    write_byte(0x20); # JSR abs
    write_address_iop(IOP_ADDRESS, find_bootstrap_symbol(TOKEN_LSL16), 0);

    flush_cached_values(REG_MASK);
end sub;

sub arch_gen_lsr_word(iop: [BEIop])
    do_2op_helper(iop);

    find_or_load_fixed_value(&iop.right, REG_A);
    write_byte(0x20); # JSR abs
    write_address_iop(IOP_ADDRESS, find_bootstrap_symbol(TOKEN_LSR16), 0);

    flush_cached_values(REG_MASK);
end sub;

sub arch_gen_asr_word(iop: [BEIop])
    do_2op_helper(iop);

    find_or_load_fixed_value(&iop.right, REG_A);
    write_byte(0x20); # JSR abs
    write_address_iop(IOP_ADDRESS, find_bootstrap_symbol(TOKEN_ASR16), 0);

    flush_cached_values(REG_MASK);
end sub;

sub arch_gen_mul_word(iop: [BEIop])
    do_3op_helper(iop);

    write_byte(0x20); # JSR abs
    write_address_iop(IOP_ADDRESS, find_bootstrap_symbol(TOKEN_MUL16), 0);

    flush_cached_values(REG_MASK);
end sub;
