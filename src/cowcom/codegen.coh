const RULE_HAS_PREDICATES := 0x01;

record Register
	name: string;
	id: RegId;
	uses: RegId;
	compatible: RegId;
	is_stacked: uint8;
end record;

record Rule
	flags: uint8;
	compatible_producable_regs: RegId;
	producable_regs: RegId;
	uses_regs: RegId;
	consumable_regs: RegId[INSTRUCTION_TEMPLATE_DEPTH];
	matchbytes: uint8[INSTRUCTION_TEMPLATE_DEPTH];
	copyable_nodes: uint8;
	register_nodes: uint8;
end record;

record Instruction
	ruleid: uint8;
	producable_regs: RegId;
	produced_reg: RegId;
	input_regs: RegId;
	output_regs: RegId;
	n: [Node][INSTRUCTION_TEMPLATE_DEPTH];
	first_spill: [Regmove];
	first_reload: [Regmove];
	last_reload: [Regmove];
end record;

var instructions: Instruction[16];
var next_instruction: [Instruction];

var nodes: [Node][16];
var nodecount: uint8;

include ".obj/arch8080/inssel.coh";

# Free up the node tree routed in the parameter. This is more exciting than it
# should be because we don't have recursion.
sub Discard(node: [Node])
	var pending := node;
	while pending != (0 as [Node]) loop
		node := pending;
		pending := node.dlink;

		# Unlink and push any children.
		if node.left != (0 as [Node]) then
			node.left.dlink := pending;
			pending := node.left;
		end if;
		if node.right != (0 as [Node]) then
			node.right.dlink := pending;
			pending := node.right;
		end if;

		# Now free this node.
		print("discard ");
		print_hex_i32(node as intptr as uint32);
		print_nl();
		Free(node as [uint8]);
	end loop;
end sub;

sub PushNode(node: [Node])
	if nodecount == @sizeof nodes then
		SimpleError("node stack overflow");
	end if;
	nodes[nodecount] := node;
	nodecount := nodecount + 1;
end sub;

sub IsStackedRegister(regid: RegId): (result: uint8)
	result := 0;
	var reg := &registers[0];
	while reg != &registers[REGISTER_COUNT] loop
		if (reg.id & regid) != 0 then
			result := reg.is_stacked;
			return;
		end if;
		reg := @next reg;
	end loop;
end sub;

sub FindFirst(inreg: RegId): (outreg: RegId)
	outreg := 1;
	while outreg != 0 loop
		if (inreg & outreg) != 0 then
			return;
		end if;
		outreg := outreg << 1;
	end loop;
	SimpleError("failed to allocate register");
end sub;

sub CalculateBlockedRegisters(insn: [Instruction], last: [Instruction]): (blocked: RegId)
	blocked := 0;
	while insn <= last loop
		blocked := blocked | insn.input_regs | insn.output_regs;
		insn := @next insn;
	end loop;
end sub;

sub FindConflictingRegisters(inreg: RegId): (conflicting: RegId)
	conflicting := 0;
	var reg := &registers[0];
	while reg != &registers[REGISTER_COUNT] loop
		if (reg.id & inreg) != 0 then
			conflicting := conflicting | reg.uses;
		end if;
		reg := @next reg;
	end loop;
end sub;

sub BlockRegisters(insn: [Instruction], last: [Instruction], blocked: RegId)
	while insn <= last loop
		insn.input_regs := insn.input_regs | blocked;
		insn.output_regs := insn.output_regs | blocked;
		insn := @next insn;
	end loop;
end sub;

sub TemplateComparator(data: [uint8], template: [uint8]): (result: uint8)
	result := 0;

	var i: uint8 := INSTRUCTION_TEMPLATE_DEPTH;
	while i != 0 loop
		var d := [data];
		data := data + 1;
		var t := [template];
		template := template + 1;
		if (t != 0) and (d != t) then
			return;
		end if;

		i := i - 1;
	end loop;

	result := 1;
end sub;

sub Generate(rootnode: [Node])
	var i: uint8;

	MemZero(&instructions[0] as [uint8], @bytesof instructions);
	next_instruction := &instructions[0];
	nodecount := 0;

	PushNode(rootnode);
	while nodecount != 0 loop
		if next_instruction == &instructions[@sizeof instructions] then
			SimpleError("instruction queue overflow");
		end if;
		var producer := next_instruction;
		next_instruction := @next next_instruction;

		# Find the first matching rule for this instruction.

		nodecount := nodecount - 1;
		var node := nodes[nodecount];
		var matchbytes: uint8[INSTRUCTION_TEMPLATE_DEPTH];
		MemZero(&matchbytes[0] as [uint8], @bytesof matchbytes);
		var matchnodes: [Node][INSTRUCTION_TEMPLATE_DEPTH];
		MemZero(&matchnodes[0] as [uint8], @bytesof matchnodes);
		matchnodes[0] := node;
		PopulateMatchBuffer(producer, &matchnodes[0], &matchbytes[0]);

		var ruleid: uint8 := 0xff;
		var rule := @prev &codegen_rules[0];
		loop
			rule := @next rule;
			ruleid := ruleid + 1;

			if rule == &codegen_rules[INSTRUCTION_TEMPLATE_COUNT] then
				# Reach the end of the list of rules without matching anything.
				StartError();
				print("unmatched instruction: ");
				i := 0;
				while i != INSTRUCTION_TEMPLATE_DEPTH loop
					print_i8(matchbytes[i]);
					print_char(' ');
					i := i + 1;
				end loop;
				EndError();
			end if;

			if rule.compatible_producable_regs != 0 then
				# This rule produces a result, so fail if the result register
				# isn't compatible.
				if (node.desired_reg & rule.compatible_producable_regs) == 0 then
					continue;
				end if;
			else
				# This rule produces no result, so fail if we need one.
				if node.desired_reg != 0 then
					continue;
				end if;
			end if;

			if TemplateComparator(&matchbytes[0], &rule.matchbytes[0]) == 0 then
				# Fail if the tree doesn't match.
				continue;
			end if;

			if ((rule.flags & RULE_HAS_PREDICATES) != 0) 
					and (MatchPredicate(ruleid, &matchnodes[0]) != 0) then
				# This rule has a manual predicate and the manual predicate said no.
				continue;
			end if;

			# We have a matching rule!
			break;
		end loop;

		# We have found a rule for this instruction.

		producer.ruleid := ruleid;
		producer.producable_regs := rule.producable_regs;
		producer.output_regs := rule.uses_regs;

		# Copy child nodes into the current instruction and make sure they're
		# pushed for later instruction allocation.

		var copymask := rule.copyable_nodes;
		var regmask := rule.register_nodes;
		i := 0;
		while i != INSTRUCTION_TEMPLATE_DEPTH loop
			var n := matchnodes[i];
			if (copymask & 1) != 0 then
				producer.n[i] := n;
				if (regmask & 1) != 0 then
					PushNode(n);
					n.desired_reg := rule.consumable_regs[i];
					n.consumer := producer;
				end if;
			end if;
			copymask := copymask >> 1;
			regmask := regmask >> 1;
			i := i + 1;
		end loop;
		node.producer := producer;

		if producer.producable_regs != 0 then
			# The instruction has produced a register. For stackable registers,
			# stop now: we ignore them for register allocation.
			if IsStackedRegister(producer.producable_regs) == 0 then
				var consumer := node.consumer;
				var blocked := CalculateBlockedRegisters(@next consumer, @prev producer);
				var candidate := node.desired_reg & producer.producable_regs;

				if (candidate & ~(blocked | producer.output_regs | consumer.input_regs)) != 0 then
					# Good news --- we can allocate the ideal register for
					# both producer and consumer.

					candidate := FindFirst(candidate & ~(blocked | producer.output_regs | consumer.input_regs));
					node.produced_reg := candidate;
					producer.produced_reg := candidate;

					blocked := FindConflictingRegisters(candidate);
					BlockRegisters(@next consumer, @prev producer, blocked);
					producer.output_regs := producer.output_regs | blocked;
				else
					SimpleError("regalloc");
				end if;
			end if;
		end if;
	end loop;

	# We have a set of instructions for this expression; emit them.

	while next_instruction != &instructions[0] loop
		next_instruction := @prev next_instruction;
		EmitOneInstruction(next_instruction.ruleid, next_instruction);
	end loop;

	Discard(rootnode);
end sub;

