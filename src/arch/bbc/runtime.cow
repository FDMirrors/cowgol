sub osbyte(a: uint8, x: uint8, y: uint8)
    @bytes 0xAD, &a;            # LDA a
    @bytes 0xAE, &x;            # LDX x
    @bytes 0xAC, &y;            # LDY y
    @bytes 0x4C, 0xF4, 0xFF;    # JMP OSBYTE
end sub;

sub print(ptr: [int8])
    loop
        var c: int8 := ptr[0];
        if c == 0 then
            return;
        end if;
        print_char(c as uint8);
        ptr := ptr + 1;
    end loop;
end sub;

sub print_char(char: uint8)
    @bytes 0xAD, &char;        # LDA char
    @bytes 0x4C, 0xE3, 0xFF;   # JMP OSASCII
end sub;

sub print_newline()
    @bytes 0x4C, 0xE7, 0xFF;   # JMP abs
end sub;

sub print_i8(value: uint8)
end sub;

sub print_i16(value: uint16)
end sub;

sub print_i32(value: uint32)
end sub;

sub print_hex_i8(value: uint8)
end sub;

sub print_hex_i16(value: uint16)
end sub;

sub print_hex_i32(value: uint32)
end sub;

sub file_openin(filename: [int8]): (fd: uint8)
end sub;

sub file_openout(filename: [int8]): (fd: uint8)
end sub;

sub file_getblock(fd: uint8, ptr: [int8], length: uint16)
end sub;

sub file_putblock(fd: uint8, ptr: [int8], length: uint16)
end sub;

sub file_seek(fd: uint8, pos: uint32)
end sub;

sub file_ext(fd: uint8): (length: uint32)
end sub;

sub file_eof(fd: uint8): (eof: uint8)
end sub;

sub file_getchar(fd: uint8): (char: int8)
end sub;

sub file_close(fd: uint8)
end sub;

sub exit(status: uint8)
end sub;

var __params: uint16[3] @segment(0x81);

# Copies A parameters from the code immediately following this call into __params.
sub __loadbytes()
    var nextaddr: uint16 @segment(0x81);
    var maxcount: uint8 @segment(0x81);
    @bytes 0x85, >&maxcount;     # STA maxcount
    @bytes 0xA2, 0xFF;           # LDX #-1

    @bytes 0x68;                 # PLA
    @bytes 0x85, >&nextaddr+0;   # STA nextaddr+0
    @bytes 0x68;                 # PLA
    @bytes 0x85, >&nextaddr+1;   # STA nextaddr+1

    goto start;

again:
    @bytes 0xB1, >&nextaddr;     # LDA (nextaddr), Y
    @bytes 0x95, >&__params;     # STA __pointers, X

start:
    @bytes 0xE6, >&nextaddr+0;   # INC nextaddr+0
    @bytes 0xD0, 0x02;           # BNE $+2
    @bytes 0xE6, >&nextaddr+1;   # INC nextaddr+1

    @bytes 0xE8;                 # INX
    @bytes 0xE4, >&maxcount;     # CPX maxcount
    @bytes 0xD0, 0xF1;           # BNE again

    @bytes 0x6C, &nextaddr;      # JMP (nextaddr)
end sub;

sub __load4bytes()
    @bytes 0xA9, 0x04;           # LDA #4
    @bytes 0x4C, &__loadbytes;   # JMP __loadbytes (must be jump to avoid changing stack)
end sub;

sub __load6params()
    @bytes 0xA9, 0x06;           # LDA #6
    @bytes 0x4C, &__loadbytes;   # JMP __loadbytes (must be jump to avoid changing stack)
end sub;

#sub __add16()
#    @bytes 0x68;             # PLA
#    @bytes 0x85, >&lp;       # STA lp
#    @bytes 0x68;             # PLA
#    @bytes 0x85, >&lp+1;     # STA lp+1
#
#    @bytes 0xA9, 0x06;       # LDA #6
#    __copyparams();
#
#    # loop:
#    @bytes 0xA0, 0x00;       # LDY #0
#    @bytes 0xA2, 0x01;       # LDX #1
#    @bytes 0x18;             # CLC
#    # loop:
#    @bytes 0xB1, >&__pointers+0; # LDA (__pointers+0), Y
#    @bytes 0x71, >&__pointers+2; # ADC (__pointers+2), Y
#    @bytes 0x91, >&__pointers+4; # STA (__pointers+4), Y
#    @bytes 0xC8;             # INY
#    @bytes 0xCA;             # DEX
#    @bytes 0x10, 0xF6;       # BPL loop
#
#    @bytes 0x6C, &__nextaddr; # JMP (__nextaddr)
#end sub;

# On entry, A=shift amount, X=word size
sub __lsl()
    var count: uint8 @segment(0x81);
    var width: uint8 @segment(0x81);
    @bytes 0x85, >&count;        # STA count
    @bytes 0xCA;                 # DEX
    @bytes 0x86, >&width;        # STX width

    # Copy the value from src to dest, shifting once as we go.

shiftagain:
    @bytes 0xA0, 0x00;           # LDY #0
    @bytes 0xA6, >&width;        # LDX width
    @bytes 0x18;                 # CLC
    # loop:
    @bytes 0xB1, >&__params+0;   # LDA (__params+0), Y
    @bytes 0x2A;                 # ROL A
    @bytes 0x91, >&__params+2;   # STA (__params+2), Y
    @bytes 0xC8;                 # INY
    @bytes 0xCA;                 # DEX
    @bytes 0x10, 0xF7;           # BPL loop

    @bytes 0xC6, >&count;        # DEC count
    @bytes 0xF0, 0x0B;           # BEQ exit

    # We need to shift more, so we do it in-place in dest.

    @bytes 0xA5, >&__params+2;   # LDA __params+2
    @bytes 0x85, >&__params+0;   # STA __params+0
    @bytes 0xA5, >&__params+3;   # LDA __params+3
    @bytes 0x85, >&__params+1;   # STA __params+1
    goto shiftagain;
end sub;

sub __lsl16()
    @bytes 0xA2, 0x02;           # LDX #2
    @bytes 0x4C, &__lsl;         # JMP __lsl
end sub;

# On entry, A=shift amount, X=word size, Y=0xFF for signed or 0x00 for unsigned
sub __lsr_asr()
    var count: uint8 @segment(0x81);
    var width: uint8 @segment(0x81);
    var signed: uint8 @segment(0x81);
    @bytes 0x85, >&count;        # STA count
    @bytes 0xCA;                 # DEX
    @bytes 0x86, >&width;        # STX width
    @bytes 0x84, >&signed;       # STY signed

    # Copy the value from src to dest, shifting once as we go.

shiftagain:
    @bytes 0xA4, >&width;        # LDY width
    @bytes 0x18;                 # CLC

    # Prime the carry bit with the sign, so it propagates in if needed.
    @bytes 0xB1, >&__params+0;   # LDA (__params+0), Y
    @bytes 0x25, >&signed;       # AND signed
    @bytes 0x0A;                 # ASL A

    # loop:
    @bytes 0xB1, >&__params+0;   # LDA (__params+0), Y
    @bytes 0x6A;                 # ROR A
    @bytes 0x91, >&__params+2;   # STA (__params+2), Y
    @bytes 0x88;                 # DEY
    @bytes 0x10, 0xF8;           # BPL loop

    @bytes 0xC6, >&count;        # DEC count
    @bytes 0xF0, 0x0B;           # BEQ exit

    # We need to shift more, so we do it in-place in dest.

    @bytes 0xA5, >&__params+2;   # LDA __params+2
    @bytes 0x85, >&__params+0;   # STA __params+0
    @bytes 0xA5, >&__params+3;   # LDA __params+3
    @bytes 0x85, >&__params+1;   # STA __params+1
    goto shiftagain;
end sub;

sub __lsr16()
    @bytes 0xA2, 0x02;           # LDX #2 --- word width
    @bytes 0xA0, 0x00;           # LDY #0 --- unsigned
    @bytes 0x4C, &__lsr_asr;     # JMP __lsr
end sub;

sub __asr16()
    @bytes 0xA2, 0x02;           # LDX #2
    @bytes 0xA0, 0xFF;           # LDY #255 --- signed
    @bytes 0x4C, &__lsr_asr;     # JMP __asr
end sub;

# A/X -> A quotient, X remainder
sub __divmodu8()
    var num: uint8 @segment(0x81);
    var den: uint8 @segment(0x81);
    @bytes 0x85, >&num;          # STA num
    @bytes 0x86, >&den;          # STX den

    @bytes 0xA9, 0x00;           # LDA #0
    @bytes 0xA2, 0x08;           # LDX #8
    @bytes 0x06, >&num;          # ASL num

    # again:
    @bytes 0x2A;                 # ROL A
    @bytes 0xC5, >&den;          # CMP den
    @bytes 0x90, 0x02;           # BCC $+2
    @bytes 0xE5, >&den;          # SBC den
    @bytes 0x26, >&num;          # ROL num
    @bytes 0xCA;                 # DEX
    @bytes 0xD0, 0xF4;           # BNE again

    @bytes 0xAA;                 # TAX
    @bytes 0xA5, >&num;          # LDA num
end sub;

sub __mul8u(left: uint8, right: uint8): (result: uint8)
    @bytes 0xA9, 0x00; # LDA #0
    @bytes 0xF0, 0x07; # BEQ start

    # add:
    @bytes 0x18; # CLC
    @bytes 0x6D, &left; # ADC abs
    # loop:
    @bytes 0x0E, &left; # ASL abs
    # start:
    @bytes 0x4E, &right; # LSR abs
    @bytes 0xB0, 0xF4; # BCS add
    @bytes 0xD0, 0xF6; # BNE loop
    @bytes 0x8D, &result; # STA abs
end sub;

var LOMEM: [int8];
var HIMEM: [int8];
