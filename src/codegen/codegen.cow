sub try_copy(src: [EffectiveAddress], dest: [EffectiveAddress])
    if arch_gen_copy(src, dest) == 1 then
        return;
    end if;

    # When assigning a generic number to something, promote the number to the same type as
    # the thing being assigned to.
    if (src.flags & FLAG_NUMBER) != 0 then
        src.flags := dest.flags;
        if arch_gen_copy(src, dest) == 1 then
            return;
        end if;
    end if;

    print("cannot copy ");
    print_ea(src);
    print(" to ");
    print_ea(dest);
    halt();
end sub;

sub simplify_to(src: [StackSlot], dest: [StackSlot])
    if ((src.operator & IOP_TYPE_SIMPLE2OP) != 0)
            or (src.operator == IOP_ADDOP)
            or (src.operator == IOP_SUBOP)  then
        if arch_gen_alu2op(src.operator, &src.left, &src.right, &dest.left) == 0 then
            print("2op needs more simplification");
            halt();
        end if;
    elseif (src.operator & IOP_TYPE_SIMPLE1OP) != 0 then
        if arch_gen_alu1op(src.operator, &src.left, &dest.left) == 0 then
            print("1op needs more simplification");
            halt();
        end if;
    elseif src.operator == IOP_THING then
        try_copy(&src.left, &dest.left);
    else
        print("cannot simplify");
        halt();
    end if;
end sub;

sub simplify_slot(slot: [StackSlot])
    if slot.operator != IOP_THING then
        print("can't simplify yet");
        halt();
    end if;
end sub;

sub slot_to_variable(slot: [StackSlot]): (var_id: uint16)
    if (slot.operator == IOP_THING) and (slot.left.type == EA_VAR_PLUS_CONST)
            and (get_value_of_number(slot.left.offset_id) == 0) then
        var_id := slot.left.thing_id;
        return;
    end if;

    if slot.left.type_id == 0 then
        print("can't convert something with no type to a variable");
        halt();
    end if;

    print("todo");
    halt();
end sub;

sub simplify_all_slots_up_to(offset: int8)
    var top: int8 := stack_pos + offset;
    var index: int8 := 0;
    while index < top loop
        simplify_slot(&stack[index]);
        index := index + 1;
    end loop;
end sub;

sub compute_constant_alu2_value(op: uint8, left_id: uint16, right_id: uint16): (result_id: uint16)
    var left: int32 := get_value_of_number(left_id);
    var right: int32 := get_value_of_number(right_id);
    var result: int32;

    if op == IOP_ADDOP then
        result := left + right;
    elseif op == IOP_SUBOP then
        result := left - right;
    else
        print("can't compute this constant value yet");
    end if;

    result_id := add_number_by_value(result);
end sub;

sub global_stack_rules(): (matched: uint8)
    matched := 1;
    var right: [StackSlot] := peek_slot(-1);
    var left: [StackSlot] := peek_slot(-2);

    sub stack_must_be_empty()
        if stack_pos != 0 then
            print("stack not empty");
            halt();
        end if;
    end sub;

    sub push_thing()
        var iop: [ThingIop] := &queue[0] as [ThingIop];
        var thing: [TypedThing] := find_thing(iop.thing_id) as [TypedThing];
        var slot: [StackSlot] := push_new_slot();

        slot.operator := IOP_THING;
        slot.left.type_id := thing.type_id;
        var type: [TypeThing] := find_thing(slot.left.type_id) as [TypeThing];
        if thing.thing_type == THING_NUMBER then
            slot.left.flags := slot.left.flags | FLAG_NUMBER;
        elseif type.width == 1 then
            slot.left.flags := slot.left.flags | FLAG_WIDTH_1;
        elseif type.width == 2 then
            slot.left.flags := slot.left.flags | FLAG_WIDTH_2;
        elseif type.width == 4 then
            slot.left.flags := slot.left.flags | FLAG_WIDTH_4;
        else
            slot.left.flags := slot.left.flags | FLAG_WIDTH_BIG;
        end if;
        if type.thing_type == THING_SIGNED then
            slot.left.flags := slot.left.flags | FLAG_SIGNED;
        elseif type.thing_type == THING_POINTER then
            slot.left.flags := slot.left.flags | FLAG_POINTER;
        end if;

        if (thing.thing_type == THING_VARIABLE) or (thing.thing_type == THING_PARAMETER) then
            slot.left.type := EA_VAR_PLUS_CONST;
            slot.left.thing_id := iop.thing_id;
        elseif thing.thing_type == THING_NUMBER then
            slot.left.type := EA_NUMBER;
            slot.left.offset_id := iop.thing_id;
        else
            print("don't know how to push things of kind 0x");
            print_hex_i8(thing.thing_type);
            halt();
        end if;
    end sub;

    sub swap()
        var params: StackSlot[2];
        pop_slot(&params[1]);
        pop_slot(&params[0]);

        var slot: [StackSlot] := push_new_slot();
        copy_slot(&params[1], slot);
        slot := push_new_slot();
        copy_slot(&params[0], slot);
    end sub;

    sub push_simple2op()
        var params: StackSlot[2];
        pop_slot(&params[1]);
        pop_slot(&params[0]);
        simplify_slot(&params[0]);
        simplify_slot(&params[1]);

        var slot: [StackSlot] := push_new_slot();
        if (params[0].left.type == EA_NUMBER) and (params[1].left.type == EA_NUMBER) then
            slot.operator := IOP_THING;
            slot.left.type := EA_NUMBER;
            slot.left.flags := FLAG_NUMBER;
            slot.left.offset_id := compute_constant_alu2_value(
                queue[0].iop_kind, params[0].left.offset_id, params[1].left.offset_id);
        else
            slot.operator := queue[0].iop_kind;
            copy_ea(&params[0].left, &slot.left);
            copy_ea(&params[1].left, &slot.right);
        end if;
    end sub;

    sub push_simple1op()
        var params: StackSlot[1];
        pop_slot(&params[0]);
        simplify_slot(&params[0]);

        var slot: [StackSlot] := push_new_slot();
        slot.operator := queue[0].iop_kind;
        copy_ea(&params[0].left, &slot.left);
    end sub;

    sub assign()
        simplify_all_slots_up_to(-2); # all except assign params
        simplify_slot(left);
        simplify_to(right, left);
        discard_slots(2);
    end sub;

    sub assignto()
        simplify_all_slots_up_to(-2); # all except assign params
        simplify_slot(right);
        simplify_to(left, right);
        discard_slots(2);
    end sub;

    sub call()
        simplify_all_slots_up_to(0);
        var iop: [CallIop] := &queue[0] as [CallIop];
        arch_gen_call(iop.thing_id);
    end sub;

    sub load()
        var var_id: uint16 := slot_to_variable(right);
        discard_slots(1);
        var slot: [StackSlot] := push_new_slot();
        slot.operator := IOP_THING;
        slot.left.type := EA_PTR_PLUS_CONST;
        slot.left.flags := FLAG_WIDTH_2;
        slot.left.thing_id := var_id;
    end sub;

    if queue[0].iop_kind == IOP_RETURN then
        stack_must_be_empty();
        arch_gen_return();
        consume_iops(1);
        return;
    end if;

    if queue[0].iop_kind == IOP_CALL then
        call();
        consume_iops(1);
        return;
    end if;

    if queue[0].iop_kind == IOP_LABEL then
        stack_must_be_empty();
        arch_gen_label();
        write_iop(&queue[0] as [Iop]);
        consume_iops(1);
        return;
    end if;

    if queue[0].iop_kind == IOP_SWAP then
        swap();
        consume_iops(1);
        return;
    end if;

    if (queue[0].iop_kind == IOP_BYTES) or (queue[0].iop_kind == IOP_WORD) then
        stack_must_be_empty();
        write_iop(&queue[0] as [Iop]);
        consume_iops(1);
        return;
    end if;

    if queue[0].iop_kind == IOP_THING then
        push_thing();
        consume_iops(1);
        return;
    end if;

    if queue[0].iop_kind == IOP_LOAD then
        load();
        consume_iops(1);
        return;
    end if;

    if ((queue[0].iop_kind & IOP_TYPE_SIMPLE2OP) != 0)
            or (queue[0].iop_kind == IOP_ADDOP)
            or (queue[0].iop_kind == IOP_SUBOP)  then
        push_simple2op();
        consume_iops(1);
        return;
    end if;

    if (queue[0].iop_kind == IOP_ZEXTOP)
            and (right.operator == IOP_THING) and (right.left.type == EA_NUMBER) then
        consume_iops(1);
        return;
    end if;

    if ((queue[0].iop_kind & IOP_TYPE_SIMPLE1OP) != 0) then
        push_simple1op();
        consume_iops(1);
        return;
    end if;

    if queue[0].iop_kind == IOP_ASSIGN then
        assign();
        consume_iops(1);
        return;
    end if;

    if queue[0].iop_kind == IOP_ASSIGNTO then
        assignto();
        consume_iops(1);
        return;
    end if;

    matched := 0;
end sub;
