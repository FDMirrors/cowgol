%{
	#include "globals.h"
	#include "emitter.h"
	#include "midcodes.h"
	#include "compiler.h"
	#include "parser.h"
	#include <bsd/string.h>
	#include <ctype.h>

	#define IMPL
	#include "codegen.h"

	#define E emitter_printf
	static char asmbuffer[80];

	struct subarch
	{
		int id;
	};

	static int id = 1;
	static Symbol* uint32_type;
	static Symbol* int32_type;
	static Symbol* int16_type;
	static Symbol* uint16_type;
	static Symbol* int8_type;

	void arch_init_types(void)
	{
		uint32_type = make_number_type("uint32", 4, false);
		int32_type = make_number_type("int32", 4, true);
		uint16_type = make_number_type("uint16", 2, false);
		int16_type = make_number_type("int16", 2, true);
		uint8_type = make_number_type("uint8", 1, false);
		int8_type = make_number_type("int8", 1, true);

		intptr_type = uint32_type;
		add_alias(NULL, "intptr", intptr_type);
	}

	Symbol* arch_guess_int_type(uint32_t min, uint32_t max)
	{
		if ((min >= 0) && (max <= 255))
			return uint8_type;
		if ((min >= -128) && (max <= 127))
			return int8_type;
		if ((min >= 0) && (max <= 65535))
			return uint16_type;
		if ((min >= -32768) && (max <= 32767))
			return int16_type;
		if (min >= 0)
			return uint32_type;
		return int32_type;
	}

	void arch_init_subroutine(struct subroutine* sub)
	{
		sub->arch = calloc(1, sizeof(struct subarch));
		sub->arch->id = id++;
	}

	void arch_init_variable(struct symbol* var)
	{
		/* All variables get allocated from workspace 0. */
		var->u.var.offset = current_sub->workspace[0];
		current_sub->workspace[0] += var->u.var.type->u.type.width;
	}

	void arch_init_member(struct symbol* record, struct symbol* member)
	{
		member->u.var.offset = record->u.type.width;
		record->u.type.width += member->u.var.type->u.type.width;
	}

	static const char* regref(reg_t reg)
	{
		switch (reg)
		{
			case REG_EAX: return "%eax";
			case REG_EBX: return "%ebx";
			case REG_ECX: return "%ecx";
			case REG_EDX: return "%edx";
			case REG_ESI: return "%esi";
			case REG_EDI: return "%edi";
			case REG_AX: return "%ax";
			case REG_BX: return "%bx";
			case REG_CX: return "%cx";
			case REG_DX: return "%dx";
			case REG_SI: return "%si";
			case REG_DI: return "%di";
			case REG_AL: return "%al";
			case REG_BL: return "%bl";
			case REG_CL: return "%cl";
			case REG_DL: return "%dl";
			default: fatal("unknown register id 0x%x", reg);
		}
	}

	static const char* stkref(reg_t reg)
	{
		switch (reg)
		{
			case REG_EAX: return "%eax";
			case REG_EBX: return "%ebx";
			case REG_ECX: return "%ecx";
			case REG_EDX: return "%edx";
			case REG_ESI: return "%esi";
			case REG_EDI: return "%edi";
			case REG_AL: case REG_AX: return "%ax";
			case REG_BL: case REG_BX: return "%bx";
			case REG_CL: case REG_CX: return "%cx";
			case REG_DL: case REG_DX: return "%dx";
			case REG_SI: return "%si";
			case REG_DI: return "%di";
			default: fatal("unknown register id 0x%x", reg);
		}
	}

	static const char* byteregref(reg_t reg)
	{
		switch (reg)
		{
			case REG_AL: case REG_AX: case REG_EAX: return "%al";
			case REG_BL: case REG_BX: case REG_EBX: return "%bl";
			case REG_CL: case REG_CX: case REG_ECX: return "%cl";
			case REG_DL: case REG_DX: case REG_EDX: return "%dl";
			default: fatal("unknown register id 0x%x", reg);
		}
	}

	static const char* subref(Subroutine* sub)
	{
		if (sub->externname)
			return sub->externname;
		
		static char buffer[32];
		snprintf(buffer, sizeof(buffer), "f%d", sub->arch->id);
		return buffer;
	}

	static const char* symref(Symbol* sym, int32_t off)
	{
		static char buffer[32];
		snprintf(buffer, sizeof(buffer), "(w%d+%d)",
			sym->u.var.sub->arch->id,
			sym->u.var.offset + off);
		return buffer;
	}

	static const char* labelref(int label)
	{
		static char buffer[32];
		snprintf(buffer, sizeof(buffer), "x%d", label);
		return buffer;
	}

	/* Note! This is allowed to destroy the source register. */
	void arch_emit_move(reg_t src, reg_t dest)
	{
		if (!src)
			E("\tpop %s\n", stkref(dest));
		else if (!dest)
			E("\tpush %s\n", stkref(src));
		else
			E("\tmov %s, %s\n", regref(dest), regref(src));
	}

	void arch_emit_comment(const char* text, ...)
	{
		va_list ap;
		va_start(ap, text);
		emitter_printf("\t# ");
		emitter_vprintf(text, ap);
		emitter_printf("\n");
		va_end(ap);
	}
%}

register eax ebx ecx edx esi edi;
register ax bx cx dx si di;
register al ah bl bh cl ch dl dh;
register stk4 param;

regclass r8 := al|bl|cl|dl;
regclass r16 := ax|bx|cx|dx|si|di;
regclass r32 := eax|ebx|ecx|edx|esi|edi;
regclass ri := ebx|esi|edi;

regdata eax compatible r32;
regdata ebx compatible r32|ri;
regdata ecx compatible r32;
regdata edx compatible r32;
regdata esi compatible r32|ri;
regdata edi compatible r32|ri;
regdata ax compatible r16;
regdata bx compatible r16;
regdata cx compatible r16;
regdata dx compatible r16;
regdata si compatible r16;
regdata di compatible r16;
regdata al compatible r8;
regdata bl compatible r8;
regdata cl compatible r8;
regdata dl compatible r8;
regdata stk4 stacked;
regdata param stacked;

gen STARTFILE()
{
    emitter_open_chunk();
	E("\t.code32\n");
    emitter_close_chunk();
}

gen ENDFILE();

gen STARTSUB():s
{
    emitter_open_chunk();
    E("\n");
    E("# %s\n", $s.sub->name);
    E("\t.text\n");
    if ($s.sub->externname)
        E("\t.global %s\n", $s.sub->externname);
    E("\t.global %s\n", subref($s.sub));
    E("%s:\n", subref($s.sub));

    if ($s.sub->inputparameters != 0)
    {
        E("\tpopl %%eax\n");
        for (int i=$s.sub->inputparameters-1; i>=0; i--)
        {
			Symbol* param = get_input_parameters($s.sub);
			for (int j=0; j<i; j++)
				param = param->next;

			int w = param->u.var.type->u.type.width;
			switch (w)
			{
				case 1:
					E("\tpopw %%bx\n");
					E("\tmovb %%bl, %s\n", symref(param, 0));
					break;

				case 2:
				case 4:
				{
					const char* insn = "popw";
						insn = "popl";
					E("\t%s %s\n", insn, symref(param, 0));
					break;
				}
			}
        }
        E("\tpushl %%eax\n");
    }
}

gen ENDSUB():s
{
	E("end_%s:\n", subref($s.sub));
	if ($s.sub->outputparameters != 0)
	{
		E("\tpopl %%eax\n");

		for (int i=0; i<$s.sub->outputparameters; i++)
		{
			struct symbol* param = $s.sub->namespace.firstsymbol;
			for (int j=0; j<(i + $s.sub->inputparameters); j++)
				param = param->next;

			const char* insn = "pushw";
			if (param->u.var.type->u.type.width == 4)
				E("\t%s %s\n", insn, symref(param, 0));
		}

		E("\tjmp %%eax\n");
	}
	else
		E("\tret\n");

    E("\t.bss\n");
	E("w%d:\n", $s.sub->arch->id);
	if ($s.sub->workspace[0] != 0)
		E("\t.space %d\n", $s.sub->workspace[0]);
    emitter_close_chunk();
}

// --- Control flow ------------------------------------------------------

gen RETURN()
{
	E("\tjmp end_%s\n", subref(current_sub));
}

gen LABEL():b
{
	E("%s:\n", labelref($b.label));
}

gen JUMP():j
{
	E("\tjmp %s\n", labelref($j.label));
}

// --- Subroutines -------------------------------------------------------

// SETPARAM leaves the parameter on the top of the stack, where the
// code generator loses track of it.

gen param := END();

gen param := PUSHPARAM1(param, r8:val)
	{ E("\tpush %s\n", stkref($val)); }

gen param := PUSHPARAM2(param, r16:val)
	{ E("\tpush %s\n", stkref($val)); }

gen param := PUSHPARAM4(param, r32:val)
	{ E("\tpush %s\n", stkref($val)); }

%{
	static void call(Subroutine* sub)
	{
		if (sub->externname)
		{
			emitter_open_chunk();
			E("\t.extern %s\n", sub->externname);
			emitter_close_chunk();
		}

		arch_emit_comment("subroutine with %d input parameters", sub->inputparameters);
		E("\tcall %s\n", subref(sub));
	}

	static void calln(Subroutine* sub, reg_t reg)
	{
		call(sub);
		E("\tpop %s\n", regref(reg));
	}
%}

gen CALLS(param);

gen param := CALL0(param):c
	{ call($c.sub); }

gen r8 := CALL1(param):c
	{ calln($c.sub, $$); }

gen r16 := CALL2(param):c
	{ calln($c.sub, $$); }

gen r32 := CALL4(param):c
	{ calln($c.sub, $$); }

%{
	static void popparam(Symbol* sym, int32_t off)
	{
		const char* ins = NULL;
		switch (sym->u.var.type->u.type.width)
		{
			case 1: ins = "movb"; break;
			case 2: ins = "movw"; break;
			case 4: ins = "mov"; break;
			default: assert(false);
		}

		E("\tpop %eax\n");
		E("\t%s [%s], %eax\n", ins, symref(sym, off));
	}
%}

rewrite POPPARAM1(p, a) := POPPARAM4(p, a);
rewrite POPPARAM2(p, a) := POPPARAM4(p, a);

gen POPPARAM4(param, ADDRESS():a) uses eax
	{ popparam($a.sym, $a.off); }

gen param := POPPARAM4(param, ADDRESS():a) uses eax
	{ popparam($a.sym, $a.off); }

// --- Core conversions --------------------------------------------------

gen r8 := CONSTANT(): c
	{ E("\tmovb $0x%x, %s\n", $c.value & 0xff, regref($$)); }

gen r16 := CONSTANT():c
	{ E("\tmovw $0x%x, %s\n", $c.value & 0xffff, regref($$)); }

gen r32 := CONSTANT():c
	{ E("\tmov $0x%x, %s\n", $c.value, regref($$)); }

gen r32 := ADDRESS():a
	{ E("\tlea %s, %s\n", symref($a.sym, $a.off), regref($$)); }

// --- Loads and stores --------------------------------------------------

gen r8 := LOAD1(r32:lhs)
	{ E("\tmovb (%s), %s\n", regref($lhs), regref($$)); }
	
gen r8 := LOAD1(ADDRESS():a)
	{ E("\tmovb %s, %s\n", symref($a.sym, $a.off), regref($$)); }
	
gen r16 := LOAD2(r32:lhs)
	{ E("\tmovw (%s), %s\n", regref($lhs), regref($$)); }

gen r16 := LOAD2(ADDRESS():a)
	{ E("\tmovw %s, %s\n", symref($a.sym, $a.off), regref($$)); }
	
gen r32 := LOAD4(r32:lhs)
	{ E("\tmov (%s), %s\n", regref($lhs), regref($$)); }

gen r32 := LOAD4(ADDRESS():a)
	{ E("\tmov %s, %s\n", symref($a.sym, $a.off), regref($$)); }
	
gen STORE1(r8:val, r32:addr)
	{ E("\tmovb %s, (%s)\n", regref($val), regref($addr)); }

gen STORE1(r8:val, ADDRESS():a)
	{ E("\tmovb %s, %s\n", regref($val), symref($a.sym, $a.off)); }

gen STORE2(r16:val, r32:addr)
	{ E("\tmovw %s, (%s)\n", regref($val), regref($addr)); }

gen STORE2(r16:val, ADDRESS():a)
	{ E("\tmovw %s, %s\n", regref($val), symref($a.sym, $a.off)); }

gen STORE4(r32:val, r32:addr)
	{ E("\tmov %s, (%s)\n", regref($val), regref($addr)); }

gen STORE4(r32:val, ADDRESS():a)
	{ E("\tmov %s, %s\n", regref($val), symref($a.sym, $a.off)); }

// --- Casts ----------------------------------------------------------------

gen r8 := CAST21(r16:val)
	{ E("\tmovb %s, %s\n", byteregref($val), regref($$)); }

gen r8 := CAST41(r32:val)
	{ E("\tmovb %s, %s\n", byteregref($val), regref($$)); }

// --- 8-bit arithmetic -----------------------------------------------------

gen r8 := ADD1(r8:lhs, $$:rhs)
	{ E("\taddb %s, %s\n", regref($lhs), regref($$)); }

gen r8 := ADD1($$, CONSTANT():c)
	{ E("\taddb $0x%x, %s\n", $c.value & 0xff, regref($$)); }

gen r8 := ADD1($$, CONSTANT(value==1))
	{ E("\tincb %s\n", regref($$)); }
	
gen r8 := ADD1($$, CONSTANT(value==-1))
	{ E("\tdecb %s\n", regref($$)); }

gen r8 := SUB1($$:lhs, r8:rhs)
	{ E("\tsubb %s, %s\n", regref($rhs), regref($$)); }

gen r8 := SUB1($$, CONSTANT():c)
	{ E("\tsubb $0x%x, %s\n", $c.value & 0xff, regref($$)); }

gen r8 := NEG1($$:val)
	{ E("\tnegb %s\n", regref($$)); }

gen r8 := LSHIFT1($$:lhs, cl:rhs)
	{ E("\tshlb %s, %s\n", regref($rhs), regref($$)); }

gen r8 := RSHIFTU1($$:lhs, cl:rhs)
	{ E("\tshrb %s, %s\n", regref($rhs), regref($$)); }

// --- 16-bit arithmetic ----------------------------------------------------

gen r16 := ADD2(r16:lhs, $$:rhs)
	{ E("\taddw %s, %s\n", regref($lhs), regref($$)); }

gen r16 := ADD2($$, CONSTANT():c)
	{ E("\taddw $0x%x, %s\n", $c.value & 0xffff, regref($$)); }

gen r16 := ADD2($$, CONSTANT(value==1))
	{ E("\tincw %s\n", regref($$)); }
	
gen r16 := ADD2($$, CONSTANT(value==-1))
	{ E("\tdecw %s\n", regref($$)); }

gen r16 := SUB2($$:lhs, r16:rhs)
	{ E("\tsubw %s, %s\n", regref($rhs), regref($$)); }

gen r16 := SUB2($$, CONSTANT():c)
	{ E("\tsubw $0x%x, %s\n", $c.value & 0xffff, regref($$)); }

gen r16 := NEG2($$:val)
	{ E("\tnegw %s\n", regref($$)); }

gen r16 := RSHIFTU2($$:lhs, cl:rhs)
	{ E("\tshrw %s, %s\n", regref($rhs), regref($$)); }

// --- 32-bit arithmetic ----------------------------------------------------

gen r32 := ADD4(r32:lhs, $$:rhs)
	{ E("\taddl %s, %s\n", regref($lhs), regref($$)); }

gen r32 := ADD4($$, CONSTANT():c)
	{ E("\taddl $0x%x, %s\n", $c.value, regref($$)); }

gen r32 := ADD4($$, CONSTANT(value==1))
	{ E("\tincl %s\n", regref($$)); }
	
gen r32 := ADD4($$, CONSTANT(value==-1))
	{ E("\tdecl %s\n", regref($$)); }

gen r32 := SUB4($$:lhs, r32:rhs)
	{ E("\tsubl %s, %s\n", regref($rhs), regref($$)); }

gen r32 := SUB4($$, CONSTANT():c)
	{ E("\tsubl $0x%x, %s\n", $c.value, regref($$)); }

gen r32 := NEG4($$:val)
	{ E("\tnegl %s\n", regref($$)); }

gen r32 := RSHIFTU4($$:lhs, cl:rhs)
	{ E("\tshrl %s, %s\n", regref($rhs), regref($$)); }

// --- Branches -------------------------------------------------------------

%{
	static void cmp(const char* insn, const char* trueop,
		int truelabel, int falselabel, reg_t lhs, reg_t rhs)
	{
		E("\t%s %s, %s\n", insn, regref(lhs), regref(rhs));
		E("\t%s %s\n", trueop, labelref(truelabel));
		E("\tjmp %s\n", labelref(falselabel));
	}
%}

gen BEQU1(r8:lhs, r8:rhs):b
	{ cmp("cmpb", "je", $b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BEQS1(r8:lhs, r8:rhs):b
	{ cmp("cmpb", "je", $b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BLTU1(r8:lhs, r8:rhs):b
	{ cmp("cmpb", "jb", $b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BEQU2(r16:lhs, r16:rhs):b
	{ cmp("cmpw", "je", $b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BEQS2(r16:lhs, r16:rhs):b
	{ cmp("cmpw", "je", $b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BEQU4(r32:lhs, r32:rhs):b
	{ cmp("cmpl", "je", $b.truelabel, $b.falselabel, $lhs, $rhs); }

gen BEQS4(r32:lhs, r32:rhs):b
	{ cmp("cmpl", "je", $b.truelabel, $b.falselabel, $lhs, $rhs); }

// --- Inline assembly ------------------------------------------------------

gen ASMSTART()
{
    asmbuffer[0] = '\0';
}

gen ASMTEXT():t
{
    strlcat(asmbuffer, $t.text, sizeof(asmbuffer));
    strlcat(asmbuffer, " ", sizeof(asmbuffer));
}

gen ASMSYMBOL():s
{
	if ($s.sym->kind == VAR)
		strlcat(asmbuffer, symref($s.sym, 0), sizeof(asmbuffer));
	else
		strlcat(asmbuffer, subref($s.sym->u.sub), sizeof(asmbuffer));
    strlcat(asmbuffer, " ", sizeof(asmbuffer));
}

gen ASMEND()
{
    E("\t%s\n", asmbuffer);
}

// --- Strings -----------------------------------------------------------

gen r32 := STRING():s
{
    int sid = id++;
    emitter_open_chunk();
    E("\t.data 1\n");
    E("s%d:\n", sid);
    E("\t.byte ");
    bool start = true;
	const char* s = $s.text;
    for (;;)
    {
        char c = *s++;
        if (!c)
            break;
		if (!start)
            E(", ");
		E("0x%02x", c);
        start = false;
    }
    if (!start)
        E(", ");
    E("0\n");
    emitter_close_chunk();

	E("\tlea s%d, %s\n", sid, regref($$));
}
