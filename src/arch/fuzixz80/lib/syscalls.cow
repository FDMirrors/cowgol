sub open(path: [int8], flags: uint16, mode: uint16): (fd: int8)
	@bytes 0x2a, &mode; # ld hl, (mode)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &flags; # ld hl, (flags)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &path; # ld hl, (path)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 1; # ld l, #1
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &fd; # ld (fd), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub close(fd: int8): (status: int8)
	@bytes 0xaf; # xor a
	@bytes 0x2a, &fd; # ld hl, (fd)
	@bytes 0x67; # ld h, a
	@bytes 0xe5; # push hl
	@bytes 0x2e, 2; # ld l, #2
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub rename(oldpath: [int8], newpath: [int8]): (status: int8)
	@bytes 0x2a, &newpath; # ld hl, (newpath)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &oldpath; # ld hl, (oldpath)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 3; # ld l, #3
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub mknod(pathname: [int8], mode: uint16, dev: uint16): (status: int8)
	@bytes 0x2a, &dev; # ld hl, (dev)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &mode; # ld hl, (mode)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &pathname; # ld hl, (pathname)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 4; # ld l, #4
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub link(oldpath: [int8], newpath: [int8]): (status: int8)
	@bytes 0x2a, &newpath; # ld hl, (newpath)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &oldpath; # ld hl, (oldpath)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 5; # ld l, #5
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub unlink(path: [int8]): (status: int8)
	@bytes 0x2a, &path; # ld hl, (path)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 6; # ld l, #6
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub read(fd: int8, buf: [int8], countin: uint16): (countout: int16)
	@bytes 0xaf; # xor a
	@bytes 0x2a, &countin; # ld hl, (countin)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &buf; # ld hl, (buf)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &fd; # ld hl, (fd)
	@bytes 0x67; # ld h, a
	@bytes 0xe5; # push hl
	@bytes 0x2e, 7; # ld l, #7
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x22, &countout; # ld (countout), hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub write(fd: int8, buf: [int8], countin: uint16): (countout: int16)
	@bytes 0xaf; # xor a
	@bytes 0x2a, &countin; # ld hl, (countin)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &buf; # ld hl, (buf)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &fd; # ld hl, (fd)
	@bytes 0x67; # ld h, a
	@bytes 0xe5; # push hl
	@bytes 0x2e, 8; # ld l, #8
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x22, &countout; # ld (countout), hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub _lseek(fd: int8, offset: [uint32], mode: uint16): (status: int8)
	@bytes 0xaf; # xor a
	@bytes 0x2a, &mode; # ld hl, (mode)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &offset; # ld hl, (offset)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &fd; # ld hl, (fd)
	@bytes 0x67; # ld h, a
	@bytes 0xe5; # push hl
	@bytes 0x2e, 9; # ld l, #9
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub chdir(path: [int8]): (status: int8)
	@bytes 0x2a, &path; # ld hl, (path)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 10; # ld l, #10
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub sync()
	@bytes 0xaf; # xor a
	@bytes 0x2e, 11; # ld l, #11
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0xe1; # pop hl
end sub;

sub access(path: [int8], mode: uint16): (status: int8)
	@bytes 0x2a, &mode; # ld hl, (mode)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &path; # ld hl, (path)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 12; # ld l, #12
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub chmod(path: [int8], mode: uint16): (status: int8)
	@bytes 0x2a, &mode; # ld hl, (mode)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &path; # ld hl, (path)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 13; # ld l, #13
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub chown(path: [int8], owner: uint16, group: uint16): (status: int8)
	@bytes 0x2a, &group; # ld hl, (group)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &owner; # ld hl, (owner)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &path; # ld hl, (path)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 14; # ld l, #14
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub stat(path: [int8], s: [int8]): (status: int8)
	@bytes 0x2a, &s; # ld hl, (s)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &path; # ld hl, (path)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 15; # ld l, #15
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub fstat(fd: int8, s: [int8]): (status: int8)
	@bytes 0xaf; # xor a
	@bytes 0x2a, &s; # ld hl, (s)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &fd; # ld hl, (fd)
	@bytes 0x67; # ld h, a
	@bytes 0xe5; # push hl
	@bytes 0x2e, 16; # ld l, #16
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub dup(oldfd: int8): (newfs: int8)
	@bytes 0xaf; # xor a
	@bytes 0x2a, &oldfd; # ld hl, (oldfd)
	@bytes 0x67; # ld h, a
	@bytes 0xe5; # push hl
	@bytes 0x2e, 17; # ld l, #17
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &newfs; # ld (newfs), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub getpid(): (pid: uint16)
	@bytes 0xaf; # xor a
	@bytes 0x2e, 18; # ld l, #18
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x22, &pid; # ld (pid), hl
	@bytes 0xe1; # pop hl
end sub;

sub getppid(): (pid: uint16)
	@bytes 0xaf; # xor a
	@bytes 0x2e, 19; # ld l, #19
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x22, &pid; # ld (pid), hl
	@bytes 0xe1; # pop hl
end sub;

sub getuid(): (uid: uint16)
	@bytes 0xaf; # xor a
	@bytes 0x2e, 20; # ld l, #20
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x22, &uid; # ld (uid), hl
	@bytes 0xe1; # pop hl
end sub;

sub umask(newmode: uint16): (oldmode: uint16)
	@bytes 0x2a, &newmode; # ld hl, (newmode)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 21; # ld l, #21
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x22, &oldmode; # ld (oldmode), hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub getfsys(dev: uint16, fs: [int8]): (status: int8)
	@bytes 0x2a, &fs; # ld hl, (fs)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &dev; # ld hl, (dev)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 22; # ld l, #22
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub execve(filename: [int8], argv: [[int8]], envp: [[int8]]): (status: int8)
	@bytes 0x2a, &envp; # ld hl, (envp)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &argv; # ld hl, (argv)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &filename; # ld hl, (filename)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 23; # ld l, #23
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub getdirent(fd: int8, buf: [int8], len: uint16): (status: int8)
	@bytes 0xaf; # xor a
	@bytes 0x2a, &len; # ld hl, (len)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &buf; # ld hl, (buf)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &fd; # ld hl, (fd)
	@bytes 0x67; # ld h, a
	@bytes 0xe5; # push hl
	@bytes 0x2e, 24; # ld l, #24
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub setuid(uid: uint16): (status: int8)
	@bytes 0x2a, &uid; # ld hl, (uid)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 25; # ld l, #25
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub setgid(gid: uint16): (status: int8)
	@bytes 0x2a, &gid; # ld hl, (gid)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 26; # ld l, #26
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub time(t: [int8], clock: uint16): (status: int8)
	@bytes 0x2a, &clock; # ld hl, (clock)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &t; # ld hl, (t)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 27; # ld l, #27
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub stime(t: [int8]): (status: int8)
	@bytes 0x2a, &t; # ld hl, (t)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 28; # ld l, #28
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub ioctl(fd: int8, request: uint16, argp: [int8]): (result: uint16)
	@bytes 0xaf; # xor a
	@bytes 0x2a, &argp; # ld hl, (argp)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &request; # ld hl, (request)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &fd; # ld hl, (fd)
	@bytes 0x67; # ld h, a
	@bytes 0xe5; # push hl
	@bytes 0x2e, 29; # ld l, #29
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x22, &result; # ld (result), hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub brk(addr: [int8]): (result: int8)
	@bytes 0x2a, &addr; # ld hl, (addr)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 30; # ld l, #30
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &result; # ld (result), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub sbrk(delta: int16)
	@bytes 0x2a, &delta; # ld hl, (delta)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 31; # ld l, #31
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub _fork(flags: uint16, addr: [int8]): (pid: uint16)
	@bytes 0x2a, &addr; # ld hl, (addr)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &flags; # ld hl, (flags)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 32; # ld l, #32
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x22, &pid; # ld (pid), hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub mount(dev: [int8], path: [int8], flags: uint16): (status: int8)
	@bytes 0x2a, &flags; # ld hl, (flags)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &path; # ld hl, (path)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &dev; # ld hl, (dev)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 33; # ld l, #33
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub _umount(dev: [int8], flags: uint16): (status: int8)
	@bytes 0x2a, &flags; # ld hl, (flags)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &dev; # ld hl, (dev)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 34; # ld l, #34
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub signal(signum: uint8, newhandler: uint16): (oldhandler: uint16)
	@bytes 0x2a, &newhandler; # ld hl, (newhandler)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &signum; # ld hl, (signum)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 35; # ld l, #35
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x22, &oldhandler; # ld (oldhandler), hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub dup2(newfd: int8): (oldfd: int8)
	@bytes 0xaf; # xor a
	@bytes 0x2a, &newfd; # ld hl, (newfd)
	@bytes 0x67; # ld h, a
	@bytes 0xe5; # push hl
	@bytes 0x2e, 36; # ld l, #36
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &oldfd; # ld (oldfd), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub pause(dsecs: uint16): (status: int8)
	@bytes 0x2a, &dsecs; # ld hl, (dsecs)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 37; # ld l, #37
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub alarm(newalarm: uint16): (oldalarm: uint16)
	@bytes 0x2a, &newalarm; # ld hl, (newalarm)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 38; # ld l, #38
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x22, &oldalarm; # ld (oldalarm), hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub kill(pid: uint16, sig: int8): (status: int8)
	@bytes 0xaf; # xor a
	@bytes 0x2a, &sig; # ld hl, (sig)
	@bytes 0x67; # ld h, a
	@bytes 0xe5; # push hl
	@bytes 0x2a, &pid; # ld hl, (pid)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 39; # ld l, #39
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub pipe(pipefds: [int16]): (status: int8)
	@bytes 0x2a, &pipefds; # ld hl, (pipefds)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 40; # ld l, #40
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub getgid(): (gid: uint16)
	@bytes 0xaf; # xor a
	@bytes 0x2e, 41; # ld l, #41
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x22, &gid; # ld (gid), hl
	@bytes 0xe1; # pop hl
end sub;

sub _times(tms: [int8]): (status: int8)
	@bytes 0x2a, &tms; # ld hl, (tms)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 42; # ld l, #42
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub utime(file: [int8], ktime: [int8]): (status: int8)
	@bytes 0x2a, &ktime; # ld hl, (ktime)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &file; # ld hl, (file)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 43; # ld l, #43
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub geteuid(): (uid: uint16)
	@bytes 0xaf; # xor a
	@bytes 0x2e, 44; # ld l, #44
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x22, &uid; # ld (uid), hl
	@bytes 0xe1; # pop hl
end sub;

sub getegid(): (gid: uint16)
	@bytes 0xaf; # xor a
	@bytes 0x2e, 45; # ld l, #45
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x22, &gid; # ld (gid), hl
	@bytes 0xe1; # pop hl
end sub;

sub chroot(path: [int8]): (status: int8)
	@bytes 0x2a, &path; # ld hl, (path)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 46; # ld l, #46
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub fcntl(cmd: uint16, arg: uint16): (fd: int8)
	@bytes 0x2a, &arg; # ld hl, (arg)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &cmd; # ld hl, (cmd)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 47; # ld l, #47
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &fd; # ld (fd), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub fchdir(fd: int8): (status: int8)
	@bytes 0xaf; # xor a
	@bytes 0x2a, &fd; # ld hl, (fd)
	@bytes 0x67; # ld h, a
	@bytes 0xe5; # push hl
	@bytes 0x2e, 48; # ld l, #48
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub fchmod(fd: int8, mode: uint16): (status: int8)
	@bytes 0xaf; # xor a
	@bytes 0x2a, &mode; # ld hl, (mode)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &fd; # ld hl, (fd)
	@bytes 0x67; # ld h, a
	@bytes 0xe5; # push hl
	@bytes 0x2e, 49; # ld l, #49
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub fchown(fd: int8, owner: uint16, group: uint16): (status: int8)
	@bytes 0xaf; # xor a
	@bytes 0x2a, &group; # ld hl, (group)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &owner; # ld hl, (owner)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &fd; # ld hl, (fd)
	@bytes 0x67; # ld h, a
	@bytes 0xe5; # push hl
	@bytes 0x2e, 50; # ld l, #50
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub mkdir(path: [int8], mode: uint16): (status: int8)
	@bytes 0x2a, &mode; # ld hl, (mode)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &path; # ld hl, (path)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 51; # ld l, #51
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub rmdir(path: [int8]): (status: int8)
	@bytes 0x2a, &path; # ld hl, (path)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 52; # ld l, #52
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub setpgrp(): (status: int8)
	@bytes 0xaf; # xor a
	@bytes 0x2e, 53; # ld l, #53
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
end sub;

sub uname(): (uzib: [int8])
	@bytes 0xaf; # xor a
	@bytes 0x2e, 54; # ld l, #54
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x22, &uzib; # ld (uzib), hl
	@bytes 0xe1; # pop hl
end sub;

sub waitpid(pid: int16, wstatus: [int16], options: uint16): (result: int16)
	@bytes 0x2a, &options; # ld hl, (options)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &wstatus; # ld hl, (wstatus)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &pid; # ld hl, (pid)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 55; # ld l, #55
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x22, &result; # ld (result), hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub nice(prio: int16): (status: int8)
	@bytes 0x2a, &prio; # ld hl, (prio)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 58; # ld l, #58
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub flock(fd: int8, operation: int16): (status: int8)
	@bytes 0xaf; # xor a
	@bytes 0x2a, &operation; # ld hl, (operation)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &fd; # ld hl, (fd)
	@bytes 0x67; # ld h, a
	@bytes 0xe5; # push hl
	@bytes 0x2e, 60; # ld l, #60
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

sub getpgrp(): (pid: uint16)
	@bytes 0xaf; # xor a
	@bytes 0x2e, 61; # ld l, #61
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x22, &pid; # ld (pid), hl
	@bytes 0xe1; # pop hl
end sub;

sub sched_yield(): (status: int8)
	@bytes 0xaf; # xor a
	@bytes 0x2e, 62; # ld l, #62
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
end sub;

sub setgroups(size: uint8, gids: [uint16]): (status: int8)
	@bytes 0x2a, &gids; # ld hl, (gids)
	@bytes 0xe5; # push hl
	@bytes 0x2a, &size; # ld hl, (size)
	@bytes 0xe5; # push hl
	@bytes 0x2e, 73; # ld l, #73
	@bytes 0xe5; # push hl
	@bytes 0xcd, &__raw_syscall; # call __raw_syscall
	@bytes 0x7d; # ld a, l
	@bytes 0x32, &status; # ld (status), a
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
	@bytes 0xe1; # pop hl
end sub;

