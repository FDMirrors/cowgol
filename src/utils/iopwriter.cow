var iop_out_fd: uint8;
var old_filename_id: uint16;
var old_linenumber: uint16;

sub init_iop_writer(filename: [int8])
    iop_out_fd := file_openout(filename);
end sub;

sub write_iop_header(header: [IHeader])
    file_putblock(iop_out_fd, header as [int8], IHeader@bytes);
    old_filename_id := 0;
    old_linenumber := 0;
end sub;

sub write_terminating_iop_header()
    var buf: IHeader[1];
    buf[0].thing_id := 0;
    write_iop_header(&buf[0]);
end sub;

sub write_iop(iop: [Iop])
    if current_filename_id != old_filename_id then
        var fbuf: FilenameIop[1];
        fbuf[0].iop_size := FilenameIop@bytes;
        fbuf[0].iop_kind := IOP_FILENAME;
        fbuf[0].thing_id := current_filename_id;
        file_putblock(iop_out_fd, &fbuf[0] as [int8], FilenameIop@bytes);
        old_filename_id := current_filename_id;
    end if;

    if current_linenumber != old_linenumber then
        var lbuf: LinenumberIop[1];
        lbuf[0].iop_size := LinenumberIop@bytes;
        lbuf[0].iop_kind := IOP_LINENUMBER;
        lbuf[0].line_number := current_linenumber;
        file_putblock(iop_out_fd, &lbuf[0] as [int8], LinenumberIop@bytes);
        old_linenumber := current_linenumber;
    end if;

    file_putblock(iop_out_fd, iop as [int8], iop.iop_size);
end sub;

sub write_untyped_iop(kind: uint8)
    var obuf: Iop[1];
    obuf[0].iop_kind := kind;
    obuf[0].iop_size := Iop@bytes;
    write_iop(&obuf[0] as [Iop]);
end sub;

sub write_bytes_iop(byte_count: uint8, bytes: [uint8])
    var buf: BytesIop[1];
    buf[0].iop_size := BytesIop@bytes;
    buf[0].iop_kind := IOP_BYTES;
    buf[0].byte_count := byte_count;
    copy_memory(bytes as [int8], &buf[0].bytes[0] as [int8], byte_count);
    write_iop(&buf[0] as [Iop]);
end sub;

sub write_byte(byte: uint8)
    var buf: uint8[1];
    buf[0] := byte;
    write_bytes_iop(1, &buf[0] as [uint8]);
end sub;

sub write_word_iop(word: uint16)
    var buf: uint16[1];
    buf[0] := word;
    write_bytes_iop(2, &buf[0] as [uint8]);
end sub;

sub write_address_iop(thing_id: uint16, offset: uint16)
    var buf: AddressIop[1];
    buf[0].iop_size := AddressIop@bytes;
    buf[0].iop_kind := IOP_ADDRESS;
    buf[0].thing_id := thing_id;
    buf[0].offset := offset;
    write_iop(&buf[0] as [Iop]);
end sub;

sub write_label_iop(label: uint16)
    var buf: LabelIop;
    buf.iop_size := LabelIop@bytes;
    buf.iop_kind := IOP_LABEL;
    buf.label := label;
    write_iop(&buf as [Iop]);
end sub;

sub write_cg_6502_mem_iop(opcode: uint8, thing_id: uint16, offset: uint16)
    var buf: CG6502MemIop[1];
    buf[0].iop_size := CG6502MemIop@bytes;
    buf[0].iop_kind := IOP_CG_6502_MEM;
    buf[0].opcode := opcode;
    buf[0].thing_id := thing_id;
    buf[0].offset := offset;
    write_iop(&buf[0] as [Iop]);
end sub;

sub write_cg_6502_zeropage_iop(thing_id: uint16, offset: uint16)
    var buf: AddressIop;
    buf.iop_size := buf@bytes;
    buf.iop_kind := IOP_CG_6502_ZEROPAGE;
    buf.thing_id := thing_id;
    buf.offset := offset;
    write_iop(&buf as [Iop]);
end sub;

sub write_cg_6502_conditional_iop(opcode: uint8, label: uint16)
    var buf: CG6502ConditionalIop[1];
    buf[0].iop_size := CG6502ConditionalIop@bytes;
    buf[0].iop_kind := IOP_CG_6502_COND;
    buf[0].opcode := opcode;
    buf[0].label := label;
    write_iop(&buf[0] as [Iop]);
end sub;

