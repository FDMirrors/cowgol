sub is_valid_byte_offset(ea: [EffectiveAddress]): (is_valid: uint8)
    is_valid := 0;

    var thing_type: uint8 := get_thing_type(ea.off_id);
    if (thing_type & THING_TYPED) != 0 then
        var type_id: uint16 := get_type_of_thing(ea.off_id);
        var type: [TypeThing] := find_thing(type_id) as [TypeThing];
        if (type.thing_type != THING_UNSIGNED) or (type.width != 1) then
            print("* invalid: var offset is not unsigned byte\n");
            return;
        end if;
    elseif thing_type == THING_NUMBER then
        if (ea.flags & EA_DEREF) != 0 then
            var value: int32 := get_value_of_number(ea.off_id);
            if (value < 0) or (value > 255) then
                print("* invalid: pointer offset out of range\n");
                return;
            end if;
        end if;
    end if;

    is_valid := 1;
end sub;

sub arch_validate_be_iop(iop: [BEIop]): (is_valid: uint8)
    print("* checking ea validity: iop=0x");
    print_hex_i8(iop.iop_kind);
    print(" width=");
    print_i8(iop.width);
    print(" left=");
    print_ea(&iop.left);
    print(" right=");
    print_ea(&iop.right);
    print(" dest=");
    print_ea(&iop.dest);
    print_newline();

    var iopkind: uint8 := iop.iop_kind & IOP_TYPE_MASK;
    is_valid := 0;

    if iop.width > 1 then
        # var offsetted EAs are not allowed.
        if (is_typed_thing(iop.left.off_id) != 0) or
           (is_typed_thing(iop.right.off_id) != 0) or
           (is_typed_thing(iop.dest.off_id) != 0) then
           print("* invalid: non-constant offset\n");
           return;
        end if;

        # Derefs are only allowed if the opcode is a copy.
        if iop == IOP_BE_COPY then
            if ((iop.left.flags & EA_DEREF) != 0) and ((iop.dest.flags & EA_DEREF) != 0) then
                print("* invalid: copy with deref on both src and dest\n");
                return;
            end if;
        else
            if ((iop.left.flags & EA_DEREF) != 0)
                    or ((iop.right.flags & EA_DEREF) != 0)
                    or ((iop.dest.flags & EA_DEREF) != 0) then
                print("* invalid: deref\n");
                return;
            end if;
        end if;
    else
        # You are allowed a single var offsetted EA. This can't be combined with a deref.
        if is_valid_byte_offset(&iop.left) == 0 then
            return;
        end if;

        if iopkind == IOP_TYPE_BACKEND_3OP then
            if is_valid_byte_offset(&iop.right) == 0 then
                return;
            end if;
        end if;

        if is_valid_byte_offset(&iop.dest) == 0 then
            return;
        end if;
    end if;

    is_valid := 1;
end sub;
