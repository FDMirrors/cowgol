const REG_A    := 0b0000_0001;
const REG_X    := 0b0000_0010;
const REG_Y    := 0b0000_0100;
const REG_MASK := 0b0111_1111;
const PRECIOUS := 0b1000_0000;

record CachedValue
    location: uint8;
    ea: EffectiveAddress;
end record;

var values: CachedValue[32];
var regusage: uint8[3];

sub bad_register()
    print("bad register");
    halt();
end sub;

sub init_allocator()
    zero_memory(&values[0] as [int8], values@bytes);
    zero_memory(&regusage[0] as [int8], regusage@bytes);
end sub;

sub find_unused_regs(candidates: uint8): (mask: uint8)
    var i: uint8 := 0;
    while i < values@size loop
        candidates := candidates & (values[i].location ^ 0xff);
        i := i + 1;
    end loop;
    mask := candidates & REG_MASK;
end sub;

sub find_first_bit(value: uint8): (mask: uint8)
    mask := 1;
    loop
        if (value & mask) != 0 then
            return;
        end if;
        if mask == 0x80 then
            break;
        end if;
        mask := mask << 1;
    end loop;
    mask := 0;
end sub;

sub allocate_reg(candidates: uint8): (mask: uint8)
    mask := find_unused_regs(candidates);
    if mask == 0 then
        print("no unused registers");
        halt();
    end if;
    mask := find_first_bit(mask);
end sub;

sub find_reg_with_value(value: [EffectiveAddress]): (mask: uint8)
    var index: uint8 := 0;
    while index < values@size loop
        if is_same_ea(&values[index].ea, value) == 1 then
            mask := values[index].location & REG_MASK;
            return;
        end if;
        index := index + 1;
    end loop;
    mask := 0;
end sub;

sub value_is_cached_in_reg(value: [EffectiveAddress], mask: uint8)
    var index: uint8 := 0;
    while index < values@size loop
        if values[index].location == 0 then
            print("* using cache slot ");
            print_i8(index);
            print(" for ");
            print_ea(value);
            print_newline();
            values[index].location := mask;
            copy_ea(value, &values[index].ea);
            return;
        end if;
        index := index + 1;
    end loop;
    print("value cache is full");
    halt();
end sub;

sub value_is_precious_in_reg(value: [EffectiveAddress], mask: uint8)
    var index: uint8 := 0;
    while index < values@size loop
        if values[index].location == 0 then
            print("* using cache slot ");
            print_i8(index);
            print(" for precious ");
            print_ea(value);
            print_newline();
            values[index].location := mask | PRECIOUS;
            copy_ea(value, &values[index].ea);
            return;
        end if;
        index := index + 1;
    end loop;
    print("value cache is full");
    halt();
end sub;

sub write_back_precious_value(location: uint8, ea: [EffectiveAddress])
    print("* writing back 0x");
    print_hex_i8(location);
    print(" to precious value ");
    print_ea(ea);
    print_newline();

    if ea.type == EA_VAR_PLUS_CONST then
        var opcode: uint8;
        if location == REG_A then
            opcode := 0x8D; # STA abs
        elseif location == REG_X then
            opcode := 0x8E; # STX abs
        elseif location == REG_Y then
            opcode := 0x8C; # STY abs
        else
            bad_register();
        end if;
        write_cg_6502_mem_iop(opcode, ea.thing_id, ea.offset_id);
    else
        print("can't write precious value ");
        print_ea(ea);
        print(" yet");
        halt();
    end if;
end sub;

sub flush_cached_values(mask: uint8)
    var index: uint8 := 0;
    while index < values@size loop
        var location: uint8 := values[index].location;
        if (location & mask) != 0 then
            if (location & PRECIOUS) != 0 then
                write_back_precious_value(location & (PRECIOUS ^ 0xff), &values[index].ea);
            end if;
            print("* flushing cache slot ");
            print_i8(index);
            print_newline();
            values[index].location := 0;
        end if;
        index := index + 1;
    end loop;
end sub;

sub find_or_load_value(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := find_reg_with_value(ea);
    if location != 0 then
        print("* found in 0x");
        print_hex_i8(location);
        print(" value ");
        print_ea(ea);
        print_newline();
        return;
    end if;

    location := allocate_reg(candidates);
    print("* allocating 0x");
    print_hex_i8(location);
    print(" for ");
    print_ea(ea);
    print_newline();

    var opcode: uint8;

    flush_cached_values(location);
    value_is_cached_in_reg(ea, location);
    if ea.type == EA_NUMBER then
        var buf: uint8[2];
        if location == REG_A then
            buf[0] := 0xA9; # LDA imm
        elseif location == REG_X then
            buf[0] := 0xA2; # LDX imm
        elseif location == REG_Y then
            buf[0] := 0xA0; # LDY imm
        else
            bad_register();
        end if;
        var thing: [NumberThing] := find_thing(ea.offset_id) as [NumberThing];
        buf[1] := thing.value;
        write_bytes_iop(2, &buf[0]);
    elseif ea.type == EA_VAR_PLUS_CONST then
        if location == REG_A then
            opcode := 0xAD; # LDA abs
        elseif location == REG_X then
            opcode := 0xAE; # LDX abs
        elseif location == REG_Y then
            opcode := 0xAC; # LDY abs
        else
            bad_register();
        end if;
        write_cg_6502_mem_iop(opcode, ea.thing_id, ea.offset_id);
    else
        print("can't implicit load this ea yet");
    end if;
end sub;

sub write_byte(byte: uint8)
    var buf: uint8[1];
    buf[0] := byte;
    write_bytes_iop(1, &buf[0]);
end sub;

sub arch_gen_return()
    flush_cached_values(REG_MASK);
    write_byte(0x60); # RTS
end sub;

sub arch_gen_call(thing_id: uint16)
    flush_cached_values(REG_MASK);
    write_byte(0x20); # JSR
    write_word_iop(thing_id, 0);
end sub;

sub arch_gen_label()
    flush_cached_values(REG_MASK);
end sub;

sub arch_gen_copy(src: [EffectiveAddress], dest: [EffectiveAddress]): (matched: uint8)
    matched := 1;

    if ((src.flags & FLAG_WIDTH_2) != 0) and ((dest.flags & FLAG_WIDTH_2) != 0) then
        if ((src.flags & FLAG_NUMBER) != 0) then
            write_byte(0x20); # JSR abs
            write_word_iop(0, 0); # copy number
            write_word_iop(src.thing_id, src.offset_id);
            write_word_iop(dest.thing_id, dest.offset_id);
        else
            write_cg_copy_iop(IOP_CG_COPY2, 0,
                src.thing_id, src.offset_id,
                dest.thing_id, dest.offset_id);
        end if;
        return;
    end if;

    if ((src.flags & FLAG_WIDTH_1) != 0) and ((dest.flags & FLAG_WIDTH_1) != 0) then
        var location: uint8 := find_or_load_value(src, REG_A|REG_X|REG_Y);
        value_is_precious_in_reg(dest, location);
        return;
    end if;

    matched := 0;
end sub;

sub arch_gen_alu2op(iop: uint8,
        left: [EffectiveAddress], right: [EffectiveAddress], dest: [EffectiveAddress]):
        (matched: uint8)
    matched := 1;

    sub major_8bit(opcodebase: uint8)
        var accumulator: uint8 := find_or_load_value(left, REG_A);
        var buf: uint8[2];
        if right.type == EA_VAR_PLUS_CONST then
            # OPCODE abs
            write_cg_6502_mem_iop(opcodebase | 0x0D, right.thing_id, right.offset_id);
            value_is_precious_in_reg(dest, REG_A);
        else
            print("can't add this EA yet");
            halt();
        end if;
    end sub;

    if iop == IOP_ADDOP then
        if ((left.flags & FLAG_WIDTH_1) != 0) and ((right.flags & FLAG_WIDTH_1) != 0) then
            write_byte(0x18); # CLC
            major_8bit(0x60); # base ADC
            return;
        end if;
    end if;

    matched := 0;
end sub;

sub arch_gen_alu1op(iop: uint8, left: [EffectiveAddress], dest: [EffectiveAddress]): (matched: uint8)
    matched := 1;

    sub do_not()
        var accumulator: uint8 := find_or_load_value(left, REG_A);
        write_byte(0x4D); # EOR imm
        write_byte(0xFF);
        value_is_precious_in_reg(dest, REG_A);
    end sub;

    if iop == IOP_NOTOP then
        if (left.flags & FLAG_WIDTH_1) != 0 then
            do_not();
            return;
        end if;
    end if;

    matched := 0;
end sub;
