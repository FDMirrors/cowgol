# In order from left to right: has sizes, number of inputs, number of outputs,
# instruction definition.
- 0 0 END()
- 0 0 STARTFILE()
- 0 0 ENDFILE()
- 0 0 STARTSUB(subr: [Subroutine]) = ("%s", $$.subr.name)
- 0 0 ENDSUB(subr: [Subroutine]) = ("%s", $$.subr.name)

- 0 0 STARTINIT(sym: [Symbol]) = ("%s", $$.sym.name)
y 0 0 INIT(value: int32) = ("%d", $$.value)
- 0 0 INITS(text: string) = ("...")
- 0 0 ENDINIT()

- 0 0 ASMSTART()
- 0 0 ASMTEXT(text: string) = ("%s", $$.text)
- 0 0 ASMSYMBOL(sym: [Symbol]) = ("%s", $$.sym.name)
- 0 0 ASMVALUE(value: int32) = ("%d", $$.value)
- 0 0 ASMEND()

# This one is used internally for bookkeeping and the backend should never see it.
- 2 1 PAIR()

- 0 0 LABEL(label: uint16) = ("%d", $$.label)
- 0 0 JUMP(label: uint16) = ("%d", $$.label)
- 1 0 CALLS()
- 0 0 CALL(subr: [Subroutine]) = ("%s", $$.subr.name)
y 0 1 CALLE(subr: [Subroutine]) = ("%s", $$.subr.name)
- 0 0 RETURN()

- 0 1 CONSTANT(value: int32) = ("%d", $$.value)
- 0 1 STRING(text: string) = ("...")
- 0 1 ADDRESS(sym: [Symbol], off: Size) = ("%s%+d", $$.sym.name, $$.off)

y 1 1 LOAD()
y 2 0 STORE() # left is value, right is address

- 2 1 BAND(truelabel: LabelRef, falselabel: LabelRef, fallthrough: LabelRef, negated: uint8) = ("true=%d false=%d, fallthrough=%d negated=%d", $$.truelabel, $$.falselabel, $$.fallthrough, $$.negated)
- 2 1 BOR(truelabel: LabelRef, falselabel: LabelRef, fallthrough: LabelRef, negated: uint8) = ("true=%d false=%d, fallthrough=%d negated=%d", $$.truelabel, $$.falselabel, $$.fallthrough, $$.negated)
y 2 1 BEQS(truelabel: LabelRef, falselabel: LabelRef, fallthrough: LabelRef, negated: uint8) = ("true=%d false=%d, fallthrough=%d negated=%d", $$.truelabel, $$.falselabel, $$.fallthrough, $$.negated)
y 2 1 BLTS(truelabel: LabelRef, falselabel: LabelRef, fallthrough: LabelRef, negated: uint8) = ("true=%d false=%d, fallthrough=%d negated=%d", $$.truelabel, $$.falselabel, $$.fallthrough, $$.negated)
y 2 1 BEQU(truelabel: LabelRef, falselabel: LabelRef, fallthrough: LabelRef, negated: uint8) = ("true=%d false=%d, fallthrough=%d negated=%d", $$.truelabel, $$.falselabel, $$.fallthrough, $$.negated)
y 2 1 BLTU(truelabel: LabelRef, falselabel: LabelRef, fallthrough: LabelRef, negated: uint8) = ("true=%d false=%d, fallthrough=%d negated=%d", $$.truelabel, $$.falselabel, $$.fallthrough, $$.negated)

y 1 0 STARTCASE()
y 0 0 WHENCASE(value: int32, falselabel: uint16) = ("%s %d => %d", $$.isdefault ? "default" : "", $$.value, $$.label)

# These produce all combinations of source and destination widths.
y 1 1 CAST1(sext: uint8)
y 1 1 CAST2(sext: uint8)
y 1 1 CAST4(sext: uint8)
y 1 1 CAST8(sext: uint8)

# PUSHARG is a root node, but POPARG is a leaf. However, because the parameter
# stack and the spill stack occupy the same physical space (at least on most
# architectures), POPARG must be the first node actually generated in any
# tree. The frontend only generates it for STORE(POPARG(), something)
# statements, which meets this requirement.
y 1 0 PUSHARG(subr: [Subroutine], remaining: uint8)
y 0 1 POPARG(subr: [Subroutine], remaining: uint8)

# The order here is important. 
y 1 1 NOT()
y 1 1 NEG()
y 2 1 LSHIFT()
y 2 1 RSHIFTU()
y 2 1 RSHIFTS()
# 2op non-commutative (SUB must be the first).
y 2 1 SUB()
y 2 1 DIVU()
y 2 1 DIVS()
y 2 1 REMU()
y 2 1 REMS()
# 2op commutative (ADD must be the first).
y 2 1 ADD()
y 2 1 MUL()
y 2 1 AND()
y 2 1 OR()
y 2 1 EOR()

