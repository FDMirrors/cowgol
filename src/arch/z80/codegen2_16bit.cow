# 16-bit code generation on the Z80 is hard.
#
# This is because there are multiple interacting strategies that I need to
# use which all play off each other. In summary, these are:
#
#   - 16-bit adds or subs must have the result (and one of the LHS or RHS)
#     in HL.
#   - 8-bit indirected RHSs must use HL, IX or IY (preferably HL because #     it's much cheaper).
#   - any ALU op which isn't an add or a sub needs to be done a byte at a
#     time and pass through A.
#   - only A, HL, BC, DE, IX, IY can be read or written directly. Only A,
#     B, C, D, E, H, L can be read via indirection.
#   - offsets which aren't 0 have to use IX or IY as the index register.
#   - if all three parameters have offsets, we need to delay writing back
#     the result until we can free up an index register.
#   - if the destination is a DEREF, it needs to be written back to
#     memory immediately; otherwise, leave it in a register pair for
#     later.
#   - lots of things need HL or A for setup, but we frequently need these
#     for the LHS for the arithmetic operation, so we need to set up the
#     RHS first... except when we don't.
#
# ...and possibly more, which is a mess.
#
# We therefore need to know these facts:
#  1. Where are we going to be doing the work? (A, HL, any register.)
#     -> This also tells us whether we're working a byte at a time (via A).
#  2. Where are we leaving the result? (memory, a register pair.)
#
# So, essentially, what we end up needing to do is:
#
#  1. Decide where the work is happening. Decide where the result will be.
#  2. Set up any input pointers.
#  3. Is the work happening in A? Is the result in a DEREF? Do we
#     have a free index register? If so, set up the result pointer now.
#     Otherwise, allocate a spare 8-bit register to stash the low byte of
#     the result in.
#  4. Do the work, leaving the result either in memory (if the output
#     pointer was set up), or in a register pair. If the result needs to
#     go into a DEREF but we don't have a pointer set up, leave the low
#     byte of the result in a random 8-bit register (the high byte ends up
#     in A).
#     -> If any of the operands are a DEREF while we're doing this,
#        we need to mutate the pointer. The same pointer might be being
#        used for multiple operands, so make sure to only mutate it once
#        per byte.
#  5. Is the result going into a DEREF? Is the pointer not set up? If so,
#     set one up now, and write the result back.
#
# Yikes.
#
# I worked through some examples, and it gets painfully complicated, so
# I'm going to make the simplifying assumption that the destination is
# *always* a register pair. This will then be written back as a seperate
# stage. This makes slightly less efficient code, as if the result is a
# DEREF then we need two additional register copies... but it makes the
# logic much simpler and does allow us to cache the result (subject to
# pointer aliasing rules).
#
# Some examples:
#
#   a := b + c
#     work is: in HL (because 16-bit add)
#     result is: in HL (because 16-bit add)
#     pointers: none (values are loaded into register pairs)
#     load LHS: ld hl, (b)
#     load RHS: ld bc, (c)
#     do work:  add hl, bc
#     save result: nop, we're leaving it in HL
#
#   a := b & c
#     work is: in A (because it's an and)
#     result is: in any register pair
#     pointers: none (values are loaded into register pairs)
#     result is: in HL
#     load LHS: ld hl, (c)
#     load RHS: ld bc, (b)
#     do work:  ld a, l; and c; ld l, a
#               ld a, h; and b; ld h, a
#     save result: nop, we're leaving it in HL
#
#   a := b + c[0]
#     work is: in A (because some params are DEREF and this is ALU)
#     result is: in any register pair
#     pointers: RHS, so load it: ld hl, (c)
#     result is: in BC (because we're leaving it in a register)
#     load LHS: ld bc, (b)
#     load RHS: none (it's a DEREF)
#     do work:  ld a, c; add (hl); inc hl; ld c, a
#               ld a, b; adc (hl); ld b, a
#     save result: nop, we're leaving it in HL
#
#   a[0] := b[0] + c[0]
#     work is: in A (because some params are DEREF and this is ALU)
#     result is: any register pair
#     pointer: RHS, so load it: ld hl, (c)
#     pointer: LHS, so load it: ld bc, (b)
#     result is: in DE (result is DEREF so try to keep HL free)
#     do work: ld a, (bc); add (hl); ld a, e; inc bc; inc hl
#              ld a, (bc); adc (hl); ld a, d
#     save result: ld hl, (a)
#                  ld (hl), e; inc hl; ld (hl), d
#
#   a[1] := b[2] + c[3]
#     work is: in A (because some params are DEREF and this is ALU)
#     result is: any register pair
#     pointer: RHS, offsetted, so load it: ld ix, (c)
#     pointer: LHS, offsetted, so load it: ld iy, (b)
#     result is: in BC (result is DEREF so try to keep HL free)
#     do work: ld a, (iy+2); add (ix+3); ld c, a
#              ld a, (iy+3); adc (ix+4); ld b, a
#     save result: ld ix, (a)
#                  ld (ix+1), c
#                  ld (ix+2), b
#
#   a := b
#     work is: unnecessary
#     result is: any register pair
#     pointers: none
#     load RHS: ld hl, (b)
#     result is: HL
#     save result: nop, leave it in a register
#
#   a := b[0]
#     work is: in BC
#     result is: any register pair
#     pointer: LHS, so load it: ld hl, (b)
#     result is: in BC
#     do work: ld c, (hl); inc hl
#              ld b, (hl)
#     save result: nop, we're leaving it in BC
#
#   a[1] := b[2]
#     work is: in HL
#     result is: any register pair
#     pointer: LHS, offsetted, so load it:  ld ix, (b)
#     result is: in HL
#     do work: ld l, (ix+2)
#              ld h, (ix+3)
#     save result: ld iy, (a)
#                  ld (iy+1), l
#                  ld (iy+2), h

var rhsea: [EffectiveAddress];
var lhsea: [EffectiveAddress];
var destea: [EffectiveAddress];
var workreg: RegSet;
var rhsreg: RegSet;
var rhsptrreg: RegSet;
var lhsreg: RegSet;
var lhsptrreg: RegSet;
var destreg: RegSet;
var tempdestreg: RegSet;
var destdelayed: uint8;

sub reset_16bit_op()
    rhsea := 0 as [EffectiveAddress];
    lhsea := 0 as [EffectiveAddress];
    destea := 0 as [EffectiveAddress];
    rhsreg := 0;
    rhsptrreg := 0;
    lhsreg := 0;
    lhsptrreg := 0;
    workreg := 0;
    destreg := 0;
    tempdestreg := 0;
    destdelayed := 0;
end sub;

# Load the input pointers needed for the operation.
sub load_16bit_pointers(offset: uint8)
    lhsptrreg := setup_complex_pointer(lhsea);
    $if DEBUG
        print("* LHS ptr is ");
        print_regs(lhsptrreg);
        print_newline();
    $endif

    rhsptrreg := setup_complex_pointer(rhsea);
    $if DEBUG
        print("* RHS ptr is ");
        print_regs(rhsptrreg);
        print_newline();
    $endif
end sub;

sub load_16bit_input_parameters()
    var c: RegSet := rhsreg;
    rhsreg := 0;
    if rhsea != (0 as [EffectiveAddress]) then
        if (rhsea.flags != EA_DEREF) and (is_number_thing(rhsea.obj_id) == 0) then
            rhsreg := reg_find_or_load(c, rhsea);
        end if;
    end if;
    $if DEBUG
        print("* RHS value is ");
        print_regs(rhsreg);
        print_newline();
    $endif

    c := lhsreg;
    lhsreg := 0;
    if lhsea != (0 as [EffectiveAddress]) then
        if lhsea.flags != EA_DEREF then
            lhsreg := reg_find_or_load(c, lhsea);
        end if;
    end if;
    $if DEBUG
        print("* LHS value is ");
        print_regs(lhsreg);
        print_newline();
    $endif
end sub;

sub prepare_16bit_output_parameter()
    if (destreg == lhsreg) or (destreg == rhsreg) then
        $if DEBUG
            print("* dest reg reuses ");
            print_regs(destreg);
            print_newline();
        $endif
    else
        destreg := reg_alloc(destreg);
        $if DEBUG
            print("* dest (or temporary) reg is ");
            print_regs(destreg);
            print_newline();
        $endif
    end if;
    reg_value_is_changing(destea);
    reg_evict(destreg);
end sub;

sub evict_16bit_mutable_index_registers()
    # Evict the registers which we know we'll be mutating. We do this *now*,
    # after we've set them up, so that new registers don't get allocated on
    # top of things we're using.
    if (lhsptrreg & (REG_BC|REG_HL|REG_DE)) != 0 then
        reg_evict(lhsptrreg);
    end if;
    if (rhsptrreg & (REG_BC|REG_HL|REG_DE)) != 0 then
        reg_evict(rhsptrreg);
    end if;
end sub;

# Reads the LHS into the work register.
sub do_16bit_read(offset: uint8)
    $if DEBUG
        print("* read LHS ");
        print_ea(lhsea);
        print(" -> ");
        print_regs(workreg);
        print(" offset ");
        print_i8(offset);
        print_newline();
    $endif

    var reg: uint8 := halfof_reg(workreg, offset);
    if lhsreg != 0 then
        if lhsreg == workreg then
            return;
        end if;

        reg_copy(halfof_reg(lhsreg, offset), reg);
    elseif lhsptrreg != 0 then
        insn_init();
        insn.datareg := reg;
        insn.otherreg := lhsptrreg;
        if (lhsptrreg & REG_INDEX) != 0 then
            insn.offset := ((get_value_of_number(lhsea.numoff_id) as uint8) + offset) as int16;
        end if;
        insn.mode := MODE_IND;
        insn_load_object();
    elseif is_number_thing(lhsea.obj_id) != 0 then
        print("numbers should be loaded as pairs!");
        halt();
    else
        print("cannot load LHS");
        halt();
    end if;
end sub;

# Performs an ALU operation of the RHS against the work register (which must
# be A).
sub do_16bit_alu(offset: uint8, opcode: uint8)
    $if DEBUG
        print("* alu RHS ");
        print_ea(rhsea);
        print(" A offset ");
        print_i8(offset);
        print_newline();
    $endif

    if workreg != REG_A then
        print("can't ALU against not A");
        halt();
    end if;

    insn_init();
    insn.datareg := REG_A;
    if rhsreg != 0 then
        insn.otherreg := halfof_reg(rhsreg, offset);
        insn.mode := MODE_DIR;
    elseif rhsptrreg != 0 then
        insn.otherreg := rhsptrreg;
        if (rhsptrreg & REG_INDEX) != 0 then
            insn.offset := ((get_value_of_number(rhsea.numoff_id) as uint8) + offset) as int16;
        end if;
        insn.mode := MODE_IND;
    elseif is_number_thing(rhsea.obj_id) != 0 then
        var value: uint16 := get_value_of_number(rhsea.obj_id) as uint16;
        if offset == 1 then
            value := value >> 8;
        end if;
        insn.offset := value as int16;
        insn.mode := MODE_IMM;
    else
        print("cannot load LHS");
        halt();
    end if;
    insn_8bit_aluop(opcode);
end sub;

# Writes the work register into the destination register.
sub do_16bit_write(offset: uint8)
    $if DEBUG
        print("* write work reg ");
        print_regs(workreg);
        print(" to destination ");
        print_ea(destea);
        print(" offset ");
        print_i8(offset);
        print_newline();
    $endif

    if (destreg != 0) and (workreg != destreg) then
        reg_copy(halfof_reg(workreg, offset), halfof_reg(destreg, offset));
    end if;
end sub;

# Adjusts any pointers for the second byte.
sub adjust_16bit_pointers()
    sub inc(reg: RegSet)
        var regnum: uint8 := get_z80_regnum(reg);
        write_byte(0x03 | regnum); # inc rr
    end sub;

    if (lhsptrreg & (REG_BC|REG_DE|REG_HL)) != 0 then
        $if DEBUG
            print("* incrementing LHS ptr\n");
        $endif
        inc(lhsptrreg);
    end if;
    if (lhsptrreg != rhsptrreg) and ((rhsptrreg & (REG_BC|REG_DE|REG_HL)) != 0) then
        $if DEBUG
            print("* incrementing RHS ptr\n");
        $endif
        inc(rhsptrreg);
    end if;
end sub;

# Ensure that the destination is written back (to whereever).
sub write_back_16bit_destination()
    if destea.flags != EA_DEREF then
        $if DEBUG
            print("* leaving result in register\n");
        $endif
        reg_value_is_precious(destea);
    else
        $if DEBUG
            print("* writing back DEREF result\n");
        $endif

        var reg: RegSet := setup_complex_pointer(destea);

        sub write_back_byte(offset: uint8)
            insn_init();
            insn.datareg := halfof_reg(destreg, offset);;
            insn.otherreg := reg;
            if (reg & REG_INDEX) != 0 then
                insn.offset := ((get_value_of_number(destea.numoff_id) as uint8) + offset) as int16;
            end if;
            insn.mode := MODE_IND;
            insn_save_object();
        end sub;

        write_back_byte(0);
        if (reg & REG_INDEX) == 0 then
            reg_evict(reg);
            var regnum: uint8 := get_z80_regnum(reg);
            write_byte(0x03 | regnum); # inc rr
        end if;
        write_back_byte(1);
    end if;

    reg_cache_value(destreg, destea);
end sub;

# Ensure that the EA is ready for use as the RHS of a 16-bit arithmetic
# operation: it must either be in a register pair, or there must be a
# pointer to it in a register pair.
#
# If it's a pointer, it must be in HL, IX or IY (because those are the
# registers allowed when indirecting in the RHS of an aluop).
# 
# If it's a value, it can be in HL, BC or DE.
sub prepare_16bit_rhs(forceindex: uint8)
    $if DEBUG
        print("* prepare RHS: ");
        print_ea(rhsea);
        print_newline();
    $endif
    if rhsea.flags == EA_DEREF then
        var candidate: RegSet;
        if (forceindex != 0) or (get_value_of_number(rhsea.numoff_id) != 0) then
            candidate := REG_IX|REG_IY;
        else
            candidate := REG_HL;
        end if;
        rhsreg := setup_pointer(candidate, rhsea);
    else
        if (rhsea.flags == EA_VALUE) and (is_number_thing(rhsea.obj_id) != 0) then
            rhsreg := 0;
        else
            rhsreg := reg_find_or_load(REG_HL|REG_BC|REG_DE, rhsea);
        end if;
    end if;
end sub;

# Ensure that the EA is ready of use as the LHS of a 16-bit arithmetic
# operation: it must either be in a register pair, or there must be a
# pointer to it in a register pair.
#
# If it's a pointer, it must be in IX or IY if there's an offset, or any
# register pair if there isn't.
#
# If it's a value, it can be in HL, BC or DE.
sub prepare_16bit_lhs(forceindex: uint8)
    $if DEBUG
        print("* prepare LHS: ");
        print_ea(lhsea);
        print_newline();
    $endif
    if lhsea.flags == EA_DEREF then
        var candidate: RegSet;
        if (forceindex != 0) or (get_value_of_number(lhsea.numoff_id) != 0) then
            candidate := REG_IX|REG_IY;
        else
            candidate := REG_HL|REG_BC|REG_DE|REG_IX|REG_IY;
        end if;
        lhsreg := setup_pointer(candidate, lhsea);
    else
        lhsreg := reg_find_or_load(REG_HL|REG_BC|REG_DE, lhsea);
    end if;
end sub;

# Ensure that a register is prepared for use as the destination of a 16-bit
# arithmetic operation: either we have a register pair allocated, or a pointer
# is loaded into a register pair.
#
# If it's a pointer, it must be in IX or IY if there's an offset, or any
# register pair if there isn't.
#
# If it's a value, it can be in HL, BC or DE.
sub prepare_16bit_dest()
    $if DEBUG
        print("* prepare dest: ");
        print_ea(destea);
        print_newline();
    $endif
    if destea.flags == EA_DEREF then
        var candidate: RegSet;
        if get_value_of_number(destea.numoff_id) != 0 then
            candidate := REG_IX|REG_IY;
            destreg := reg_alloc_failable(candidate);
            if destreg == 0 then
                # We've run out of registers, so we need to delay writing back
                # the result.
                destreg := reg_alloc(REG_HL|REG_BC|REG_DE);
                destdelayed := 1;
                return;
            else
                reg_free(destreg);
            end if;
        else
            candidate := REG_HL|REG_BC|REG_DE|REG_IX|REG_IY;
        end if;
        destreg := setup_pointer(candidate, destea);
        destdelayed := 0;
    else
        destreg := reg_alloc(REG_HL|REG_BC|REG_DE);
        destdelayed := 0;
    end if;
end sub;

sub do_read(offset: uint8)
    $if DEBUG
        print("*   read lhs ");
        print_regs(lhsreg);
        print("-> A which is ");
        print_ea(lhsea);
        print(" offset ");
        print_i8(offset);
        print_newline();
    $endif

    if lhsea.flags != EA_DEREF then
        reg_copy(halfof_reg(lhsreg, offset), REG_A);
    else
        insn_init();
        insn.datareg := REG_A;
        insn.otherreg := lhsreg;
        if (lhsreg & REG_INDEX) != 0 then
            insn.offset := ((get_value_of_number(lhsea.numoff_id) as uint8) + offset) as int16;
        end if;
        insn.mode := MODE_IND;
        insn_load_object();
    end if;
end sub;

sub do_alu(offset: uint8, opcode: uint8)
    $if DEBUG
        print("*   alu opcode 0x");
        print_hex_i8(opcode);
        print_char(' ');
        print_regs(rhsreg);
        print_char(' ');
        print_ea(rhsea);
        print(" offset ");
        print_i8(offset);
        print_newline();
    $endif

    insn_init();
    insn.datareg := REG_A;
    if rhsea.flags != EA_DEREF then
        if is_number_thing(rhsea.obj_id) != 0 then
            var value: uint16 := get_value_of_number(rhsea.obj_id) as uint16;
            if offset == 1 then
                value := value >> 8;
            end if;
            insn.offset := value as int16;
            insn.mode := MODE_IMM;
        else
            insn.otherreg := halfof_reg(rhsreg, offset);
            insn.mode := MODE_DIR;
        end if;
    else
        insn.otherreg := rhsreg;
        if (rhsreg & REG_INDEX) != 0 then
            insn.offset := ((get_value_of_number(rhsea.numoff_id) as uint8) + offset) as int16;
        end if;
        insn.mode := MODE_IND;
    end if;
    insn_8bit_aluop(opcode);
end sub;

sub do_write(offset: uint8)
    $if DEBUG
        print("*   write A -> ");
        print_regs(destreg);
        print(" which is ");
        print_ea(destea);
        print(" offset ");
        print_i8(offset);
        print_newline();
    $endif

    if (destdelayed != 0) or (destea.flags != EA_DEREF) then
        reg_copy(REG_A, halfof_reg(destreg, offset));
    elseif destea.flags == EA_DEREF then
        insn_init();
        insn.datareg := REG_A;
        insn.otherreg := destreg;
        if (destreg & REG_INDEX) != 0 then
            insn.offset := ((get_value_of_number(destea.numoff_id) as uint8) + offset) as int16;
        end if;
        insn.mode := MODE_IND;
        insn_save_object();
    end if;
end sub;

sub do_inc(ea: [EffectiveAddress], reg: RegSet, opcode: uint8)
    # Multistage if because the bootstrap compiler doesn't support condition
    # short-circuiting.
    if (reg != 0) then
        if (ea.flags == EA_DEREF) and ((reg & REG_INDEX) == 0) then
            $if DEBUG
                print("*   inc ");
                print_regs(reg);
                print("= ");
                print_ea(ea);
                print_newline();
            $endif

            var regnum: uint8 := get_z80_regnum(reg);
            write_byte(opcode | regnum); # inc rr
        end if;
    end if;
end sub;
        
sub do_inc_all(opcode: uint8)
    do_inc(lhsea, lhsreg, opcode);
    if lhsreg != rhsreg then
        do_inc(rhsea, rhsreg, opcode);
    end if;
    if (destreg != rhsreg) and (destreg != lhsreg) and (destdelayed == 0) then
        do_inc(destea, destreg, opcode);
    end if;
end sub;

sub do_delayed_write()
    if destdelayed != 0 then
        # We had to cache the result in a register due to starvation (almost
        # always because IX and IY were both in use). Free them up, set up,
        # and write the result now.
        $if DEBUG
            print("*   writing back delayed result\n");
        $endif
        
        reg_free(lhsreg);
        reg_free(rhsreg);
        var destptr: RegSet := setup_pointer(REG_IX|REG_IY, destea);
        reg_evict(destptr);
        destdelayed := 0;

        insn_init();
        insn.datareg := halfof_reg(destreg, 0);
        insn.otherreg := destptr;
        insn.offset := get_value_of_number(destea.numoff_id) as int16;
        insn.mode := MODE_IND;
        insn_save_object();

        insn.datareg := halfof_reg(destreg, 1);
        insn.offset := insn.offset + 1;
        insn_save_object();
    end if;

    reg_cache_value(destreg, destea);
    if destea.flags != EA_DEREF then
        reg_value_is_precious(destea);
    end if;
end sub;

sub arch_gen_copy_word(iop: [BEIop])
    $if DEBUG
        print("* GENERATE copy word: ");
        print_ea(&iop.left);
        print(" -> ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    reset_16bit_op();
    lhsea := &iop.left;
    destea := &iop.dest;

    destreg := REG_BC|REG_DE|REG_HL;
    lhsreg := REG_BC|REG_DE|REG_HL;
    $if DEBUG
        print("* workreg is: ");
        print_regs(workreg);
        print_newline();
        print("* destreg is: ");
        print_regs(destreg);
        print_newline();
    $endif

    load_16bit_pointers(0);
    load_16bit_input_parameters();
    if lhsreg != 0 then
        $if DEBUG
            print("* reusing LHS as dest reg\n");
        $endif
        destreg := lhsreg;
    end if;
    prepare_16bit_output_parameter();
    workreg := destreg;
    evict_16bit_mutable_index_registers();

    do_16bit_read(0);
    do_16bit_write(0);

    adjust_16bit_pointers();

    do_16bit_read(1);
    do_16bit_write(1);

    write_back_16bit_destination();
end sub;

sub arch_gen_regular_alu_word(iop: [BEIop], opcode1: uint8, opcode2: uint8)
    $if DEBUG
        print("* GENERATE alu word: opcode1=0x");
        print_hex_i8(opcode1);
        print(" opcode2=0x");
        print_hex_i8(opcode2);
        print(": ");
        print_ea(&iop.left);
        print(" + ");
        print_ea(&iop.right);
        print(" -> ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    reset_16bit_op();
    
    rhsea := &iop.right;
    destea := &iop.dest;
    lhsea := &iop.left;

    workreg := REG_A;
    destreg := REG_BC|REG_DE|REG_HL;
    lhsreg := REG_BC|REG_DE|REG_HL;
    rhsreg := REG_BC|REG_DE|REG_HL;
    $if DEBUG
        print("* workreg is: ");
        print_regs(workreg);
        print_newline();
        print("* destreg is: ");
        print_regs(destreg);
        print_newline();
    $endif

    load_16bit_pointers(0);
    load_16bit_input_parameters();
    prepare_16bit_output_parameter();
    evict_16bit_mutable_index_registers();

    do_16bit_read(0);
    do_16bit_alu(0, opcode1);
    do_16bit_write(0);

    adjust_16bit_pointers();

    do_16bit_read(1);
    do_16bit_alu(1, opcode2);
    do_16bit_write(1);

    write_back_16bit_destination();
end sub;

sub arch_gen_add_word(iop: [BEIop])
    arch_gen_regular_alu_word(iop, 0xC6, 0xCE); # add, adc
end sub;

sub arch_gen_sub_word(iop: [BEIop])
    arch_gen_regular_alu_word(iop, 0xD6, 0xDE); # sub, sbc
end sub;

sub arch_gen_zext_word(iop: [BEIop])
    $if DEBUG
        print("* GENERATE: zext: ");
        print_ea(&iop.left);
        print(" => ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    reset_16bit_op();
    lhsea := &iop.left;
    destea := &iop.dest;

    destreg := REG_BC|REG_DE|REG_HL;
    prepare_16bit_output_parameter();
    workreg := REG_A;

    load_complex_8bit_value_fixed(REG_A, lhsea);
    do_16bit_write(0);
    reg_free(REG_A);
    
    adjust_16bit_pointers();

    reg_find_or_load_int_fixed(REG_A, 0);
    do_16bit_write(1);
    reg_free(REG_A);

    write_back_16bit_destination();
end sub;

sub arch_gen_sext_word(iop: [BEIop])
    $if DEBUG
        print("* GENERATE: sext: ");
        print_ea(&iop.left);
        print(" => ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    reset_16bit_op();
    lhsea := &iop.left;
    destea := &iop.dest;

    destreg := REG_BC|REG_DE|REG_HL;
    prepare_16bit_output_parameter();
    workreg := REG_A;

    load_complex_8bit_value_fixed(REG_A, lhsea);
    do_16bit_write(0);
    
    adjust_16bit_pointers();

    reg_evict(REG_A);
    write_byte(0x07); # rlca
    write_byte(0x9F); # sbc a, a
    do_16bit_write(1);
    reg_free(REG_A);

    write_back_16bit_destination();
end sub;

sub arch_gen_cmp_word(ciop: [BEConditionalIop], liop: [LabelIop])
    $if DEBUG
        print("* GENERATE: compare words 0x");
        print_hex_i8(ciop.iop_kind);
        print(": ");
        print_ea(&ciop.left);
        print(", ");
        print_ea(&ciop.right);
        print(" => label 0x");
        print_hex_i8(liop.label);
        print_newline();
    $endif

    var iopkind: uint8 := ciop.iop_kind;
    reset_16bit_op();

    var invertflag: uint8;
    var destlabel: uint8;
    var fallthrough_label: uint8;
    if liop.label == ciop.iftrue_label then
        invertflag := 0x00;
        fallthrough_label := ciop.iftrue_label;
        destlabel := ciop.iffalse_label;
    else
        invertflag := 0x08;
        fallthrough_label := ciop.iffalse_label;
        destlabel := ciop.iftrue_label;
    end if;

    sub gen_comparison_branch(offset: uint8)
        if iopkind == IOP_BE_BEQ then
            do_alu(offset, 0xFE); # cp *
            write_cg_conditional_iop(0xC2 ^ invertflag, destlabel); # jp nz
        else
            if (iopkind & IOP_TYPE_COMPARISON_S) != 0 then
                # BLTS
                do_alu(offset, 0xD6); # sub *

                var skipxorlabel: uint8 := create_label();
                write_cg_conditional_iop(0xE2 ^ invertflag, skipxorlabel); # jp po
                write_word(0x80EE); # xor 0x80
                write_label_iop(skipxorlabel);

                write_cg_conditional_iop(0xF2 ^ invertflag, destlabel); # jp p
            else
                # BLTU
                do_alu(offset, 0xFE); # cp *
                write_cg_conditional_iop(0xD2 ^ invertflag, destlabel); # jp c
            end if;
        end if;
    end sub;

    lhsea := &ciop.left;
    rhsea := &ciop.right;

    prepare_16bit_rhs(1);
    prepare_16bit_lhs(1);

    reg_evict(ALL_REGS);

    do_read(1);
    gen_comparison_branch(1);
    
    do_inc_all(0x0B); # dec rr
    
    do_read(0);
    gen_comparison_branch(0);

    if liop.label != fallthrough_label then
        write_cg_conditional_iop(0xC3, fallthrough_label); # jp
    end if;
end sub;
