sub load_complex_16bit_value(regs: RegSet, ea: [EffectiveAddress]): (reg: RegSet)
    # If the value is already in a register, load it.

    if reg_is_cached_in(REG_16BIT, ea) != 0 then
        reg := reg_find_or_load(regs, ea);
        return;
    end if;
        
    # If the value can be trivially loaded, do so.

    if ea.flags == EA_VALUE then
        reg := reg_find_or_load(regs, ea);
        return;
    end if;

    # The value is going to have to be indirected through a pointer of
    # some description, as we can't refer to it directly.

    var pointer: RegSet := construct_pointer(REG_HL|REG_IX|REG_IY, MODE_IND, ea, 0);

    # Now the pointer is in a register, dereference it.

    sub load_byte(offset: uint8)
        insn_init();
        insn.datareg := halfof_reg(reg, offset);
        insn.otherreg := pointer;
        insn.mode := MODE_IND;
        if (pointer & REG_INDEX) != 0 then
            insn.offset := (get_value_of_number(ea.numoff_id) as int16) + (offset as int16);
        end if;
        insn_load_object();
    end sub;

    reg := reg_alloc(REG_BC|REG_DE|REG_HL);
    
    load_byte(0);
    if (pointer == REG_HL) then
        write_byte(0x23); # inc hl
    end if;
    load_byte(1);

    reg_free(pointer);
    reg_cache_value(reg, ea);
end sub;

sub load_complex_16bit_value_fixed(regs: RegSet, ea: [EffectiveAddress])
    var location: RegSet := load_complex_16bit_value(regs, ea);
end sub;

sub save_16bit_or_make_precious(ea: [EffectiveAddress], reg: RegSet)
    reg_cache_value(reg, ea);
    if ea.flags == EA_DEREF then
        var pointer: RegSet := construct_pointer(REG_HL|REG_IX|REG_IY, MODE_IND, ea, 0);

        sub save_byte(offset: uint8)
            insn_init();
            insn.datareg := halfof_reg(reg, offset);
            insn.otherreg := pointer;
            insn.mode := MODE_IND;
            if (pointer & REG_INDEX) != 0 then
                insn.offset := (get_value_of_number(ea.numoff_id) as int16) + (offset as int16);
            end if;
            insn_save_object();
        end sub;

        save_byte(0);
        if pointer == REG_HL then
            write_byte(0x23); # inc hl
        end if;
        save_byte(1);

        reg_free(pointer);
    else
        reg_value_is_precious(ea);
    end if;
end sub;

sub inplace_shift(reg: RegSet, offset: uint8, opcode: uint8)
    $if DEBUG
        print("* in-place shifting reg ");
        print_regs(reg);
        print(" offset ");
        print_i8(offset);
        print_newline();
    $endif
    var regnum: uint8 := get_z80_regnum(halfof_reg(reg, offset));
    write_byte(0xCB);
    write_byte(opcode | regnum);
end sub;
    
sub arch_gen_lsl_word(iop: [BEIop])
    $if DEBUG
        print("* GENERATE lsl word: ");
        print_ea(&iop.left);
        print(" << ");
        print_ea(&iop.right);
        print(" -> ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    load_complex_8bit_value_fixed(REG_B, &iop.right);
    var reg: RegSet := load_complex_16bit_value(REG_16BIT, &iop.left);
    reg_evict(reg);
    reg_evict(REG_B);
    reg_cache_value(reg, &iop.dest);
    reg_value_is_precious(&iop.dest);

    # We have to skip the shift completely if the value is 0. Because the test
    # happens at the *end* of the loop, if we just go in the front we'll always
    # go round once. So we do this instead.
    # TODO: unnecessary if the RHS is a constant.

    var entrypoint: uint8 := create_label();
    write_byte(0x04); # inc b
    write_cg_conditional_iop(0xC3, entrypoint); # jp

    var label: uint8 := create_label();
    write_label_iop(label);
    inplace_shift(reg, 0, 0x20); # sla r
    inplace_shift(reg, 1, 0x10); # rl r
    write_label_iop(entrypoint);
    write_cg_conditional_iop(0x10, label); # djnz label
    
    reg_free(REG_B);
    save_16bit_or_make_precious(&iop.dest, reg);
end sub;

sub arch_gen_lsr_word(iop: [BEIop])
    $if DEBUG
        print("* GENERATE lsr word: ");
        print_ea(&iop.left);
        print(" >> ");
        print_ea(&iop.right);
        print(" -> ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    load_complex_8bit_value_fixed(REG_B, &iop.right);
    var reg: RegSet := load_complex_16bit_value(REG_16BIT, &iop.left);
    reg_evict(reg);
    reg_evict(REG_B);
    reg_cache_value(reg, &iop.dest);
    reg_value_is_precious(&iop.dest);

    # We have to skip the shift completely if the value is 0. Because the test
    # happens at the *end* of the loop, if we just go in the front we'll always
    # go round once. So we do this instead.
    # TODO: unnecessary if the RHS is a constant.

    var entrypoint: uint8 := create_label();
    write_byte(0x04); # inc b
    write_cg_conditional_iop(0xC3, entrypoint); # jp

    var label: uint8 := create_label();
    write_label_iop(label);
    inplace_shift(reg, 1, 0x38); # srl r
    inplace_shift(reg, 0, 0x18); # rr r
    write_label_iop(entrypoint);
    write_cg_conditional_iop(0x10, label); # djnz label
    
    reg_free(REG_B);
    save_16bit_or_make_precious(&iop.dest, reg);
end sub;

sub arch_gen_asr_word(iop: [BEIop])
    $if DEBUG
        print("* GENERATE asr word: ");
        print_ea(&iop.left);
        print(" >> ");
        print_ea(&iop.right);
        print(" -> ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    load_complex_8bit_value_fixed(REG_B, &iop.right);
    var reg: RegSet := load_complex_16bit_value(REG_16BIT, &iop.left);
    reg_evict(reg);
    reg_evict(REG_B);
    reg_cache_value(reg, &iop.dest);
    reg_value_is_precious(&iop.dest);

    # We have to skip the shift completely if the value is 0. Because the test
    # happens at the *end* of the loop, if we just go in the front we'll always
    # go round once. So we do this instead.
    # TODO: unnecessary if the RHS is a constant.

    var entrypoint: uint8 := create_label();
    write_byte(0x04); # inc b
    write_cg_conditional_iop(0xC3, entrypoint); # jp

    var label: uint8 := create_label();
    write_label_iop(label);
    inplace_shift(reg, 1, 0x28); # sra r
    inplace_shift(reg, 0, 0x18); # rr r
    write_label_iop(entrypoint);
    write_cg_conditional_iop(0x10, label); # djnz label
    
    reg_free(REG_B);
    save_16bit_or_make_precious(&iop.dest, reg);
end sub;
