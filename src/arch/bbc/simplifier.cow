sub get_width_of(node: [Node]): (width: int8)
    width := get_width_of_type(node.type_id);
end sub;

sub write_be_iop(iop: [BEIop])
    print("* BE iop 0x");
    print_hex_i8(iop.iop_kind);
    print(" width=");
    print_i8(iop.width);
    print(" left=");
    print_ea(&iop.left);
    print(" right=");
    print_ea(&iop.right);
    print(" dest=");
    print_ea(&iop.dest);
    print_newline();
    write_iop(iop as [Iop]);
end sub;

sub reset_be_iop(iop: [BEIop])
    zero_memory(iop as [int8], BEIop@bytes);
    iop.iop_size := BEIop@bytes;
    iop.left.type := EA_OBJVAL;
    iop.right.type := EA_OBJVAL;
end sub;

sub simplify_ea(beiop: int8, width: int8, ea: [EffectiveAddress])
    var iop: BEIop;
    var tmpvar_id: int16;

    sub varoffset_into_add()
        tmpvar_id := alloc_temporary(int16_type);
        reset_be_iop(&iop);
        iop.iop_kind := IOP_BE_ADD;
        iop.width := 2;
        iop.left.obj_id := ea.obj_id;
        iop.left.type := ea.type & (EA_DEREF_AFTER ^ -1);
        iop.right.obj_id := ea.varoff_id;
        iop.right.type := EA_OBJVAL;
        iop.dest.obj_id := tmpvar_id;
        iop.dest.type := EA_OBJVAL;
        write_be_iop(&iop);

        deref_temporary(ea.obj_id);
        ea.obj_id := tmpvar_id;
        ea.type := EA_PTRVAL;
        ea.varoff_id := 0;
    end sub;

    sub numoffset_into_add()
        if tmpvar_id == 0 then
            tmpvar_id := alloc_temporary(int16_type);
        else
            ref_temporary(tmpvar_id);
        end if;

        reset_be_iop(&iop);
        iop.iop_kind := IOP_BE_ADD;
        iop.width := 2;
        iop.left.obj_id := ea.obj_id;
        iop.left.type := ea.type & (EA_DEREF_AFTER ^ -1);
        iop.right.obj_id := ea.numoff_id;
        iop.right.type := EA_OBJVAL;
        iop.dest.obj_id := tmpvar_id;
        iop.dest.type := EA_OBJVAL;
        write_be_iop(&iop);

        deref_temporary(ea.obj_id);
        ea.obj_id := tmpvar_id;
        ea.type := EA_PTRVAL;
        ea.numoff_id := 0;
    end sub;

    if ea.varoff_id != 0 then
        var type_id: int16 := get_type_of_thing(ea.varoff_id);
        var type: [TypeThing] := find_thing(type_id) as [TypeThing];

        # If this is an OBJVAL ea, then the object must be an array. Out of bound
        # array indices are invalid (i.e. undefined behaviour). So, an 8-bit
        # index has valid indices 0..127... which can be done via an index
        # instruction.
        if (type.width != 1) or (ea.type != EA_OBJVAL) then
            print("* turning var offset into add\n");
            varoffset_into_add();
        end if;
    end if;

    if ea.numoff_id != 0 then
        sub is_number_a_byte(number_id: int16): (is_valid: int8)
            var value: int32 := get_value_of_number(number_id);
            if (value >= 0) and (value <= 255) then
                is_valid := 1;
            else
                is_valid := 0;
            end if;
        end sub;

        if (ea.type & EA_DEREF_AFTER) != 0 then
            if is_number_a_byte(ea.numoff_id) == 0 then
                print("* turning too-large constant offset of deref into add\n");
                numoffset_into_add();
            end if;
        end if;
    end if;
end sub;

sub arch_simplify_node_to(src: [Node], dest: [Node])
    if dest.iop != IOP_FEX_PUSH then
        print("simplify_node_to() where dest is not simplified");
        halt();
    end if;

    var destwidth: int8 := get_width_of(dest);

    var iop: BEIop;
    reset_be_iop(&iop);
    iop.width := destwidth;
    copy_ea(&dest.left, &iop.dest);

    if src.iop == IOP_FEX_PUSH then
        iop.iop_kind := IOP_BE_COPY;
    else
        iop.iop_kind := src.iop;
    end if;

    copy_ea_ref(&src.left, &iop.left);
    copy_ea_ref(&src.right, &iop.right);

    simplify_ea(iop.iop_kind, destwidth, &iop.left);
    if (iop.iop_kind & IOP_TYPE_MASK) == IOP_TYPE_BACKEND_3OP then
        simplify_ea(iop.iop_kind, destwidth, &iop.right);
    end if;
    simplify_ea(iop.iop_kind, destwidth, &iop.dest);

    write_be_iop(&iop);

    deref_ea(&iop.left);
    deref_ea(&iop.right);
    deref_ea(&iop.dest);
end sub;

sub arch_simplify_conditional_iop(iop: [BEConditionalIop])
    simplify_ea(iop.iop_kind, iop.width, &iop.left);
    simplify_ea(iop.iop_kind, iop.width, &iop.right);

    write_iop(iop as [Iop]);
end sub;
