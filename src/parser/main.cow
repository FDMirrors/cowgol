var break_label_id: uint16;
var continue_label_id: uint16;
var if_true_label_id: uint16;
var if_false_label_id: uint16;
var if_end_label_id: uint16;

sub create_function(out subroutine_id: uint16, out namespace_id: uint16)
    subroutine_id := create_thing(THING_SUBROUTINE, SubroutineThing@bytes);
    namespace_id := create_thing(THING_NAMESPACE, NamespaceThing@bytes);
    var namespace: [NamespaceThing] := find_thing(namespace_id) as [NamespaceThing];
    namespace.previous_namespace := current_namespace_id;
    var subroutine: [SubroutineThing] := find_thing(subroutine_id) as [SubroutineThing];
    subroutine.namespace := namespace_id;
end sub;

sub push_loop()
    lexical_push(break_label_id);
    lexical_push(continue_label_id);
    lexical_push(TOKEN_LOOP);
end sub;

sub pop_loop()
    emit_goto(continue_label_id);
    emit_label(break_label_id);

    lexical_pop_scope_type(TOKEN_LOOP);
    continue_label_id := lexical_pop();
    break_label_id := lexical_pop();
end sub;

sub push_if()
    lexical_push(if_true_label_id);
    lexical_push(if_false_label_id);
    lexical_push(if_end_label_id);
    lexical_push(TOKEN_IF);
end sub;

sub pop_if()
    emit_label(if_end_label_id);

    lexical_pop_scope_type(TOKEN_IF);
    if_end_label_id := lexical_pop();
    if_false_label_id := lexical_pop();
    if_true_label_id := lexical_pop();
end sub;

sub push_subroutine()
    lexical_push(break_label_id);
    lexical_push(continue_label_id);
    lexical_push(if_true_label_id);
    lexical_push(if_false_label_id);
    lexical_push(if_end_label_id);
    lexical_push(current_subroutine_id);
    lexical_push(current_namespace_id);
    lexical_push(ioptab_size);
    lexical_push(TOKEN_SUB);
end sub;

sub pop_subroutine()
    lexical_pop_scope_type(TOKEN_SUB);

    emit_simple(IOP_END);

    flush_iops(lexical_pop());
    current_namespace_id := lexical_pop();
    current_subroutine_id := lexical_pop();
    if_end_label_id := lexical_pop();
    if_false_label_id := lexical_pop();
    if_end_label_id := lexical_pop();
    continue_label_id := lexical_pop();
    break_label_id := lexical_pop();
end sub;

sub create_bootstrap_type(identifier_id: uint16, out type: [NumericThing])
    var type_id: uint16 := create_thing(THING_NUMERIC, NumericThing@bytes);
    add_symbol(identifier_id, type_id, current_namespace_id);
    type := find_thing(type_id) as [NumericThing];
end sub;

sub init_parser()
    current_namespace_id := 0;
    lexical_push(LEX_TOP);

    create_function(current_subroutine_id, current_namespace_id);

    var type: [NumericThing];
    type := create_bootstrap_type(TOKEN_INT8);
    type.thing_type := THING_SIGNED;
    type.width := 1;

    type := create_bootstrap_type(TOKEN_UINT8);
    type.thing_type := THING_UNSIGNED;
    type.width := 1;

    type := create_bootstrap_type(TOKEN_INT16);
    type.thing_type := THING_SIGNED;
    type.width := 2;

    type := create_bootstrap_type(TOKEN_UINT16);
    type.thing_type := THING_UNSIGNED;
    type.width := 2;

    type := create_bootstrap_type(TOKEN_INT32);
    type.thing_type := THING_SIGNED;
    type.width := 4;

    type := create_bootstrap_type(TOKEN_UINT32);
    type.thing_type := THING_UNSIGNED;
    type.width := 4;
end sub;

sub do_sub()
    var old_namespace_id: uint16 := current_namespace_id;

    push_subroutine();
    expect_token(TOKEN_SUB);
    var id: uint16 := expect_identifier();
    create_function(current_subroutine_id, current_namespace_id);
    add_symbol(id, current_subroutine_id, old_namespace_id);
    break_label_id := 0;
    continue_label_id := 0;
    if_true_label_id := 0;
    if_false_label_id := 0;
    if_end_label_id := 0;

    expect_token(TOKEN_OPENPAREN);

    while current_token != TOKEN_CLOSEPAREN loop
        var inout: uint16 := TOKEN_IN;
        if (current_token == TOKEN_IN) | (current_token == TOKEN_OUT) | (current_token == TOKEN_INOUT) then
            inout := current_token;
            next_token();
        end if;

        id := expect_identifier();
        expect_token(TOKEN_COLON);
        var type_id: uint16 := read_type();

        var parameter_id: uint16 := create_thing(THING_PARAMETER, ParameterThing@bytes);
        add_symbol(id, parameter_id, current_namespace_id);
        var parameter: [ParameterThing] := find_thing(parameter_id) as [ParameterThing];
        parameter.inout := inout;
        parameter.type := type_id;

        if current_token != TOKEN_COMMA then
            break;
        end if;
        next_token();
    end loop;
    expect_token(TOKEN_CLOSEPAREN);
end sub;

sub do_var()
    expect_token(TOKEN_VAR);
    var id: uint16 := expect_identifier();
    expect_token(TOKEN_COLON);
    var type_id: uint16 := read_type();

    var variable_id: uint16 := create_thing(THING_VARIABLE, VariableThing@bytes);
    add_symbol(id, variable_id, current_namespace_id);
    var variable: [VariableThing] := find_thing(variable_id) as [VariableThing];
    variable.type := type_id;

    if current_token == TOKEN_ASSIGN then
        var thing_iop: [ThingIop] := emit(IOP_THING, ThingIop@bytes) as [ThingIop];
        thing_iop.thing_id := variable_id;

        next_token();
        do_expression();
        emit_simple(IOP_ASSIGN);
    end if;

    expect_token(TOKEN_SEMICOLON);
end sub;

sub do_const()
    expect_token(TOKEN_CONST);
    var id: uint16 := expect_identifier();
    expect_token(TOKEN_ASSIGN);

    var value: int32 := do_constant();
    var number_id: uint16 := add_number_by_value(value);
    add_symbol(id, number_id, current_namespace_id);

    expect_token(TOKEN_SEMICOLON);
end sub;

sub do_end()
    expect_token(TOKEN_END);
    var peeked: uint16 := lexical_peek();
    if current_token != peeked then
        print("can't close a ");
        show_identifier(peeked);
        print(" with a ");
        show_identifier(current_token);
        halt();
    end if;
    if current_token == TOKEN_SUB then
        next_token();
        pop_subroutine();
    elseif current_token == TOKEN_LOOP then
        next_token();
        pop_loop();
    elseif current_token == TOKEN_IF then
        next_token();
        pop_if();
    else
        print("can't close ");
        show_identifier(current_token);
        print(" yet");
        halt();
    end if;
    expect_token(TOKEN_SEMICOLON);
end sub;

sub do_label()
    var id: uint16 := expect_identifier();
    expect_token(TOKEN_COLON);

    var label_id: uint16 := create_label();
    add_symbol(id, label_id, current_namespace_id);
    emit_label(label_id);
end sub;

sub do_assignment()
    do_expression();
    expect_token(TOKEN_ASSIGN);
    do_expression();
    expect_token(TOKEN_SEMICOLON);

    emit_simple(IOP_ASSIGN);
end sub;

sub do_goto()
    next_token();
    var id: uint16 := expect_identifier();
    emit_goto(id);

    expect_token(TOKEN_SEMICOLON);
end sub;

sub do_generic_loop_opening()
    next_token();
    push_loop();

    continue_label_id := create_label();
    emit_label(continue_label_id);
end sub;

sub do_loop()
    do_generic_loop_opening();
    break_label_id := create_label();
end sub;

sub do_while()
    do_generic_loop_opening();

    var loop_label_id: uint16;
    do_conditional(loop_label_id, break_label_id);
    emit_label(loop_label_id);

    expect_token(TOKEN_LOOP);
end sub;

sub do_jump(label_id: uint16)
    next_token();
    expect_token(TOKEN_SEMICOLON);

    if label_id == 0 then
        print("not inside a loop");
        halt();
    end if;

    emit_goto(label_id);
end sub;

sub do_return()
    next_token();
    expect_token(TOKEN_SEMICOLON);
    emit_simple(IOP_RETURN);
end sub;

sub do_generic_if_then()
    if_true_label_id := create_label();
    if_false_label_id := create_label();
    do_conditional(if_true_label_id, if_false_label_id);
    expect_token(TOKEN_THEN);
    emit_label(if_true_label_id);
end sub;

sub do_if()
    next_token();
    push_if();
    do_generic_if_then();
    if_end_label_id := create_label();
end sub;

sub do_elseif()
    next_token();
    emit_goto(if_end_label_id);
    emit_label(if_false_label_id);
    do_generic_if_then();
end sub;

sub do_else()
    next_token();
    emit_goto(if_end_label_id);
    emit_label(if_false_label_id);
end sub;

sub do_functioncall()
    var id: uint16 := expect_identifier();
    var parameters: uint8 := 0;

    expect_token(TOKEN_OPENPAREN);
    loop
        if current_token == TOKEN_CLOSEPAREN then
            break;
        end if;
        if parameters > 0 then
            expect_token(TOKEN_COMMA);
        end if;

        do_expression();
        parameters := parameters + 1;
    end loop;
    expect_token(TOKEN_CLOSEPAREN);

    var iop: [CallIop] := emit(IOP_SCALL, CallIop@bytes) as [CallIop];
    iop.thing_id := id;
    iop.parameter_count := parameters;
    expect_token(TOKEN_SEMICOLON);
end sub;

load_thing_table("things.dat");
init_parser();
init_tokenreader("tokens.dat");

open_iopfile("iops.dat");
break_label_id := 0;
continue_label_id := 0;
while current_token != 0 loop
    var thing: [Thing] := find_thing(current_token);
    if thing.thing_type == THING_IDENTIFIER then
        if peeked_token == TOKEN_COLON then
            do_label();
        elseif peeked_token == TOKEN_OPENPAREN then
            do_functioncall();
        else
            do_assignment();
        end if;
    elseif current_token == TOKEN_SUB then
        do_sub();
    elseif current_token == TOKEN_VAR then
        do_var();
    elseif current_token == TOKEN_CONST then
        do_const();
    elseif current_token == TOKEN_END then
        do_end();
    elseif current_token == TOKEN_GOTO then
        do_goto();
    elseif current_token == TOKEN_LOOP then
        do_loop();
    elseif current_token == TOKEN_WHILE then
        do_while();
    elseif current_token == TOKEN_BREAK then
        do_jump(break_label_id);
    elseif current_token == TOKEN_CONTINUE then
        do_jump(continue_label_id);
    elseif current_token == TOKEN_RETURN then
        do_return();
    elseif current_token == TOKEN_IF then
        do_if();
    elseif current_token == TOKEN_ELSE then
        do_else();
    elseif current_token == TOKEN_ELSEIF then
        do_elseif();
    else
        print("unknown token ");
        show_identifier(current_token);
        halt();
    end if;
end loop;
var iop: [Iop] := emit(IOP_END, Iop@bytes);
flush_iops(0);
close_iopfile();

print("thing table size: ");
print_i16(thing_table_top);
print_newline();
save_thing_table("things.dat");
