var reference_count: uint16 := 0;
var subroutine_count: uint16 := 0;
var used_subroutine_count: uint16 := 0;

sub check_sub_ancestry(child_sub_id: uint16, parent_sub_id: uint16): (yes: uint8)
    sub namespace_of(subroutine_id: uint16): (namespace: [NamespaceThing])
        var subroutine: [SubroutineThing] := find_thing(subroutine_id) as [SubroutineThing];
        namespace := find_thing(subroutine.namespace_id) as [NamespaceThing];
    end sub;

    var child: [NamespaceThing] := namespace_of(child_sub_id);
    var parent: [NamespaceThing] := namespace_of(parent_sub_id);

    yes := 0;
    while child != parent loop
        if child.previous_namespace == 0 then
            return;
        end if;
        child := find_thing(child.previous_namespace) as [NamespaceThing];
    end loop;

    yes := 1;
end sub;

sub process_subroutine(subroutine_id: uint16)
    var subroutine: [SubroutineThing] := find_thing(subroutine_id) as [SubroutineThing];
    subroutine.segment := SEGMENT_OMIT;

    sub do_call(iop: [CallIop])
        reference_count := reference_count + 1;
        add_reference(subroutine_id, iop.thing_id);
    end sub;

    sub do_var(var_id: uint16)
        if is_typed_thing(var_id) != 0 then
            var obj: [TypedThing] := find_thing(var_id) as [TypedThing];
            if obj.segment == SEGMENT_UNKNOWN then
                if obj.address == 0 then
                    obj.address := subroutine_id;
                else
                    if check_sub_ancestry(subroutine_id, obj.address) == 0 then
                        obj.address := subroutine_id;
                    end if;
                end if;
            end if;
        end if;
    end sub;

    sub do_ea(ea: [EffectiveAddress])
        do_var(ea.obj_id);
        do_var(ea.varoff_id);
    end sub;

    sub do_beiop(iop: [BEIop])
        do_ea(&iop.left);
        do_ea(&iop.right);
        do_ea(&iop.dest);
    end sub;

    sub do_beconditionaliop(iop: [BEConditionalIop])
        do_ea(&iop.left);
        do_ea(&iop.right);
    end sub;

    loop
        var iop: [Iop] := read_iop();
        var ioptype: uint8 := iop.iop_kind & IOP_TYPE_MASK;

        if iop.iop_kind == IOP_END then
            break;
        elseif iop.iop_kind == IOP_CALL then
            do_call(iop as [CallIop]);
        elseif (ioptype == IOP_TYPE_BACKEND_2OP)
            or (ioptype == IOP_TYPE_BACKEND_3OP)
        then
            do_beiop(iop as [BEIop]);
        elseif (iop.iop_kind == IOP_BE_BEQ)
            or (iop.iop_kind == IOP_BE_BLTS)
            or (iop.iop_kind == IOP_BE_BLTU)
            or (iop.iop_kind == IOP_BE_BGTS)
            or (iop.iop_kind == IOP_BE_BGTU)
        then
            do_beconditionaliop(iop as [BEConditionalIop]);
        end if;
    end loop;
end sub;

sub build_graph()
    loop
        var iheader: [IHeader] := read_iop_header();
        if iheader.thing_id == 0 then
            break;
        end if;

        process_subroutine(iheader.thing_id);
        subroutine_count := subroutine_count + 1;
    end loop;
end sub;

sub mark_main_subroutine()
    var main_id: uint16 := find_main_subroutine();
    var main: [SubroutineThing] := find_thing(main_id) as [SubroutineThing];
    main.segment := SEGMENT_UNKNOWN;
    used_subroutine_count := 1;
end sub;

sub find_reachable_subroutines()
    var changed: uint8;

    loop
        changed := 0;
        var i: uint16 := 0;
        while i < graph_count loop
            var g: [GraphRecord] := &graph_base[i];
            var src: [SubroutineThing] := find_thing(g.src_id) as [SubroutineThing];
            var dest: [SubroutineThing] := find_thing(g.dest_id) as [SubroutineThing];

            if src.segment == SEGMENT_UNKNOWN then
                if dest.segment == SEGMENT_OMIT then
                    changed := 1;
                    dest.segment := SEGMENT_UNKNOWN;
                    dest.address := used_subroutine_count;
                    used_subroutine_count := used_subroutine_count + 1;
                end if;
            end if;

            i := i + 1;
        end loop;

        if changed == 0 then
            break;
        end if;
    end loop;
end sub;

sub clean_graph()
    var i: uint16 := 0;
    while i < graph_count loop
        var g: [GraphRecord] := &graph_base[i];
        var src: [SubroutineThing] := find_thing(g.src_id) as [SubroutineThing];

        if src.segment == SEGMENT_OMIT then
            g.src_id := 0;
            g.dest_id := 0;
        end if;

        i := i + 1;
    end loop;
end sub;

init_graph(&thing_table[thing_table_top] as [int8]);
build_graph();
print("found ");
print_i16(subroutine_count);
print(" subroutines in ");
print_i16(graph_count);
print(" graph nodes from ");
print_i16(reference_count);
print(" references\n");

mark_main_subroutine();
find_reachable_subroutines();

print("found ");
print_i16(used_subroutine_count);
print(" reachable subroutines\n");

clean_graph();

save_thing_table("things.dat");
