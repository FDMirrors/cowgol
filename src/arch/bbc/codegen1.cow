record CachedValue
    ea: EffectiveAddress;
    locations: uint8;
end record;

var values: CachedValue[8];
var locked_registers: uint8;

sub print_cache()
    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        if value.locations != 0 then
            print("cache slot ");
            print_i8(i);
            print(": ");
            print_ea(&value.ea);
            if (value.locations & PRECIOUS) != 0 then
                print(" precious");
            end if;
            print(" in 0x");
            print_hex_i8(value.locations & REG_MASK);
            print_newline();
        end if;
        i := i + 1;
    end loop;
end sub;

sub arch_gen_beginning_of_instruction()
    locked_registers := 0;
end sub;

sub arch_init_codegen()
    zero_memory(&values[0] as [int8], values@bytes);
end sub;

sub write_back_precious_value(location: uint8, ea: [EffectiveAddress])
    location := find_first_bit(location);
    print("* writing back 0x");
    print_hex_i8(location);
    print(" to precious value ");
    print_ea(ea);
    print_newline();

    if ea.type == EA_OBJVAL then
        save_objval(location, ea);
    else
        print("can't write precious value ");
        print_ea(ea);
        print(" yet");
        halt();
    end if;
end sub;

sub write_back_precious_values(mask: uint8)
    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        var locations: uint8 := value.locations;
        if (locations & mask) != 0 then
            if (locations & PRECIOUS) != 0 then
                locations := locations - PRECIOUS;
                write_back_precious_value(locations, &value.ea);
                value.locations := locations;
            end if;
        end if;
        i := i + 1;
    end loop;
end sub;

sub find_unused_regs(candidates: uint8): (mask: uint8)
    var i: uint8 := 0;
    while i < values@size loop
        candidates := candidates & (values[i].locations ^ 0xff);
        i := i + 1;
    end loop;
    mask := candidates & REG_MASK;
end sub;

sub allocate_reg(candidates: uint8): (mask: uint8)
    candidates := candidates & (locked_registers ^ 0xff);
    mask := find_unused_regs(candidates);
    if mask == 0 then
        mask := candidates;
        if mask == 0 then
            print_cache();
            print("locked register bitmask: 0x");
            print_hex_i8(locked_registers);
            print_newline();
            print("no available registers");
            halt();
        end if;
    end if;
    mask := find_first_bit(mask);
    write_back_precious_values(mask);
    locked_registers := locked_registers | mask;
    print("* allocating 0x");
    print_hex_i8(mask);
    print_newline();
end sub;

sub free_reg(mask: uint8)
    locked_registers := locked_registers & (mask ^ REG_MASK);
end sub;

sub allocate_fixed_reg(candidates: uint8)
    var location: uint8 := allocate_reg(candidates);
end sub;

sub find_regs_with_value(ea: [EffectiveAddress], candidates: uint8): (locations: uint8)
    var index: uint8 := 0;
    while index < values@size loop
        var value: [CachedValue] := &values[index];
        locations := value.locations & candidates & REG_MASK;
        if (locations != 0) and (is_same_ea(&value.ea, ea) != 0) then
            locations := value.locations & REG_MASK;
            print("* found in 0x");
            print_hex_i8(locations);
            print(" value ");
            print_ea(ea);
            print_newline();
            return;
        end if;
        index := index + 1;
    end loop;
    locations := 0;
    print("* did not find value ");
    print_ea(ea);
    print(" in any register\n");
end sub;

sub find_reg_with_value(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := find_regs_with_value(ea, candidates);
    if location != 0 then
        location := find_first_bit(location);
    end if;
end sub;

sub value_is_cached_in_reg(ea: [EffectiveAddress], locations: uint8)
    var i: uint8;
    var value: [CachedValue];

    sub msg()
        print("* remembering that ");
        print_ea(ea);
        print(" is also in 0x");
        print_i8(locations);
        print_newline();
    end sub;

    # Look for a cache slot already containing this value.
    i := 0;
    while i < values@size loop
        value := &values[i];

        if is_same_ea(&value.ea, ea) != 0 then
            value.locations := value.locations | locations;
            msg();
            return;
        end if;
        i := i + 1;
    end loop;

    # Not found --- find an empty cache slot and use that.
    i := 0;
    while i < values@size loop
        value := &values[i];

        if value.locations == 0 then
            value.locations := locations;
            copy_ea(ea, &value.ea);
            msg();
            return;
        end if;
        i := i + 1;
    end loop;

    print("can't cache, value cache is full");
    halt();
end sub;

sub move_value_to_reg(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    print("* hunting for ");
    print_ea(ea);
    print(" in 0x");
    print_hex_i8(candidates);
    print_newline();

    location := find_reg_with_value(ea, candidates);
    if location != 0 then
        locked_registers := locked_registers | location;
        return;
    end if;

    location := find_reg_with_value(ea, REG_A|REG_X|REG_Y);
    if location == 0 then
        return;
    end if;

    var oldlocation: uint8 := location;
    location := allocate_reg(candidates);

    # Special case: can't move from X to Y or vice versa.
    if (oldlocation|location) == (REG_X|REG_Y) then
        free_reg(location);
        location := 0;
        return;
    end if;

    print("* moving value ");
    print_ea(ea);
    print(" from 0x");
    print_hex_i8(oldlocation);
    print(" to ");
    print_hex_i8(location);
    print_newline();

    var opcode: uint8 := 0;
    if location == REG_A then
        if oldlocation == REG_X then
            opcode := 0x8A; # TXA
        elseif oldlocation == REG_Y then
            opcode := 0x98; # TYA
        end if;
    elseif location == REG_X then
        if oldlocation == REG_A then
            opcode := 0xAA; # TAX
        end if;
    elseif location == REG_Y then
        if oldlocation == REG_A then
            opcode := 0xA8; # TAY
        end if;
    end if;
    if opcode == 0 then
        print("bad move");
        halt();
    end if;

    write_byte(opcode);
    value_is_cached_in_reg(ea, location);
end sub;

sub value_is_precious(ea: [EffectiveAddress])
    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        if value.locations != 0 then
            if is_same_ea(ea, &value.ea) != 0 then
                if (value.locations & PRECIOUS) == 0 then
                    print("* remembering that value ");
                    print_ea(ea);
                    print(" is precious in 0x");
                    print_i8(value.locations);
                    print_newline();
                    value.locations := value.locations | PRECIOUS;
                    return;
                end if;
            end if;
        end if;
        i := i + 1;
    end loop;
    print("can't make precious, value cache is full");
    halt();
end sub;

# The contents of location are about to be replaced with a new value. If any values there
# are precious, they get written back --- except for the new value, if it's there.
# Any cached values in that location get flushed. This allows mutation of values without
# triggering writeback.
sub value_in_location_will_be_replaced_with(location: uint8, newvalue: [EffectiveAddress])
    print("* replacing value in 0x");
    print_hex_i8(location);
    print(" with ");
    print_ea(newvalue);
    print_newline();

    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        if (value.locations & location) != 0 then
            if ((value.locations & PRECIOUS) != 0) and (is_same_ea(&value.ea, newvalue) == 0) then
                write_back_precious_value(location, &value.ea);
            end if;
            value.locations := value.locations & (REG_MASK ^ location);
        end if;
        i := i + 1;
    end loop;
end sub;

sub flush_cached_values(mask: uint8)
    write_back_precious_values(mask);

    print("* flushing cached values in 0x");
    print_hex_i8(mask);
    print_newline();

    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        value.locations := value.locations & (REG_MASK ^ mask);
        i := i + 1;
    end loop;
end sub;

sub allocate_reg_for_value(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := allocate_reg(candidates);
    flush_cached_values(location);
    value_is_cached_in_reg(ea, location);
end sub;

sub find_or_load_objval(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := move_value_to_reg(ea, candidates);
    if location != 0 then
        return;
    end if;
    location := allocate_reg_for_value(ea, candidates);

    load_objval(location, ea);
end sub;

# Loads *just the index part* of the EA into Y.
sub find_or_load_index_into_y(ea: [EffectiveAddress])
    var indexea: EffectiveAddress;
    indexea.type := EA_OBJVAL;
    indexea.varoff_id := 0;
    indexea.numoff_id := 0;
    if ea.varoff_id != 0 then
        indexea.obj_id := ea.varoff_id;
    else
        indexea.obj_id := ea.numoff_id;
        if indexea.obj_id == 0 then
            indexea.obj_id := add_number_by_value(0);
        end if;
    end if;

    var location: uint8 := find_or_load_objval(&indexea, REG_Y);
end sub;

sub find_or_load_ptrval(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := move_value_to_reg(ea, candidates);
    if location != 0 then
        return;
    end if;

    find_or_load_index_into_y(ea);
    location := allocate_reg_for_value(ea, REG_A);

    write_byte(0xB1); # LDA (zp), Y
    write_cg_6502_zeropage_iop(ea.obj_id, 0);
end sub;

sub save_ptrval(location: uint8, ea: [EffectiveAddress])
    find_or_load_index_into_y(ea);
    ea.numoff_id := 0;
    st_ind(location, REG_Y, ea);
    free_reg(REG_Y);
end sub;

sub find_or_load_value(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    if ea.type == EA_OBJVAL then
        location := find_or_load_objval(ea, candidates);
    elseif ea.type == EA_PTRVAL then
        location := find_or_load_ptrval(ea, candidates);
    else
        print("can't load ");
        print_ea(ea);
        print(" yet");
        halt();
    end if;
end sub;

sub find_or_load_int(value: uint8, candidates: uint8): (location: uint8)
    var ea: EffectiveAddress;
    ea.type := EA_OBJVAL;
    ea.obj_id := add_number_by_value(value);
    ea.numoff_id := 0;
    ea.varoff_id := 0;
    location := find_or_load_value(&ea, candidates);
end sub;

sub find_or_load_fixed_int(value: uint8, candidates: uint8)
    var location: uint8 := find_or_load_int(value, candidates);
end sub;

sub find_or_load_value_with_flags(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    var oldlocation: uint8 := find_reg_with_value(ea, candidates);
    location := find_or_load_value(ea, candidates);
    if oldlocation != location then
        # The value was forced from memory, so the flags are set automatically.
    else
        write_byte(0x09); # ORA imm
        write_byte(0x00);
    end if;
end sub;

sub find_or_load_fixed_value_with_flags(ea: [EffectiveAddress], candidates: uint8)
    var location: uint8 := find_or_load_value_with_flags(ea, candidates);
end sub;

sub save_value(location: uint8, ea: [EffectiveAddress])
    if ea.type == EA_OBJVAL then
        save_objval(location, ea);
    elseif ea.type == EA_PTRVAL then
        save_ptrval(location, ea);
    else
        print("can't save ");
        print_ea(ea);
        print(" yet");
        halt();
    end if;
end sub;

sub arch_gen_return()
    flush_cached_values(REG_MASK);
    write_byte(0x60); # RTS
end sub;

sub arch_gen_call(thing_id: uint16)
    flush_cached_values(REG_MASK);
    write_byte(0x20); # JSR
    write_address_iop(thing_id, 0);
end sub;

sub arch_gen_label()
    flush_cached_values(REG_MASK);
end sub;

sub arch_gen_goto(thing_id: uint16)
    flush_cached_values(REG_MASK);
    write_byte(0x4C); # JMP abs
    write_address_iop(thing_id, 0);
end sub;

sub make_value_precious_or_save_now(location: uint8, ea: [EffectiveAddress])
    value_is_cached_in_reg(ea, location);
    if (ea.type & EA_DEREF_BEFORE) != 0 then
        print("* value ");
        print_ea(ea);
        print(" can't be made precious, saving now\n");
        save_value(location, ea);
    else
        value_is_precious(ea);
    end if;
end sub;

sub save_value_with_index_or_offset(location: uint8, ea: [EffectiveAddress], offset: uint8)
    if ea.type == EA_OBJVAL then
        save_objval_with_offset(location, ea, offset);
    elseif ea.type == EA_PTRVAL then
        find_or_load_fixed_int(offset, REG_Y);
        st_ind(location, REG_Y, ea);
        free_reg(REG_Y);
    else
        print("can't save ");
        print_ea(ea);
        print(" with offset 0x");
        print_hex_i8(offset);
        print(" yet");
        halt();
    end if;
end sub;

sub arch_gen_copy_byte(iop: [BEIop])
    var location: uint8 := find_or_load_value(&iop.left, REG_A|REG_X|REG_Y);
    make_value_precious_or_save_now(location, &iop.dest);
end sub;

sub gen_regular_alu(iop: [BEIop], opcode: uint8)
    var location: uint8 := find_or_load_value(&iop.left, REG_A);
    value_in_location_will_be_replaced_with(location, &iop.dest);

    if iop.right.type == EA_OBJVAL then
        # do nothing, the opcode is already right
    else
        print("can't add ");
        print_ea(&iop.right);
        print(" yet");
        print_newline();
    end if;

    write_6502_regular_op(opcode, &iop.right);

    make_value_precious_or_save_now(location, &iop.dest);
end sub;

sub gen_incdec(iop: [BEIop], value: int8)
    var location: uint8 := find_or_load_value(&iop.left, REG_X|REG_Y);
    value_in_location_will_be_replaced_with(location, &iop.dest);

    var opcode: uint8;
    if value == 1 then
        if location == REG_X then
            opcode := 0xE8; # INX
        else
            opcode := 0xC8; # INY
        end if;
    else
        if location == REG_X then
            opcode := 0xCA; # INX
        else
            opcode := 0x88; # INY
        end if;
    end if;
    write_byte(opcode);

    make_value_precious_or_save_now(location, &iop.dest);
end sub;

sub arch_gen_add_byte(iop: [BEIop])
    var location: uint8;
    var opcode: uint8;

    if is_number_thing(iop.right.obj_id) != 0 then
        var value: int32 := get_value_of_number(iop.right.obj_id);
        if (value == 1) or (value == -1) then
            gen_incdec(iop, value);
            return;
        end if;
    end if;

    write_byte(0x18); # CLC
    gen_regular_alu(iop, 0x6D); # ADC abs
end sub;

sub arch_gen_sub_byte(iop: [BEIop])
    var location: uint8;
    var opcode: uint8;

    if is_number_thing(iop.right.obj_id) != 0 then
        var value: int32 := get_value_of_number(iop.right.obj_id);
        if (value == 1) or (value == -1) then
            gen_incdec(iop, 0-value);
            return;
        end if;
    end if;

    write_byte(0x18); # CLC
    gen_regular_alu(iop, 0xED); # SBC abs
end sub;

sub arch_gen_copy_word(iop: [BEIop])
    if is_number_thing(iop.left.obj_id) != 0 then
        var value: int32 := get_value_of_number(iop.left.obj_id);
        var candidates: uint8;
        if iop.dest.type == EA_PTRVAL then
            candidates := REG_A;
        else
            candidates := REG_A|REG_X;
        end if;

        var location: uint8 := find_or_load_int(value, candidates);
        save_value_with_index_or_offset(location, &iop.dest, 0);
        free_reg(location);
        location := find_or_load_int(value >> 8, candidates);
        save_value_with_index_or_offset(location, &iop.dest, 1);
    else
        find_or_load_fixed_int(1, REG_Y);
        allocate_fixed_reg(REG_A);

        var label: uint16 := create_label();
        write_label_iop(label);
        load_value_with_index(REG_A, &iop.left, REG_Y);
        save_value_with_index(REG_A, &iop.dest, REG_Y);
        write_byte(0x88); # DEY
        write_cg_6502_conditional_iop(0x30, label); # BMI

        flush_cached_values(REG_Y);
    end if;
end sub;

sub arch_gen_sext_word(iop: [BEIop])
    find_or_load_fixed_int(0, REG_X);

    find_or_load_fixed_value_with_flags(&iop.left, REG_A);
    write_byte(0x10); # BPL rel
    write_byte(0x01); # skip one byte
    write_byte(0xCA); # DEX

    save_value_with_offset(REG_A, &iop.dest, 0);
    save_value_with_offset(REG_X, &iop.dest, 1);
end sub;

sub arch_gen_zext_word(iop: [BEIop])
    var location: uint8 := find_or_load_value(&iop.left, REG_A|REG_X|REG_Y);
    save_value_with_offset(location, &iop.dest, 0);

    location := find_or_load_int(0, REG_A|REG_X|REG_Y);
    save_value_with_offset(location, &iop.dest, 1);
end sub;
