
%{
	#include "globals.h"
	#include "emitter.h"
	#include "midcodes.h"
	#include "compiler.h"
	#include "parser.h"
	#include <bsd/string.h>
	#include <ctype.h>

	#define IMPL
	#include "codegen.h"

	#define E emitter_printf
	static char asmbuffer[160];

	static int id = 1;
	static Symbol* int8_type;
	static Symbol* int16_type;
	static Symbol* uint16_type;
	static Symbol* int32_type;
	static Symbol* uint32_type;
	static Symbol* int64_type;
	static Symbol* uint64_type;

	#define VARSTACK_SIZE 32
	static int varstack[VARSTACK_SIZE];
	static int varsp;

	void arch_init_types(void)
	{
		uint64_type = make_number_type("uint64", 8, false);
		int64_type = make_number_type("int64", 8, true);
		uint32_type = make_number_type("uint32", 4, false);
		int32_type = make_number_type("int32", 4, true);
		uint16_type = make_number_type("uint16", 2, false);
		int16_type = make_number_type("int16", 2, true);
		uint8_type = make_number_type("uint8", 1, false);
		int8_type = make_number_type("int8", 1, true);

		intptr_type = uint64_type;
		add_alias(NULL, "intptr", intptr_type);
	}

	uint32_t arch_align_up(uint32_t i, uint8_t w)
	{
		return (i+w-1) & ~(w-1);
	}

	Symbol* arch_guess_int_type(uint32_t min, uint32_t max)
	{
		if ((min >= 0) && (max <= 255))
			return uint8_type;
		if ((min >= -128) && (max <= 127))
			return int8_type;
		if ((min >= 0) && (max <= 65535))
			return uint16_type;
		if ((min >= -32768) && (max <= 32767))
			return int16_type;
		if (min >= 0)
			return uint32_type;
		return int32_type;
	}

	void arch_init_subroutine(struct subroutine* sub) {}

	void arch_init_variable(struct symbol* var)
	{
		/* All variables get allocated from workspace 0. */

		int w = var->u.var.type->u.type.width;
		current_sub->workspace[0] = arch_align_up(current_sub->workspace[0], w);
		var->u.var.offset = current_sub->workspace[0];
		current_sub->workspace[0] += w;
	}

	void arch_init_member(struct symbol* record, struct symbol* member, int position)
	{
		if (position == -1)
			position = arch_align_up(record->u.type.width, member->u.var.type->u.type.alignment);
		member->u.var.offset = position;
		position += member->u.var.type->u.type.width;
		if (position > record->u.type.width)
			record->u.type.width = position;
	}

	static const char* subref(Subroutine* sub)
	{
		if (sub->externname)
			return sub->externname;
		
		static char buffer[32];
		snprintf(buffer, sizeof(buffer), "f%d", sub->id);
		return buffer;
	}

	static const char* symref(Symbol* sym, int32_t off)
	{
		static char buffer[32];
		if (sym->u.var.externname)
		{
			snprintf(buffer, sizeof(buffer), "(((i1*)%s)+%d)",
				sym->u.var.externname, off);
		}
		else
		{
			emitter_open_chunk();
			E("static i1 w%d[];\n", sym->u.var.sub->id);
			emitter_close_chunk(NULL);

			snprintf(buffer, sizeof(buffer), "w%d%+d",
				sym->u.var.sub->id,
				sym->u.var.offset + off);
		}
		return buffer;
	}

	static const char* labelref(int label)
	{
		static char buffer[32];
		snprintf(buffer, sizeof(buffer), "x%d", label);
		return buffer;
	}

	/* Note! This is allowed to destroy the source register. */
	void arch_emit_move(reg_t src, reg_t dest)
	{ assert(false); }

	void arch_emit_comment(const char* text, ...)
	{
		va_list ap;
		va_start(ap, text);
		emitter_printf("// ");
		emitter_vprintf(text, ap);
		emitter_printf("\n");
		va_end(ap);
	}

	static bool is_current_sub(Symbol* sym)
	{
		return sym->u.var.sub == current_sub;
	}

	static int push(void)
	{
		int vid = id++;
		if (varsp == VARSTACK_SIZE)
			fatal("varstack overflow");
		varstack[varsp++] = vid;
		return vid;
	}

	static int pop(void)
	{
		if (varsp == 0)
			fatal("vstack underflow");
		return varstack[--varsp];
	}

%}

register v1 v2 v4 v8 param;

regdata v1 stacked;
regdata v2 stacked;
regdata v4 stacked;
regdata v8 stacked;
regdata param stacked;

gen STARTFILE()
{
    emitter_open_chunk();
	E("#include \"cowgol-cgen.h\"\n");
    emitter_close_chunk(NULL);
}

gen ENDFILE();

gen STARTSUB():s
{
    emitter_open_chunk();
    E("\n");
    E("// %s\n", $s.sub->name);
	E("void %s(", subref($s.sub));

	bool first = true;
	for (int i=$s.sub->inputparameters-1; i>=0; i--)
	{
		Symbol* param = get_input_parameter($s.sub, i);

		if (!first)
			E(", ");
		first = false;

		E("i%d iparam%d", param->u.var.type->u.type.width, param->u.var.offset);
	}

	for (int i=0; i<$s.sub->outputparameters; i++)
	{
		struct symbol* param = get_output_parameter($s.sub, i);

		if (!first)
			E(", ");
		first = false;

		E("i%d* oparam%d", param->u.var.type->u.type.width, param->u.var.offset);
	}
	if (($s.sub->inputparameters == 0) && ($s.sub->outputparameters == 0))
		E("void");
	E(") {\n");

	for (int i=0; i<$s.sub->inputparameters; i++)
	{
		Symbol* param = get_input_parameter($s.sub, i);

		E("\t*(i%d*)(intptr_t)(%s) = iparam%d;\n",
			param->u.var.type->u.type.width,
			symref(param, 0),
			param->u.var.offset);
	}
}

gen ENDSUB():s
{
	E("end:;\n");
	for (int i=0; i<$s.sub->outputparameters; i++)
	{
		struct symbol* param = get_output_parameter($s.sub, i);

		E("\t*oparam%d = *(i%d*)(intptr_t)(%s);\n",
			param->u.var.offset,
			param->u.var.type->u.type.width,
			symref(param, 0));
	}
	E("}\n");
	E("static i1 w%d[%d];\n", $s.sub->id, $s.sub->workspace[0]);
    emitter_close_chunk(current_sub);
}

// --- Control flow ------------------------------------------------------

gen RETURN()
{
	E("\tgoto end;\n");
}

gen LABEL():b
{
	E("%s:;\n", labelref($b.label));
}

gen JUMP():j
{
	E("\tgoto %s;\n", labelref($j.label));
}

// --- Subroutines -------------------------------------------------------

// SETPARAM leaves the parameter on the top of the stack, where the
// code generator loses track of it.

gen param := END();

gen param := PUSHPARAM1(param, v1:val);
gen param := PUSHPARAM2(param, v2:val);
gen param := PUSHPARAM4(param, v4:val);
gen param := PUSHPARAM8(param, v8:val);

%{
	static void call(Subroutine* sub)
	{
		arch_emit_comment("subroutine with %d input and %d output parameters",
			sub->inputparameters, sub->outputparameters);

		for (int i=0; i<sub->outputparameters; i++)
		{
			struct symbol* param = sub->namespace.firstsymbol;
			for (int j=0; j<(i + sub->inputparameters); j++)
				param = param->next;

			E("\ti%d v%d;\n", param->u.var.type->u.type.width, id+i);
		}

		E("\t%s(", subref(sub));

		bool first = true;
		for (int i=0; i<sub->inputparameters; i++)
		{
			if (!first)
				E(", ");
			first = false;

			E("v%d", pop());
		}
		for (int i=0; i<sub->outputparameters; i++)
		{
			if (!first)
				E(", ");
			first = false;

			E("&v%d", push());
		}

		E(");\n");
	}
%}

gen CALLS(param);

gen param := CALL0(param):c
	{ call($c.sub); }

gen v1 := CALL1(param):c
	{ call($c.sub); }

gen v2 := CALL2(param):c
	{ call($c.sub); }

gen v4 := CALL4(param):c
	{ call($c.sub); }

gen v8 := CALL8(param):c
	{ call($c.sub); }

%{
	static void popparam(int width, Symbol* sym, int off)
	{
		E("\t*(i%d*)(intptr_t)(%s) = v%d;\n", width, symref(sym, off), pop());
	}
%}

gen POPPARAM1(param, ADDRESS():a)
	{ popparam(1, $a.sym, $a.off); }

gen param := POPPARAM1(param, ADDRESS():a)
	{ popparam(1, $a.sym, $a.off); }

gen POPPARAM2(param, ADDRESS():a)
	{ popparam(2, $a.sym, $a.off); }

gen param := POPPARAM2(param, ADDRESS():a)
	{ popparam(2, $a.sym, $a.off); }

gen POPPARAM4(param, ADDRESS():a)
	{ popparam(4, $a.sym, $a.off); }

gen param := POPPARAM4(param, ADDRESS():a)
	{ popparam(4, $a.sym, $a.off); }

gen POPPARAM8(param, ADDRESS():a)
	{ popparam(8, $a.sym, $a.off); }

gen param := POPPARAM8(param, ADDRESS():a)
	{ popparam(8, $a.sym, $a.off); }

// --- Core conversions --------------------------------------------------

gen v1 := CONSTANT():c
	{ E("\ti1 v%d = (i1)%d;\n", push(), $c.value); }

gen v2 := CONSTANT():c
	{ E("\ti2 v%d = (i2)%d;\n", push(), $c.value); }

gen v4 := CONSTANT():c
	{ E("\ti4 v%d = (i4)%d;\n", push(), $c.value); }

gen v8 := CONSTANT():c
	{ E("\ti8 v%d = (i8)%d;\n", push(), $c.value); }

gen v8 := ADDRESS():a
	{ E("\ti8 v%d = (i8)(intptr_t)(%s);\n", push(), symref($a.sym, $a.off)); }

// --- Loads and stores --------------------------------------------------

%{
	static void store_vv(int width)
	{
		int addrid = pop();
		int valid = pop();
		E("\t*(i%d*)(intptr_t)v%d = v%d;\n", width, addrid, valid);
	}

	static void store_va(int width, Symbol* sym, int off)
	{
		int valid = pop();
		E("\t*(i%d*)(intptr_t)(%s) = v%d;\n", width, symref(sym, off), valid);
	}
%}

gen STORE1(v1:val, v8:addr) { store_vv(1); }
gen STORE2(v2:val, v8:addr) { store_vv(2); }
gen STORE4(v4:val, v8:addr) { store_vv(4); }
gen STORE8(v8:val, v8:addr) { store_vv(8); }
gen STORE1(v1:val, ADDRESS():a) { store_va(1, $a.sym, $a.off); }
gen STORE2(v2:val, ADDRESS():a) { store_va(2, $a.sym, $a.off); }
gen STORE4(v4:val, ADDRESS():a) { store_va(4, $a.sym, $a.off); }
gen STORE8(v8:val, ADDRESS():a) { store_va(8, $a.sym, $a.off); }

%{
	static void load_v(int width)
	{
		int addrid = pop();
		E("\ti%d v%d = *(i%d*)(intptr_t)v%d;\n", width, push(), width, addrid);
	}

	static void load_a(int width, Symbol* sym, int off)
	{
		E("\ti%d v%d = *(i%d*)(intptr_t)(%s);\n", width, push(), width, symref(sym, off));
	}
%}

gen v1 := LOAD1(v8:addr) { load_v(1); }
gen v2 := LOAD2(v8:addr) { load_v(2); }
gen v4 := LOAD4(v8:addr) { load_v(4); }
gen v8 := LOAD8(v8:addr) { load_v(8); }
gen v1 := LOAD1(ADDRESS():a) { load_a(1, $a.sym, $a.off); }
gen v2 := LOAD2(ADDRESS():a) { load_a(2, $a.sym, $a.off); }
gen v4 := LOAD4(ADDRESS():a) { load_a(4, $a.sym, $a.off); }
gen v8 := LOAD8(ADDRESS():a) { load_a(8, $a.sym, $a.off); }

// --- Simple arithmetic ----------------------------------------------------

%{
	static void op2_vv(int width, const char* op)
	{
		int rhsid = pop();
		int lhsid = pop();
		E("\ti%d v%d = v%d %s v%d;\n", width, push(), lhsid, op, rhsid);
	}

	static void op2_vv_signed(int width, const char* op)
	{
		int rhsid = pop();
		int lhsid = pop();
		E("\ti%d v%d = (s%d)v%d %s (s%d)v%d;\n", width, push(), width, lhsid, op, width, rhsid);
	}
%}

gen v1 := ADD1(v1:lhs, v1:rhs) { op2_vv(1, "+"); }
gen v2 := ADD2(v2:lhs, v2:rhs) { op2_vv(2, "+"); }
gen v4 := ADD4(v4:lhs, v4:rhs) { op2_vv(4, "+"); }
gen v8 := ADD8(v8:lhs, v8:rhs) { op2_vv(8, "+"); }

gen v1 := SUB1(v1:lhs, v1:rhs) { op2_vv(1, "-"); }
gen v2 := SUB2(v2:lhs, v2:rhs) { op2_vv(2, "-"); }
gen v4 := SUB4(v4:lhs, v4:rhs) { op2_vv(4, "-"); }
gen v8 := SUB8(v8:lhs, v8:rhs) { op2_vv(8, "-"); }

gen v1 := MUL1(v1:lhs, v1:rhs) { op2_vv(1, "*"); }
gen v2 := MUL2(v2:lhs, v2:rhs) { op2_vv(2, "*"); }
gen v4 := MUL4(v4:lhs, v4:rhs) { op2_vv(4, "*"); }
gen v8 := MUL8(v8:lhs, v8:rhs) { op2_vv(8, "*"); }

gen v1 := DIVU1(v1:lhs, v1:rhs) { op2_vv(1, "/"); }
gen v2 := DIVU2(v2:lhs, v2:rhs) { op2_vv(2, "/"); }
gen v4 := DIVU4(v4:lhs, v4:rhs) { op2_vv(4, "/"); }
gen v8 := DIVU8(v8:lhs, v8:rhs) { op2_vv(8, "/"); }

gen v1 := REMU1(v1:lhs, v1:rhs) { op2_vv(1, "%"); }
gen v2 := REMU2(v2:lhs, v2:rhs) { op2_vv(2, "%"); }
gen v4 := REMU4(v4:lhs, v4:rhs) { op2_vv(4, "%"); }
gen v8 := REMU8(v8:lhs, v8:rhs) { op2_vv(8, "%"); }

gen v1 := DIVS1(v1:lhs, v1:rhs) { op2_vv_signed(1, "/"); }
gen v2 := DIVS2(v2:lhs, v2:rhs) { op2_vv_signed(2, "/"); }
gen v4 := DIVS4(v4:lhs, v4:rhs) { op2_vv_signed(4, "/"); }
gen v8 := DIVS8(v8:lhs, v8:rhs) { op2_vv_signed(8, "/"); }

gen v1 := REMS1(v1:lhs, v1:rhs) { op2_vv_signed(1, "%"); }
gen v2 := REMS2(v2:lhs, v2:rhs) { op2_vv_signed(2, "%"); }
gen v4 := REMS4(v4:lhs, v4:rhs) { op2_vv_signed(4, "%"); }
gen v8 := REMS8(v8:lhs, v8:rhs) { op2_vv_signed(8, "%"); }

gen v1 := AND1(v1:lhs, v1:rhs) { op2_vv(1, "&"); }
gen v2 := AND2(v2:lhs, v2:rhs) { op2_vv(2, "&"); }
gen v4 := AND4(v4:lhs, v4:rhs) { op2_vv(4, "&"); }
gen v8 := AND8(v8:lhs, v8:rhs) { op2_vv(8, "&"); }

gen v1 := OR1(v1:lhs, v1:rhs) { op2_vv(1, "|"); }
gen v2 := OR2(v2:lhs, v2:rhs) { op2_vv(2, "|"); }
gen v4 := OR4(v4:lhs, v4:rhs) { op2_vv(4, "|"); }
gen v8 := OR8(v8:lhs, v8:rhs) { op2_vv(8, "|"); }

gen v1 := EOR1(v1:lhs, v1:rhs) { op2_vv(1, "^"); }
gen v2 := EOR2(v2:lhs, v2:rhs) { op2_vv(2, "^"); }
gen v4 := EOR4(v4:lhs, v4:rhs) { op2_vv(4, "^"); }
gen v8 := EOR8(v8:lhs, v8:rhs) { op2_vv(8, "^"); }

%{
	static void op1_v(int width, const char* op)
	{
		int vid = pop();
		E("\ti%d v%d = %s v%d;\n", width, push(), op, vid);
	}
%}

gen v1 := NEG1(v1) { op1_v(1, "-"); }
gen v2 := NEG2(v2) { op1_v(2, "-"); }
gen v4 := NEG4(v4) { op1_v(4, "-"); }
gen v8 := NEG8(v8) { op1_v(8, "-"); }

gen v1 := NOT1(v1) { op1_v(1, "~"); }
gen v2 := NOT2(v2) { op1_v(2, "~"); }
gen v4 := NOT4(v4) { op1_v(4, "~"); }
gen v8 := NOT8(v8) { op1_v(8, "~"); }

// --- Shifts ---------------------------------------------------------------

%{
	static void shift(int width, const char* type, const char* op)
	{
		int rhsid = pop();
		int lhsid = pop();
		E("\ti%d v%d = ((%s)v%d) %s v%d;\n", width, push(), type, lhsid, op, rhsid);
	}
%}

gen v1 := LSHIFT1(v1, v1) { shift(1, "i1", "<<"); }
gen v2 := LSHIFT2(v2, v1) { shift(2, "i2", "<<"); }
gen v4 := LSHIFT4(v4, v1) { shift(4, "i4", "<<"); }
gen v8 := LSHIFT8(v8, v1) { shift(8, "i8", "<<"); }
gen v1 := RSHIFTU1(v1, v1) { shift(1, "i1", ">>"); }
gen v2 := RSHIFTU2(v2, v1) { shift(2, "i2", ">>"); }
gen v4 := RSHIFTU4(v4, v1) { shift(4, "i4", ">>"); }
gen v8 := RSHIFTU8(v8, v1) { shift(8, "i8", ">>"); }
gen v1 := RSHIFTS1(v1, v1) { shift(1, "s1", ">>"); }
gen v2 := RSHIFTS2(v2, v1) { shift(2, "s2", ">>"); }
gen v4 := RSHIFTS4(v4, v1) { shift(4, "s4", ">>"); }
gen v8 := RSHIFTS8(v8, v1) { shift(8, "s8", ">>"); }

//rewrite NOT1(lhs) := NOT4(lhs);

// --- Branches -------------------------------------------------------------

%{
	static void branch_u(int truelabel, int falselabel, const char* op)
	{
		int rhsid = pop();
		int lhsid = pop();
		E("\tif (v%d %s v%d) goto %s; ", lhsid, op, rhsid, labelref(truelabel));
		E("else goto %s;\n", labelref(falselabel));
	}

	static void branch_s(int truelabel, int falselabel, int width, const char* op)
	{
		int rhsid = pop();
		int lhsid = pop();
		E("\tif ((s%d)v%d %s (s%d)v%d) goto %s; ", width, lhsid, op, width, rhsid, labelref(truelabel));
		E("else goto %s;\n", labelref(falselabel));
	}
%}

gen BEQU1(v1:lhs, v1:rhs):b
	{ branch_u($b.truelabel, $b.falselabel, "=="); }

gen BEQS1(v1:lhs, v1:rhs):b
	{ branch_u($b.truelabel, $b.falselabel, "=="); }

gen BEQU2(v2:lhs, v2:rhs):b
	{ branch_u($b.truelabel, $b.falselabel, "=="); }

gen BEQS2(v2:lhs, v2:rhs):b
	{ branch_u($b.truelabel, $b.falselabel, "=="); }

gen BEQU4(v4:lhs, v4:rhs):b
	{ branch_u($b.truelabel, $b.falselabel, "=="); }

gen BEQS4(v4:lhs, v4:rhs):b
	{ branch_u($b.truelabel, $b.falselabel, "=="); }

gen BEQU8(v8:lhs, v8:rhs):b
	{ branch_u($b.truelabel, $b.falselabel, "=="); }

gen BEQS8(v8:lhs, v8:rhs):b
	{ branch_u($b.truelabel, $b.falselabel, "=="); }

gen BLTU1(v1:lhs, v1:rhs):b
	{ branch_u($b.truelabel, $b.falselabel, "<"); }

gen BLTS1(v1:lhs, v1:rhs):b
	{ branch_s($b.truelabel, $b.falselabel, 1, "<"); }

gen BLTU2(v2:lhs, v2:rhs):b
	{ branch_u($b.truelabel, $b.falselabel, "<"); }

gen BLTS2(v2:lhs, v2:rhs):b
	{ branch_s($b.truelabel, $b.falselabel, 2, "<"); }

gen BLTU4(v4:lhs, v4:rhs):b
	{ branch_u($b.truelabel, $b.falselabel, "<"); }

gen BLTS4(v4:lhs, v4:rhs):b
	{ branch_s($b.truelabel, $b.falselabel, 4, "<"); }

gen BLTU8(v8:lhs, v8:rhs):b
	{ branch_u($b.truelabel, $b.falselabel, "<"); }

gen BLTS8(v8:lhs, v8:rhs):b
	{ branch_s($b.truelabel, $b.falselabel, 8, "<"); }

// --- Casts ----------------------------------------------------------------

%{
	static void cast(int src, int dest, bool sext)
	{
		int vid = pop();
		if (sext)
			E("\ti%d v%d = (s%d)(s%d)v%d;\n", dest, push(), dest, src, vid);
		else
			E("\ti%d v%d = v%d;\n", dest, push(), vid);
	}
%}

gen v2 := CAST12(v1):c { cast(1, 2, $c.sext); }
gen v4 := CAST14(v1):c { cast(1, 4, $c.sext); }
gen v8 := CAST18(v1):c { cast(1, 8, $c.sext); }
gen v1 := CAST21(v2):c { cast(2, 1, $c.sext); }
gen v4 := CAST24(v2):c { cast(2, 4, $c.sext); }
gen v8 := CAST28(v2):c { cast(2, 8, $c.sext); }
gen v1 := CAST41(v4):c { cast(4, 1, $c.sext); }
gen v2 := CAST42(v4):c { cast(4, 2, $c.sext); }
gen v8 := CAST48(v4):c { cast(4, 8, $c.sext); }
gen v1 := CAST81(v8):c { cast(8, 1, $c.sext); }
gen v2 := CAST82(v8):c { cast(8, 2, $c.sext); }
gen v4 := CAST84(v8):c { cast(8, 4, $c.sext); }

// --- Case statements ---------------------------------------------------

%{
	static void docase(Instruction* self, const char* format, uint32_t mask)
	{
		E("\tswitch (v%d) {\n", pop());

		Node* n = self->n[0]->right;
		while (n->op == MIDCODE_WHEN)
		{
			if (n->u.when.isdefault)
				E("\t\tdefault");
			else
			{
				E("\t\tcase ");
				E(format, n->u.when.value & mask);
			}
			E(": goto %s;\n", labelref(n->u.when.label));
			n = n->left;
		}

		E("\t}\n");
	}
%}

gen CASE1(v1, param)
	{ docase(self, "0x%02x", 0xff); }

gen CASE2(v2, param)
	{ docase(self, "0x%04x", 0xffff); }

gen CASE4(v4, param)
	{ docase(self, "0x%08x", 0xffffffff); }

gen param := WHEN(param);

// --- Inline assembly ------------------------------------------------------

gen ASMSTART()
{
    asmbuffer[0] = '\0';
}

gen ASMTEXT():t
{
    strlcat(asmbuffer, $t.text, sizeof(asmbuffer));
    strlcat(asmbuffer, " ", sizeof(asmbuffer));
}

gen ASMSYMBOL():s
{
	if ($s.sym->kind == VAR)
	{
		int w = strlen(asmbuffer);
		snprintf(asmbuffer+w, sizeof(asmbuffer)-w,
			"*(i%d*)(intptr_t)(%s)",
			$s.sym->u.var.type->u.type.width,
			symref($s.sym, 0));
	}
	else
		strlcat(asmbuffer, subref($s.sym->u.sub), sizeof(asmbuffer));
    strlcat(asmbuffer, " ", sizeof(asmbuffer));
}

gen ASMVALUE():c
{
	int p = strlen(asmbuffer);
	snprintf(asmbuffer+p, sizeof(asmbuffer)-p, "%d", $c.value);
}

gen ASMEND()
{
    E("\t%s\n", asmbuffer);
}

// --- Array initialisers ------------------------------------------------

%{
	/* This is *vile*. We need to emit differentiated bytes... but also,
	 * occasionally, pointers. We don't have any type information. So,
	 * we can't just emit a byte array because we might need to embed
	 * 8-byte pointers into it, which C doesn't allow. Instead, all
	 * static initialisers end up as arrays of i8, and we buffer up bytes
	 * to emit them in chunks of eight. */

	static uint64_t initialiser_buffer;
	static uint8_t initialiser_buffer_fill_bits;

	static int emit_string(const char* s)
	{
		int sid = id++;
		emitter_open_chunk();
		E("const i1 s%d[] = { ", sid);
		bool start = true;
		for (;;)
		{
			char c = *s++;
			if (!c)
				break;
			if (!start)
				E(", ");
			E("0x%02x", c);
			start = false;
		}
		if (!start)
			E(", ");
		E("0 };\n");
		emitter_close_chunk(current_sub);
		return sid;
	}

	static void flush_initialiser_buffer(void)
	{
		if (initialiser_buffer_fill_bits != 0)
		{
			E("\t{ .i8 = 0x%016llx },\n", initialiser_buffer);
			initialiser_buffer = 0;
			initialiser_buffer_fill_bits = 0;
		}
	}

	static void check_alignment(int width)
	{
		int alignment = (initialiser_buffer_fill_bits / 8) & 7;
		if (alignment & (width-1))
			fatal("alignment error in initialiser");
	}

	static void emit_bytes(int width, uint64_t value)
	{
		check_alignment(width);

		bool first = true;
		while (width--)
		{
			uint64_t byte = value & 0xff;
			value >>= 8;

			initialiser_buffer |= byte << initialiser_buffer_fill_bits;
			initialiser_buffer_fill_bits += 8;
			if (initialiser_buffer_fill_bits == 64)
				flush_initialiser_buffer();
		}
	}
%}

gen STARTINIT():s
{
	int sid = id++;
	$s.sym->u.var.externname = aprintf("initialiser%d", sid);

	emitter_open_chunk();
	E("static data %s[] = { // %s\n",
		$s.sym->u.var.externname,
		$s.sym->name);
	initialiser_buffer = 0;
	initialiser_buffer_fill_bits = 0;
}
	
gen INIT1():c { emit_bytes(1, $c.value); }
gen INIT2():c { emit_bytes(2, $c.value); }
gen INIT4():c { emit_bytes(4, $c.value); }
gen INIT8():c { emit_bytes(8, $c.value); }

gen INITS():s {
	check_alignment(8);
	E("\t{ .ptr = (void*)s%d },\n", emit_string($s.text));
}

gen ENDINIT()
{
	flush_initialiser_buffer();
	E("\n};\n");
	emitter_close_chunk(current_sub);
}

// --- Strings -----------------------------------------------------------

gen v8 := STRING():s
{
	E("\ti8 v%d = (i8)(intptr_t)s%d;\n", push(), emit_string($s.text));
}

