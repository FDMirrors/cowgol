sub load_complex_16bit_value(regs: RegSet, ea: [EffectiveAddress]): (reg: RegSet)
    # If the value is already in a register, load it.

    if reg_is_cached_in(REG_16BIT, ea) != 0 then
        reg := reg_find_or_load(regs, ea);
        return;
    end if;
        
    # If the value can be trivially loaded, do so.

    if (ea.flags == EA_VALUE) or (ea.flags == EA_LEA) then
        reg := reg_find_or_load(regs, ea);
        return;
    end if;

    # The value is going to have to be indirected through a pointer of
    # some description, as we can't refer to it directly.

    var pointer: RegSet;
    var residualoffset: int16;
    (pointer, residualoffset) := setup_pointer(REG_HL|REG_IX|REG_IY, ea, 0);

    # Now the pointer is in a register, dereference it.

    sub load_byte(offset: uint8)
        insn_init();
        if (pointer == reg) and (offset == 0) then
            insn.datareg := REG_A;
        else
            insn.datareg := halfof_reg(reg, offset);
        end if;
        insn.otherreg := pointer;
        insn.mode := MODE_IND;
        if (pointer & REG_INDEX) != 0 then
            insn.offset := residualoffset + (offset as int16);
        end if;
        insn_load_object();
    end sub;

    # We do this in this order so as to allow us to reuse the register for the
    # pointer for the data. That's important, as we're very low on general-
    # purpose registers.
    reg_free(pointer);
    reg := reg_alloc(regs);

    # Prepare for the nasty in-place load.
    if reg == pointer then
        reg_alloc_fixed(REG_A);
    end if;
    
    load_byte(0);
    if (pointer == REG_HL) then
        reg_evict(pointer);
        write_byte(0x23); # inc hl
    end if;
    load_byte(1);

    if reg == pointer then
        reg_copy(REG_A, halfof_reg(reg, 0));
        reg_free(REG_A);
    end if;
    reg_cache_value(reg, ea);
end sub;

sub load_complex_16bit_value_fixed(regs: RegSet, ea: [EffectiveAddress])
    var location: RegSet := load_complex_16bit_value(regs, ea);
end sub;

sub save_16bit_or_make_precious(ea: [EffectiveAddress], reg: RegSet)
    $if DEBUG
        print("* value ");
        print_ea(ea);
        print(" in ");
        print_regs(reg);
        print(" must be saved");
        print_newline();
    $endif

    reg_cache_value(reg, ea);
    if ea.flags == EA_DEREF then
        var pointer: RegSet;
        var residualoffset: int16;
        (pointer, residualoffset) := setup_pointer(REG_HL|REG_IX|REG_IY, ea, 0);

        sub save_byte(offset: uint8)
            insn_init();
            insn.datareg := halfof_reg(reg, offset);
            insn.otherreg := pointer;
            insn.mode := MODE_IND;
            if (pointer & REG_INDEX) != 0 then
                insn.offset := residualoffset + (offset as int16);
            end if;
            insn_save_object();
        end sub;

        save_byte(0);
        if (pointer & REG_INDEX) == 0 then
            reg_evict(pointer);
            var regnum: uint8 := get_z80_regnum(pointer);
            write_byte(0x03 | regnum); # inc bc
        end if;
        save_byte(1);

        reg_free(pointer);
    else
        reg_value_is_precious(ea);
    end if;
end sub;

sub arch_gen_copy_word(iop: [BEIop])
    $if DEBUG
        print("* GENERATE copy word: ");
        print_ea(&iop.left);
        print(" -> ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    var location: RegSet := load_complex_16bit_value(REG_PAIR, &iop.left);
    reg_value_is_changing(&iop.dest);
    save_16bit_or_make_precious(&iop.dest, location);
end sub;

sub arch_gen_shift_word(iop: [BEIop])
    $if DEBUG
        print("* GENERATE shift word opcode=0x");
        print_hex_i8(iop.iop_kind);
        print(": ");
        print_ea(&iop.left);
        print(" by ");
        print_ea(&iop.right);
        print(" -> ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    var reg: RegSet;
    sub inplace_shift_half(reg: RegSet, offset: uint8, opcode: uint8)
        $if DEBUG
            print("* in-place shifting reg ");
            print_regs(reg);
            print(" offset ");
            print_i8(offset);
            print_newline();
        $endif
        var regnum: uint8 := get_z80_regnum(halfof_reg(reg, offset));
        write_byte(0xCB);
        write_byte(opcode | regnum);
    end sub;
    
    sub inplace_shift()
        if (iop.iop_kind == IOP_BE_LSL) and (reg == REG_HL) then
            write_byte(0x29); # add hl, hl
        elseif iop.iop_kind == IOP_BE_LSR then
            inplace_shift_half(reg, 1, 0x38); # srl r
            inplace_shift_half(reg, 0, 0x18); # rr r
        else
            inplace_shift_half(reg, 1, 0x28); # sra r
            inplace_shift_half(reg, 0, 0x18); # rr r
        end if;
    end sub;

    if iop.iop_kind == IOP_BE_LSL then
        reg := REG_HL;
    else
        reg := REG_PAIR;
    end if;
    reg := load_complex_16bit_value(reg, &iop.left);
    reg_value_is_changing(&iop.dest);

    if is_number_thing(iop.right.obj_id) != 0 then
        var count: uint8 := get_value_of_number(iop.right.obj_id) as uint8;
        if count < 8 then
            while count != 0 loop
                inplace_shift();
                count := count - 1;
            end loop;
            save_16bit_or_make_precious(&iop.dest, reg);
            return;
        end if;
    end if;
            
    load_complex_8bit_value_fixed(REG_B, &iop.right);
    reg_evict(REG_B);
    reg_evict(reg);

    # We have to skip the shift completely if the value is 0. Because the test
    # happens at the *end* of the loop, if we just go in the front we'll always
    # go round once. So we do this instead.
    # TODO: unnecessary if the RHS is a constant.

    var entrypoint: uint8 := create_label();
    write_byte(0x04); # inc b
    write_cg_conditional_iop(0xC3, entrypoint); # jp

    var label: uint8 := create_label();
    write_label_iop(label);
    inplace_shift();
    write_label_iop(entrypoint);
    write_cg_conditional_iop(0x10, label); # djnz label
    
    reg_free(REG_B);
    save_16bit_or_make_precious(&iop.dest, reg);
end sub;

sub arch_gen_extend_word(iop: [BEIop], signed: uint8, srcwidth: uint8)
    $if DEBUG
        print("* GENERATE: extend word signed=");
        print_i8(signed);
        print(" srcwidth=");
        print_i8(srcwidth);
        print(": ");
        print_ea(&iop.left);
        print(" => ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    if srcwidth != 1 then
        print("bad extension");
        halt();
    end if;

    var destreg: RegSet := reg_alloc(REG_PAIR);
    load_complex_8bit_value_fixed(REG_A, &iop.right);
    reg_copy(REG_A, halfof_reg(destreg, 0));
    reg_evict(REG_A);
    if signed != 0 then
        write_byte(0x07); # rlca
        write_byte(0x9F); # sbc a, a
        reg_copy(REG_A, halfof_reg(destreg, 0));
    else
        reg_find_or_load_int_fixed(halfof_reg(destreg, 1), 0);
    end if;
    reg_free(REG_A);
    save_16bit_or_make_precious(&iop.dest, destreg);
end sub;

sub add_or_sub_constant_rhs(iop: [BEIop], delta: int16)
    var leftreg: RegSet := load_complex_16bit_value(REG_HL|REG_BC|REG_DE, &iop.left);
    reg_value_is_changing(&iop.dest);
    
    var reg: RegSet := apply_offset(leftreg, delta);

    reg_free(reg);
    save_16bit_or_make_precious(&iop.dest, reg);
end sub;

sub maybe_do_fast_add_or_sub(iop: [BEIop], negative: uint8): (yes: uint8)
    yes := 0;
    if is_number_thing(iop.right.obj_id) != 0 then
        var delta: int16 := get_value_of_number(iop.right.obj_id) as int16;
        if negative != 0 then
            delta := 0-delta;
        end if;
        add_or_sub_constant_rhs(iop, delta);
        yes := 1;
    end if;
end sub;

sub arch_gen_add_word(iop: [BEIop])
    $if DEBUG
        print("* GENERATE: add word: ");
        print_ea(&iop.left);
        print(" + ");
        print_ea(&iop.right);
        print(" => ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    if maybe_do_fast_add_or_sub(iop, 0) != 0 then
        return;
    end if;

    var leftreg: RegSet := load_complex_16bit_value(REG_HL, &iop.left);
    var rightreg: RegSet := load_complex_16bit_value(REG_HL|REG_BC|REG_DE, &iop.right);

    reg_value_is_changing(&iop.dest);
    reg_evict(leftreg);
    
    $if DEBUG
        print("* doing 16-bit add now\n");
    $endif
    write_byte(0x09 | get_z80_regnum(rightreg)); # add hl, bc

    reg_free(rightreg);
    save_16bit_or_make_precious(&iop.dest, leftreg);
end sub;

sub arch_gen_sub_word(iop: [BEIop])
    $if DEBUG
        print("* GENERATE: sub word: ");
        print_ea(&iop.left);
        print(" - ");
        print_ea(&iop.right);
        print(" => ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    if maybe_do_fast_add_or_sub(iop, 1) != 0 then
        return;
    end if;
    
    var leftreg: RegSet := load_complex_16bit_value(REG_HL, &iop.left);
    var rightreg: RegSet := load_complex_16bit_value(REG_HL|REG_BC|REG_DE, &iop.right);

    reg_value_is_changing(&iop.dest);
    reg_evict(leftreg);
    
    $if DEBUG
        print("* doing 16-bit sub now\n");
    $endif
    var regnum: uint8 := get_z80_regnum(rightreg);
    
    write_word(0xEDB7);        # or a (clear carry), plus prefix byte for next
    write_byte(0x42 | regnum); # sbc hl, bc

    reg_free(rightreg);
    save_16bit_or_make_precious(&iop.dest, leftreg);
end sub;

sub arch_gen_cmp_16bit(ciop: [BEConditionalIop], liop: [LabelIop])
    $if DEBUG
        print("* GENERATE: compare words 0x");
        print_hex_i8(ciop.iop_kind);
        print(": ");
        print_ea(&ciop.left);
        print(", ");
        print_ea(&ciop.right);
        print(" => label 0x");
        print_hex_i8(liop.label);
        print_newline();
    $endif

    var fallthrough_label: uint8;
    var iopkind: uint8 := ciop.iop_kind;

    var rhsreg: RegSet;
    if (iopkind & IOP_TYPE_COMPARISON_GT) == 0 then
        rhsreg := load_complex_16bit_value(REG_BC|REG_DE, &ciop.right);
        load_complex_16bit_value_fixed(REG_HL, &ciop.left);
    else
        rhsreg := load_complex_16bit_value(REG_BC|REG_DE, &ciop.left);
        load_complex_16bit_value_fixed(REG_HL, &ciop.right);
    end if;

    var invertflag: uint8;
    var destlabel: uint8;
    if liop.label == ciop.iftrue_label then
        invertflag := 0x00;
        fallthrough_label := ciop.iftrue_label;
        destlabel := ciop.iffalse_label;
    else
        invertflag := 0x08;
        fallthrough_label := ciop.iffalse_label;
        destlabel := ciop.iftrue_label;
    end if;

    reg_evict(REG_HL);
    var regnum: uint8 := get_z80_regnum(rhsreg);
    write_word(0xEDB7);        # or a (clear carry), plus prefix byte for next
    write_byte(0x42 | regnum); # sbc hl, bc

    if iopkind == IOP_BE_BEQ then
        write_cg_conditional_iop(0xC2 ^ invertflag, destlabel); # jp nz
    else
        if (iopkind & IOP_TYPE_COMPARISON_S) != 0 then
            # BLTS
            var skipxorlabel: uint8 := create_label();
            write_cg_conditional_iop(0xE2, skipxorlabel); # jp po
            write_word(0x80EE); # xor 0x80
            write_label_iop(skipxorlabel);

            write_cg_conditional_iop(0xF2 ^ invertflag, destlabel); # jp p
        else
            # BLTU
            write_cg_conditional_iop(0xD2 ^ invertflag, destlabel); # jp c
        end if;
    end if;

    if liop.label != fallthrough_label then
        write_cg_conditional_iop(0xC3, fallthrough_label); # jp
    end if;
end sub;

