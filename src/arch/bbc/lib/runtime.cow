sub print(ptr: [int8])
    loop
        var c: int8 := ptr[0];
        if c == 0 then
            return;
        end if;
        print_char(c as uint8);
        ptr := ptr + 1;
    end loop;
end sub;

sub print_char(char: uint8)
    @bytes 0xAD, &char;        # LDA char
    @bytes 0x4C, 0xE3, 0xFF;   # JMP OSASCII
end sub;

sub print_newline()
    @bytes 0x4C, 0xE7, 0xFF;   # JMP abs
end sub;

sub print_i8(value: uint8)
    var buffer: uint8[3];
    var pos: uint8 := 0;
    loop
        var rem: uint8;
        (value, rem) := divmod8(value, 10);
        buffer[pos] := rem;
        if value == 0 then
            break;
        end if;
        pos := pos + 1;
    end loop;

    loop
        print_char(buffer[pos] + '0');
        if pos == 0 then
            break;
        end if;
        pos := pos - 1;
    end loop;
end sub;

sub print_i16(value: uint16)
end sub;

sub print_i32(value: uint32)
end sub;

sub print_hex_i8(value: uint8)
    var i: uint8 := 2;
    loop
        var digit: uint8 := value >> 4;
        if digit < 10 then
            digit := digit + '0';
        else
            digit := digit + ('A' - 10);
        end if;
        print_char(digit);
        value := value << 4;
        i := i - 1;
        if i == 0 then
            break;
        end if;
    end loop;
end sub;

sub print_hex_i16(value: uint16)
    var valuep: [uint8] := (&value) as [uint8];
    print_hex_i8(valuep[1]);
    print_hex_i8(valuep[0]);
end sub;

sub print_hex_i32(value: uint32)
    var valuep: [uint8] := (&value) as [uint8];
    print_hex_i8(valuep[3]);
    print_hex_i8(valuep[2]);
    print_hex_i8(valuep[1]);
    print_hex_i8(valuep[0]);
end sub;

sub exit(status: uint8)
end sub;

var __params: uint16[3] @segment(0x81);

# Copies A parameters from the code immediately following this call into __params.
# Note: X is left at 0, for use by __modeadjust if necessary.
sub __loadbytes()
    var nextaddr: uint16 @segment(0x81);
    var maxcount: uint8 @segment(0x81);
    @bytes 0x85, >&maxcount;     # STA maxcount
    @bytes 0xA2, 0xFF;           # LDX #-1
    @bytes 0xA0, 0x00;           # LDY #0

    @bytes 0x68;                 # PLA
    @bytes 0x85, >&nextaddr+0;   # STA nextaddr+0
    @bytes 0x68;                 # PLA
    @bytes 0x85, >&nextaddr+1;   # STA nextaddr+1

    goto start;

again:
    @bytes 0xB1, >&nextaddr;     # LDA (nextaddr), Y
    @bytes 0x95, >&__params;     # STA __pointers, X

start:
    @bytes 0xE6, >&nextaddr+0;   # INC nextaddr+0
    @bytes 0xD0, 0x02;           # BNE $+2
    @bytes 0xE6, >&nextaddr+1;   # INC nextaddr+1

    @bytes 0xE8;                 # INX
    @bytes 0xE4, >&maxcount;     # CPX maxcount
    @bytes 0xD0, 0xF1;           # BNE again

    @bytes 0xA2, 0x00;           # LDX #0
    @bytes 0x6C, &nextaddr;      # JMP (nextaddr)
end sub;

sub __load4bytes()
    @bytes 0xA9, 0x04;           # LDA #4
    @bytes 0x4C, &__loadbytes;   # JMP __loadbytes (must be jump to avoid changing stack)
end sub;

sub __load6bytes()
    @bytes 0xA9, 0x06;           # LDA #6
    @bytes 0x4C, &__loadbytes;   # JMP __loadbytes (must be jump to avoid changing stack)
end sub;

# Called immediately after a __loadbytes. On entry, X must be zero. Jump to
# __modeadjust+(7-addressingmode). This is gross, and probably quite slow.
sub __modeadjust()
    @bytes 0xE8;                 # INX X=7
    @bytes 0xE8;                 # INX X=6
    @bytes 0xE8;                 # INX X=5
    @bytes 0xE8;                 # INX X=4
    @bytes 0xE8;                 # INX X=3
    @bytes 0xE8;                 # INX X=2
    @bytes 0xE8;                 # INX X=1
                                 #     X=0

    @bytes 0xA0, 0x00;           # LDY #0
    @bytes 0x8A;                 # TXA
    @bytes 0x29, 0x01;           # AND #1
    @bytes 0xF0, 0x0C;           # BEQ next

    @bytes 0xB1, >&__params+0;   # LDA (__params+0), Y
    @bytes 0x48;                 # PHA
    @bytes 0xC8;                 # INY
    @bytes 0xB1, >&__params+0;   # LDA (__params+0), Y
    @bytes 0x85, >&__params+1;   # STA __params+1
    @bytes 0x68;                 # PLA
    @bytes 0x85, >&__params+0;   # STA __params+0
    @bytes 0x88;                 # DEY

# next:
    @bytes 0x8A;                 # TXA
    @bytes 0x29, 0x02;           # AND #2
    @bytes 0xF0, 0x0C;           # BEQ next

    @bytes 0xB1, >&__params+2;   # LDA (__params+2), Y
    @bytes 0x48;                 # PHA
    @bytes 0xC8;                 # INY
    @bytes 0xB1, >&__params+2;   # LDA (__params+2), Y
    @bytes 0x85, >&__params+3;   # STA __params+3
    @bytes 0x68;                 # PLA
    @bytes 0x85, >&__params+2;   # STA __params+2
    @bytes 0x88;                 # DEY

# next:
    @bytes 0x8A;                 # TXA
    @bytes 0x29, 0x04;           # AND #4
    @bytes 0xF0, 0x0B;           # BEQ next

    @bytes 0xB1, >&__params+4;   # LDA (__params+4), Y
    @bytes 0x48;                 # PHA
    @bytes 0xC8;                 # INY
    @bytes 0xB1, >&__params+4;   # LDA (__params+4), Y
    @bytes 0x85, >&__params+5;   # STA __params+5
    @bytes 0x68;                 # PLA
    @bytes 0x85, >&__params+4;   # STA __params+4
end sub;

#sub __add16()
#    @bytes 0x68;             # PLA
#    @bytes 0x85, >&lp;       # STA lp
#    @bytes 0x68;             # PLA
#    @bytes 0x85, >&lp+1;     # STA lp+1
#
#    @bytes 0xA9, 0x06;       # LDA #6
#    __copyparams();
#
#    # loop:
#    @bytes 0xA0, 0x00;       # LDY #0
#    @bytes 0xA2, 0x01;       # LDX #1
#    @bytes 0x18;             # CLC
#    # loop:
#    @bytes 0xB1, >&__pointers+0; # LDA (__pointers+0), Y
#    @bytes 0x71, >&__pointers+2; # ADC (__pointers+2), Y
#    @bytes 0x91, >&__pointers+4; # STA (__pointers+4), Y
#    @bytes 0xC8;             # INY
#    @bytes 0xCA;             # DEX
#    @bytes 0x10, 0xF6;       # BPL loop
#
#    @bytes 0x6C, &__nextaddr; # JMP (__nextaddr)
#end sub;

# On entry, X=word size
sub __copy()
    @bytes 0xCA;                 # DEX
    @bytes 0x8A;                 # TXA
    @bytes 0xA8;                 # TAY

    # again:
    @bytes 0xB1, >&__params+2;   # LDA (__params+2), Y
    @bytes 0x91, >&__params+0;   # STA (__params+0), Y
    @bytes 0x88;                 # DEY
    @bytes 0x10, 0xF9;           # BPL again
end sub;

# On entry, A=shift amount, X=word size
sub __lsl()
    @bytes 0xA8;                 # TAY (cheap cmp #0)
    @bytes 0xD0, 0x03;           # BNE $+3
    @bytes 0x4C, &__copy;        # JMP __copy

    var count: uint8 @segment(0x81);
    var width: uint8 @segment(0x81);
    @bytes 0x85, >&count;        # STA count
    @bytes 0xCA;                 # DEX
    @bytes 0x86, >&width;        # STX width

    # Copy the value from src to dest, shifting once as we go.

shiftagain:
    @bytes 0xA0, 0x00;           # LDY #0
    @bytes 0xA6, >&width;        # LDX width
    @bytes 0x18;                 # CLC
    # loop:
    @bytes 0xB1, >&__params+2;   # LDA (__params+2), Y
    @bytes 0x2A;                 # ROL A
    @bytes 0x91, >&__params+0;   # STA (__params+0), Y
    @bytes 0xC8;                 # INY
    @bytes 0xCA;                 # DEX
    @bytes 0x10, 0xF7;           # BPL loop

    @bytes 0xC6, >&count;        # DEC count
    @bytes 0xF0, 0x0B;           # BEQ exit

    # We need to shift more, so we do it in-place in dest.

    @bytes 0xA5, >&__params+0;   # LDA __params+0
    @bytes 0x85, >&__params+2;   # STA __params+2
    @bytes 0xA5, >&__params+1;   # LDA __params+1
    @bytes 0x85, >&__params+3;   # STA __params+3
    goto shiftagain;
end sub;

sub __lsl16()
    @bytes 0xA2, 0x02;           # LDX #2
    @bytes 0x4C, &__lsl;         # JMP __lsl
end sub;

sub __lsl32()
    @bytes 0xA2, 0x04;           # LDX #4
    @bytes 0x4C, &__lsl;         # JMP __lsl
end sub;

# On entry, A=shift amount, X=word size, Y=0xFF for signed or 0x00 for unsigned
sub __lsr_asr()
    var signed: uint8 @segment(0x81);
    @bytes 0x84, >&signed;       # STY signed

    @bytes 0xA8;                 # TAY (cheap cmp #0)
    @bytes 0xD0, 0x03;           # BNE $+3
    @bytes 0x4C, &__copy;        # JMP __copy

    var count: uint8 @segment(0x81);
    var width: uint8 @segment(0x81);
    @bytes 0x85, >&count;        # STA count
    @bytes 0xCA;                 # DEX
    @bytes 0x86, >&width;        # STX width

    # Copy the value from src to dest, shifting once as we go.

shiftagain:
    @bytes 0xA4, >&width;        # LDY width
    @bytes 0x18;                 # CLC

    # Prime the carry bit with the sign, so it propagates in if needed.
    @bytes 0xB1, >&__params+2;   # LDA (__params+2), Y
    @bytes 0x25, >&signed;       # AND signed
    @bytes 0x0A;                 # ASL A

    # loop:
    @bytes 0xB1, >&__params+2;   # LDA (__params+2), Y
    @bytes 0x6A;                 # ROR A
    @bytes 0x91, >&__params+0;   # STA (__params+0), Y
    @bytes 0x88;                 # DEY
    @bytes 0x10, 0xF8;           # BPL loop

    @bytes 0xC6, >&count;        # DEC count
    @bytes 0xF0, 0x0B;           # BEQ exit

    # We need to shift more, so we do it in-place in dest.

    @bytes 0xA5, >&__params+0;   # LDA __params+0
    @bytes 0x85, >&__params+2;   # STA __params+2
    @bytes 0xA5, >&__params+1;   # LDA __params+1
    @bytes 0x85, >&__params+3;   # STA __params+3
    goto shiftagain;
end sub;

sub __lsr16()
    @bytes 0xA2, 0x02;           # LDX #2 --- word width
    @bytes 0xA0, 0x00;           # LDY #0 --- unsigned
    @bytes 0x4C, &__lsr_asr;     # JMP __lsr
end sub;

sub __lsr32()
    @bytes 0xA2, 0x04;           # LDX #4 --- word width
    @bytes 0xA0, 0x00;           # LDY #0 --- unsigned
    @bytes 0x4C, &__lsr_asr;     # JMP __lsr
end sub;

sub __asr16()
    @bytes 0xA2, 0x02;           # LDX #2 --- word width
    @bytes 0xA0, 0xFF;           # LDY #255 --- signed
    @bytes 0x4C, &__lsr_asr;     # JMP __asr
end sub;

sub __asr32()
    @bytes 0xA2, 0x04;           # LDX #4 --- word width
    @bytes 0xA0, 0xFF;           # LDY #255 --- signed
    @bytes 0x4C, &__lsr_asr;     # JMP __asr
end sub;

# A/X -> A quotient, X remainder
sub __divmodu8()
    var num: uint8 @segment(0x81);
    var den: uint8 @segment(0x81);
    @bytes 0x85, >&num;          # STA num
    @bytes 0x86, >&den;          # STX den

    @bytes 0xA9, 0x00;           # LDA #0
    @bytes 0xA2, 0x08;           # LDX #8
    @bytes 0x06, >&num;          # ASL num

    # again:
    @bytes 0x2A;                 # ROL A
    @bytes 0xC5, >&den;          # CMP den
    @bytes 0x90, 0x02;           # BCC $+2
    @bytes 0xE5, >&den;          # SBC den
    @bytes 0x26, >&num;          # ROL num
    @bytes 0xCA;                 # DEX
    @bytes 0xD0, 0xF4;           # BNE again

    @bytes 0xAA;                 # TAX
    @bytes 0xA5, >&num;          # LDA num
end sub;

sub divmod8(left: uint8, right: uint8): (quotient: uint8, remainder: uint8)
    @bytes 0xAD, &left;          # LDA left
    @bytes 0xAE, &right;         # LDX right
    __divmodu8();
    @bytes 0x8D, &quotient;      # STA quotient
    @bytes 0x8E, &remainder;     # STA remainder
end sub;

# On entry, A=word size
sub __mul()
    var count: uint8 @segment(0x81);
    var widthm1: uint8 @segment(0x81);
    var left: uint8[4] @segment(0x81);
    var right: uint8[4] @segment(0x81);
    var result: uint8[8] @segment(0x81);
    @bytes 0xA8;                 # TAY
    @bytes 0x88;                 # DEY
    @bytes 0x84, >&widthm1;      # STY widthm1
    @bytes 0x0A;                 # ASL A
    @bytes 0x0A;                 # ASL A
    @bytes 0x0A;                 # ASL A
    @bytes 0x85, >&count;        # STA count

    # First, copy left and right into the work area, and clear the result.

# again:
    @bytes 0x98;                 # TYA
    @bytes 0xAA;                 # TAX
    @bytes 0xB1, >&__params+2;   # LDA (__params+2), Y
    @bytes 0x95, >&left;         # STA left, X
    @bytes 0xB1, >&__params+4;   # LDA (__params+4), Y
    @bytes 0x95, >&right;        # STA right, X
    @bytes 0xA9, 0x00;           # LDA #0
    @bytes 0x95, >&result+4;     # STA dest+4, X --- only need to clear the top half
    @bytes 0x88;                 # DEY
    @bytes 0x10, 0xEF;           # BPL loop

    # Now the multiply.

shift:
    # Shift right right.
    @bytes 0xA6, >&widthm1;      # LDX widthm1
    @bytes 0x18;                 # CLC
    # loop:
    @bytes 0x76, >&right;        # ROR right, X
    @bytes 0xCA;                 # DEX
    @bytes 0x10, 0xFB;           # BPL loop
    @bytes 0x90, 0x0F;           # BCC rotate

    # Add left to the upper half of the result.
    @bytes 0xA2, 0x00;           # LDX #0
    @bytes 0xA4, >&widthm1;      # LDY widthm1
    @bytes 0x18;                 # CLC
    # loop:
    @bytes 0xB5, >&result+4;     # LDA result+4, X
    @bytes 0x75, >&left;         # ADC left, X
    @bytes 0x95, >&result+4;     # STA result+4, X
    @bytes 0xE8;                 # INX
    @bytes 0x88;                 # DEY
    @bytes 0x10, 0xF6;           # BPL loop

# rotate:
    # Now rotate the result right. (In two halves because of the split result.)
    @bytes 0xA6, >&widthm1;      # LDX widthm1
    # loop:
    @bytes 0x76, >&result+4;     # ROR result+4, X
    @bytes 0xCA;                 # DEX
    @bytes 0x10, 0xFB;           # BPL loop

    @bytes 0xA6, >&widthm1;      # LDX widthm1
    # loop:
    @bytes 0x76, >&result;       # ROR result, X
    @bytes 0xCA;                 # DEX
    @bytes 0x10, 0xFB;           # BPL loop

    # Decrement bit count and optionally go again.
    @bytes 0xC6, >&count;        # DEC count
    @bytes 0xD0, 0xD5;           # BNE shift

    # Now copy the result out.

    @bytes 0xA6, >&widthm1;      # LDX widthm1
    # loop:
    @bytes 0x8A;                 # TXA
    @bytes 0xA8;                 # TAY
    @bytes 0xB5, >&result;       # LDA result, X
    @bytes 0x91, >&__params+0;   # STA (__params+0), Y
    @bytes 0xCA;                 # DEX
    @bytes 0x10, 0xF7;           # BPL loop
end sub;

sub __mul16()
    @bytes 0xA9, 0x02;           # LDA #2
    @bytes 0x4C, &__mul;         # JMP __mul
end sub;

sub __mul32()
    @bytes 0xA9, 0x04;           # LDA #4
    @bytes 0x4C, &__mul;         # JMP __mul
end sub;

sub __mul8u(left: uint8, right: uint8): (result: uint8)
    @bytes 0xA9, 0x00; # LDA #0
    @bytes 0xF0, 0x07; # BEQ start

    # add:
    @bytes 0x18; # CLC
    @bytes 0x6D, &left; # ADC abs
    # loop:
    @bytes 0x0E, &left; # ASL abs
    # start:
    @bytes 0x4E, &right; # LSR abs
    @bytes 0xB0, 0xF4; # BCS add
    @bytes 0xD0, 0xF6; # BNE loop
    @bytes 0x8D, &result; # STA abs
end sub;

# Copies and extends from [__params+2] to [__params+0].
# On entry: A = value to extend with.
#           Y = width of destination minus one.
#           X = width of source minus one.
sub __extend()
    var srcwidth: uint8 @segment(0x81);
    @bytes 0xE8;                  # INX
    @bytes 0x86, >&srcwidth;      # STX srcwidth

    again:
    @bytes 0x91, >&__params+0;    # STA (params+0), Y
    @bytes 0x88;                  # DEY
    @bytes 0x30, 0x09;            # BMI exit
    @bytes 0xC4, >&srcwidth;      # CPY srcwidth
    @bytes 0xB0, 0xF7;            # BCS loop
    @bytes 0xB1, >&__params+2;    # LDA (params+2), Y
    goto again;
end sub;

sub __zext()
    @bytes 0xA9, 0x00;            # LDA #0
    @bytes 0x4C, &__extend;       # JMP __extend
end sub;

sub __sext()
    var destwidth: uint8 @segment(0x81);
    @bytes 0x98;                  # TYA
    @bytes 0x48;                  # PHA
    @bytes 0x8A;                  # TXA
    @bytes 0xA8;                  # TAY
    @bytes 0xB1, >&__params+2;    # LDA (params_2), Y
    @bytes 0x0A;                  # ASL A -- top bit now in carry
    @bytes 0x68;                  # PLA
    @bytes 0xA8;                  # TAY
    @bytes 0xA9, 0x00;            # LDA #0
    @bytes 0x69, 0xFF;            # ADC #0xff
    @bytes 0x49, 0xFF;            # EOR #0xff
    @bytes 0x4C, &__extend;       # JMP __extend
end sub;

var __lomem: int8 @segment(0x82);
var LOMEM: [int8] @segment(0x81) := &__lomem;
var HIMEM: [int8] @segment(0x81);

@bytes 0xA9, 0x84;          # LDA #84
@bytes 0x20, 0xF4, 0xFF;    # JSR OSBYTE
@bytes 0x86, >&HIMEM+0;     # STX HIMEM+0
@bytes 0x84, >&HIMEM+1;     # STY HIMEM+1
