const EA_NOTHING             := 0;
const EA_VAR_PLUS_CONST      := 1;
const EA_VAR_PLUS_VAR        := 2;
const EA_PTR_PLUS_CONST      := 3;
const EA_PTR_PLUS_VAR        := 4;
const EA_NUMBER              := 5;

record EffectiveAddress
    type: uint8;
    width: uint8;      # or 0 if it's a numeric constant
    thing_id: uint16;  # base object (usually a variable, or 0)
    var_id: uint16;    # variable offset (for _PLUS_VAR eas)
    constant: int32;   # constant offset (for _PLUS_CONST eas)
end record;

sub print_ea(ea: [EffectiveAddress])
    if ea.type == EA_NOTHING then
        print("nothing()");
        return;
    elseif ea.type == EA_VAR_PLUS_VAR then
        print("var_plus_var(");
    elseif ea.type == EA_VAR_PLUS_CONST then
        print("var_plus_const(");
    elseif ea.type == EA_PTR_PLUS_VAR then
        print("ptr_plus_var(");
    elseif ea.type == EA_PTR_PLUS_CONST then
        print("ptr_plus_const(");
    elseif ea.type == EA_NUMBER then
        print("number(");
    else
        print("unknown(");
    end if;

    print("width="); print_i8(ea.width);

    if ea.type != EA_NUMBER then
        print(" thing_id=0x");
        print_hex_i16(ea.thing_id);

        if (ea.type == EA_VAR_PLUS_VAR) or (ea.type == EA_VAR_PLUS_CONST) then
            print(" var_id=0x");
            print_hex_i16(ea.var_id);
            print(")");
            return;
        end if;
    end if;

    print(" constant=0x");
    print_hex_i32(ea.constant);
    print(")");
end sub;

sub is_same_ea(ea1: [EffectiveAddress], ea2: [EffectiveAddress]): (result: uint8)
    if compare_memory(ea1 as [int8], ea2 as [int8], EffectiveAddress@bytes) == 0 then
        result := 1;
    else
        result := 0;
    end if;
end sub;

sub copy_ea(src: [EffectiveAddress], dest: [EffectiveAddress])
    copy_memory(src as [int8], dest as [int8], EffectiveAddress@bytes);
end sub;
