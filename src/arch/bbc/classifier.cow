sub arch_classify_vars(ea: [EffectiveAddress])
    sub do_data(obj_id: uint16, segment: uint8)
        var obj: [DataThing] := find_thing(obj_id) as [DataThing];
        if segment > obj.segment then
            obj.segment := segment;
        end if;
    end sub;

    var objtype: uint8 := get_thing_type(ea.obj_id);
    if (objtype & THING_TYPED) != 0 then
        var segment: uint8;
        if (ea.flags & EA_DEREF_BEFORE) != 0 then
            segment := SEGMENT_ZEROPAGE;
        else
            segment := SEGMENT_DATA;
        end if;
        do_data(ea.obj_id, segment);
    elseif objtype == THING_STRING then
        do_data(ea.obj_id, SEGMENT_CONST);
    end if;
    if is_typed_thing(ea.varoff_id) != 0 then
        do_data(ea.obj_id, SEGMENT_DATA);
    end if;
end sub;

sub arch_allocate_var(offsets: [ArchSizes], thing: [TypedThing], width: uint16)
    if thing.segment == SEGMENT_ZEROPAGE then
        thing.address := offsets.zp_size;
        offsets.zp_size := offsets.zp_size + width;
    elseif thing.segment == SEGMENT_DATA then
        thing.address := offsets.data_size;
        offsets.data_size := offsets.data_size + width;
    else
        print("bad segment");
        halt();
    end if;
end sub;

sub arch_propagate_var_offsets(src_offsets: [ArchSizes], dest_offsets: [ArchSizes])
    if src_offsets.zp_size > dest_offsets.zp_size then
        dest_offsets.zp_size := src_offsets.zp_size;
    end if;

    if src_offsets.data_size > dest_offsets.data_size then
        dest_offsets.data_size := src_offsets.data_size;
    end if;
end sub;

sub arch_report_offsets(offsets: [ArchSizes])
    print("Zero page: ");
    print_i16(offsets.zp_size);
    print(" bytes\nData: ");
    print_i16(offsets.data_size);
    print(" bytes\n");
end sub;
