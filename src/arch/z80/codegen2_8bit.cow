sub setup_8bit_rhs_insn(ea: [EffectiveAddress]): (indreg: RegSet)
    indreg := 0;

    # If the RHS is already in a register, use that.

    if reg_is_cached(ea) != 0 then
        indreg := reg_find_or_load(REG_8BIT, ea);

        insn_init();
        insn.datareg := REG_A;
        insn.otherreg := indreg;
        insn.mode := MODE_DIR;
        return;
    end if;
        
    # If the RHS is a constant, use *that*.

    if (ea.flags == EA_VALUE) and (is_number_thing(ea.obj_id) != 0) then
        insn_init_from_ea(ea);
        return;
    end if;

    # The RHS is a value in memory of some description. We can't load or
    # refer to it directly, so instead get the address in an indexable
    # register and use an indirection.

    var indea: EffectiveAddress;
    zero_ea(&indea);
    indea.flags := EA_LEA;
    indea.obj_id := ea.obj_id;
    indea.type_id := ea.type_id;
    indreg := reg_find_or_load(REG_HL|REG_IX|REG_IY, &indea);

    insn_init();
    insn.datareg := REG_A;
    insn.otherreg := indreg;
    insn.mode := MODE_IND;
end sub;

sub arch_gen_copy_byte(iop: [BEIop])
    var location: RegSet := reg_find_or_load(REG_A, &iop.left);
    reg_bump(location);
    reg_cache_value(location, &iop.dest);
    reg_value_is_precious(&iop.dest);
end sub;

sub arch_gen_regular_alu_byte(iop: [BEIop], opcode: uint8)
    $if DEBUG
        print("* GENERATE regular alu byte op 0x");
        print_hex_i8(opcode);
        print(": ");
        print_ea(&iop.left);
        print(",");
        print_ea(&iop.right);
        print(" -> ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    reg_find_or_load_fixed(REG_A, &iop.left);

    var indreg: RegSet := setup_8bit_rhs_insn(&iop.right);
    reg_evict(REG_A);

    insn_8bit_aluop(opcode);
    reg_cache_value(REG_A, &iop.dest);
    reg_value_is_precious(&iop.dest);
end sub;

sub arch_gen_cmp_8bit(ciop: [BEConditionalIop], liop: [LabelIop])
    $if DEBUG
        print("* GENERATE: compare bytes 0x");
        print_hex_i8(ciop.iop_kind);
        print(": ");
        print_ea(&ciop.left);
        print(", ");
        print_ea(&ciop.right);
        print(" => label 0x");
        print_hex_i8(liop.label);
        print_newline();
    $endif

    var fallthrough_label: uint8;
    var iopkind: uint8 := ciop.iop_kind;

    reg_find_or_load_fixed(REG_A, &ciop.left);
    var indreg: RegSet := setup_8bit_rhs_insn(&ciop.right);

    var invertflag: uint8;
    var destlabel: uint8;
    if liop.label == ciop.iftrue_label then
        invertflag := 0x00;
        fallthrough_label := ciop.iftrue_label;
        destlabel := ciop.iffalse_label;
    else
        invertflag := 0x08;
        fallthrough_label := ciop.iffalse_label;
        destlabel := ciop.iftrue_label;
    end if;

    if iopkind == IOP_BE_BEQ then
        insn_8bit_aluop(0xFE); # cp *
        write_cg_conditional_iop(0xC2 ^ invertflag, destlabel); # jp nz
    else
        if (iopkind & IOP_TYPE_COMPARISON_S) != 0 then
            # BLTS
            reg_evict(REG_A);
            insn_8bit_aluop(0xD6); # sub *

            var skipxorlabel: uint8 := create_label();
            write_cg_conditional_iop(0xE2 ^ invertflag, skipxorlabel); # jp po
            write_word(0x80EE); # xor 0x80
            write_label_iop(skipxorlabel);

            write_cg_conditional_iop(0xF2 ^ invertflag, destlabel); # jp p
        else
            # BLTU
            insn_8bit_aluop(0xFE); # cp *
            write_cg_conditional_iop(0xD2 ^ invertflag, destlabel); # jp c
        end if;
    end if;

    if liop.label != fallthrough_label then
        write_cg_conditional_iop(0xC3, fallthrough_label); # jp
    end if;
end sub;
