%{
	#include "globals.h"
	#include "emitter.h"
	#include "midcodes.h"
	#include "compiler.h"
	#include <bsd/string.h>
	#include <ctype.h>

	#define IMPL
	#include "codegen.h"

	#define E emitter_printf
	static char asmbuffer[80];

	struct subarch
	{
		int id;
	};

	static int id = 1;

	void arch_init_types(void)
	{
		make_number_type("uint32", 4, false);
		intptr_type = make_number_type("int32", 4, true);
		make_number_type("uint16", 2, false);
		make_number_type("int16", 2, true);
		uint8_type = make_number_type("uint8", 1, false);
		make_number_type("int8", 1, true);

		add_alias(NULL, "intptr", intptr_type);
	}

	void arch_init_subroutine(struct subroutine* sub)
	{
		sub->arch = calloc(1, sizeof(struct subarch));
		sub->arch->id = id++;
	}

	void arch_init_variable(struct symbol* var)
	{
		/* All variables get allocated from workspace 0. */
		current_sub->workspace[0] += var->u.var.type->u.type.width;
	}

	static const char* regref(reg_t reg)
	{
		switch (reg)
		{
			case REG_R0: return "r0";
			case REG_R1: return "r1";
			case REG_R2: return "r2";
			case REG_R3: return "r3";
			case REG_R4: return "r4";
			case REG_R5: return "r5";
			case REG_R6: return "r6";
			case REG_R7: return "r7";
			default: fatal("unknown register id 0x%x", reg);
		}
	}

	static const char* regreflo(reg_t reg)
	{
		switch (reg)
		{
			default: assert(false);
		}
	}

	static const char* subref(Subroutine* sub)
	{
		if (sub->externname)
			return sub->externname;
		
		static char buffer[32];
		snprintf(buffer, sizeof(buffer), "f%d", sub->arch->id);
		return buffer;
	}

	static const char* symref(Symbol* sym, int32_t off)
	{
		static char buffer[32];
		snprintf(buffer, sizeof(buffer), "w%d%+d",
			sym->u.var.sub->arch->id,
			sym->u.var.offset + off);
		return buffer;
	}

	static const char* labelref(int label)
	{
		static char buffer[32];
		snprintf(buffer, sizeof(buffer), "x%d", label);
		return buffer;
	}

	/* Note! This is allowed to destroy the source register. */
	void arch_emit_move(reg_t src, reg_t dest)
	{
		if (!src)
			E("\tpop %s\n", regref(dest));
		else if (!dest)
			E("\tpush %s\n", regref(src));
		else
			E("\tmov %s, %s\n", regref(dest), regref(src));
	}

	void arch_emit_comment(const char* text, ...)
	{
		va_list ap;
		va_start(ap, text);
		emitter_printf("\t# ");
		emitter_vprintf(text, ap);
		emitter_printf("\n");
		va_end(ap);
	}
%}

register r0 r1 r2 r3 r4 r5 r6 r7;
register param;

regclass reg := r0|r1|r2|r3|r4|r5|r6|r7;
regdata r0 compatible reg;
regdata r1 compatible reg;
regdata r2 compatible reg;
regdata r3 compatible reg;
regdata r4 compatible reg;
regdata r5 compatible reg;
regdata r6 compatible reg;
regdata r7 compatible reg;
regdata param stacked;

gen STARTFILE()
{
    emitter_open_chunk();
	E(".syntax unified\n");
	E(".code 16\n");
    emitter_close_chunk();
}

gen ENDFILE();

gen STARTSUB():s
{
    emitter_open_chunk();
    E("\n");
    E("# %s\n", $s.sub->name);
	E(".text\n");
    if ($s.sub->externname)
        E("\t.global %s\n", $s.sub->externname);
	E(".thumb_func\n");
    E("%s:\n", subref($s.sub));

    if ($s.sub->inputparameters != 0)
    {
		E("\tldr r1, =%s\n", symref(get_input_parameters($s.sub), 0));
        for (int i=$s.sub->inputparameters-1; i>=0; i--)
        {
			Symbol* param = get_input_parameters($s.sub);
			for (int j=0; j<i; j++)
				param = param->next;

			E("\tpop {r0}\n");
			switch (param->u.var.type->u.type.width)
			{
				case 1:
					E("\tstrb r0, [r1, %d]\n", param->u.var.offset);
					break;

				case 2:
					E("\tstrh r0, [r1, %d]\n", param->u.var.offset);
					break;

				case 4:
					E("\tstr r0, [r1, %d]\n", param->u.var.offset);
					break;

				default:
					assert(false);
			}
        }
    }

	E("\tpush {lr}\n");
}

gen ENDSUB():s
{
	E("end_%s:\n", subref($s.sub));
//	if ($s.sub->outputparameters != 0)
//	{
//		E("\tpop h\n");
//		E("\txchg\n"); /* put return address in DE */
//
//		for (int i=0; i<$s.sub->outputparameters; i++)
//		{
//			struct symbol* param = $s.sub->namespace.firstsymbol;
//			for (int j=0; j<(i + $s.sub->inputparameters); j++)
//				param = param->next;
//
//			if (param->u.var.type->u.type.width == 1)
//			{
//				E("\tlda %s\n", symref(param, 0));
//				E("\tpush psw\n");
//			}
//			else
//			{
//				E("\tlhld %s\n", symref(param, 0));
//				E("\tpush h\n");
//			}
//		}
//
//		E("\txchg\n");
//		E("\tpchl\n");
//	}
//	else
//		E("\tret\n");
//
	E("\tpop {pc}\n");
	if ($s.sub->workspace[0])
	{
		E(".data\n");
		E("w%d: .ds %d\n", $s.sub->arch->id, $s.sub->workspace[0]);
	}
    emitter_close_chunk();
}

//// --- Control flow ------------------------------------------------------
//
//gen RETURN()
//{
//	E("\tjmp end_%s\n", subref(current_sub));
//}

gen LABEL():b
{
	E("%s:\n", labelref($b.label));
}

gen JUMP():j
{
	E("\tb %s\n", labelref($j.label));
}

// --- Subroutines -------------------------------------------------------

// SETPARAM leaves the parameter on the top of the stack, where the
// code generator loses track of it.

gen param := END();

gen param := PUSHPARAM1(param, reg:val)
	{ E("\tpush {%s}\n", regref($val)); }

gen param := PUSHPARAM2(param, reg:val)
	{ E("\tpush {%s}\n", regref($val)); }

gen param := PUSHPARAM4(param, reg:val)
	{ E("\tpush {%s}\n", regref($val)); }

%{
	static void call(Subroutine* sub)
	{
		if (sub->externname)
		{
			emitter_open_chunk();
			E("\t.extern %s\n", sub->externname);
			emitter_close_chunk();
		}

		arch_emit_comment("subroutine with %d input parameters", sub->inputparameters);
		E("\tbl %s\n", subref(sub));
	}
%}

//gen param := CALL0(param):c
//	{ call($c.sub); }

gen CALL0(param):c
	{ call($c.sub); }

//gen a|b|d|h := CALL1(param):c
//{
//	call($c.sub);
//	E("\tpop %s\n", stkref($$));
//}
//
//gen bc|de|hl := CALL2(param):c
//{
//	call($c.sub);
//	E("\tpop %s\n", stkref($$));
//}
//
//gen POPPARAM1(param, ADDRESS():a) uses a
//{
//	E("\tpop psw\n");
//	E("\tsta %s\n", symref($a.sym, $a.off));
//}
//
//gen param := POPPARAM1(param, ADDRESS():a) uses a
//{
//	E("\tpop psw\n");
//	E("\tsta %s\n", symref($a.sym, $a.off));
//}
//
//gen POPPARAM2(param, ADDRESS():a) uses hl
//{
//	E("\tpop hl\n");
//	E("\tshld %s\n", symref($a.sym, $a.off));
//}
//
//gen param := POPPARAM2(param, ADDRESS():a) uses hl
//{
//	E("\tpop hl\n");
//	E("\tshld %s\n", symref($a.sym, $a.off));
//}

// --- Core conversions --------------------------------------------------

gen reg := CONSTANT():c
{
	if (!($c.value & 0xffffff00))
		E("\tmov %s, #0x%x\n", regref($$), $c.value);
	else
		fatal("constant too big");
}

gen reg := ADDRESS():a
	{ E("\tldr %s, =%s\n", regref($$), symref($a.sym, $a.off)); }

// --- Loads and stores --------------------------------------------------

//gen a := LOAD1(bc|de|hl:lhs)
//{
//	switch ($lhs)
//	{
//		case REG_BC:
//			E("\tldax b\n");
//			break;
//
//		case REG_DE:
//			E("\tldax d\n");
//			break;
//
//		case REG_HL:
//			E("\tmov a, m\n");
//			break;
//
//		default:
//			assert(false);
//	}
//}
//
//gen a := LOAD1(ADDRESS():a)
//	{ E("\tlda %s\n", symref($a.sym, $a.off)); }
//
//gen hl|bc|de := LOAD2(hl:lhs) uses a
//{
//	if ($$ == REG_HL)
//	{
//		E("\tmov a, m\n");
//		E("\tinx h\n");
//		E("\tmov h, m\n");
//		E("\tmov l, a\n");
//	}
//	else
//	{
//		E("\tmov %s, m\n", regreflo($$));
//		E("\tinx h\n");
//		E("\tmov %s, m\n", regref($$));
//	}
//}
//
//gen hl := LOAD2(ADDRESS():a)
//	{ E("\tlhld %s\n", symref($a.sym, $a.off)); }
//
//gen stk4 := LOAD4(ADDRESS():a) uses hl
//{
//	E("\tlhld %s\n", symref($a.sym, $a.off+2));
//	E("\tpush h\n");
//	E("\tlhld %s\n", symref($a.sym, $a.off+0));
//	E("\tpush h\n");
//}
//
//gen STORE1(bc|de|hl:lhs, a)
//{
//	switch ($lhs)
//	{
//		case REG_BC:
//			E("\tstax b\n");
//			break;
//
//		case REG_DE:
//			E("\tstax d\n");
//			break;
//
//		case REG_HL:
//			E("\tmov m, a\n");
//			break;
//
//		default:
//			assert(false);
//	}
//}
//
//gen STORE2(hl, bc|de:rhs) uses a
//{
//	E("\tmov m, %s\n", regreflo($rhs));
//	E("\tinx h\n");
//	E("\tmov m, %s\n", regref($rhs));
//}
//
//gen STORE1(ADDRESS():lhs, a)
//	{ E("\tsta %s\n", symref($lhs.sym, $lhs.off)); }
//
//gen STORE2(ADDRESS():lhs, hl)
//	{ E("\tshld %s\n", symref($lhs.sym, $lhs.off)); }

gen reg := LOAD4(reg:lhs)
	{ E("\tldr %s, [%s]\n", regref($$), regref($lhs)); }

gen STORE4(reg:lhs, reg:rhs)
	{ E("\tstr %s, [%s]\n", regref($rhs), regref($lhs)); }

gen STORE4(ADD4(reg:lhs, CONSTANT():c), reg:rhs)
	{ E("\tstr %s, [%s, %d]\n", regref($rhs), regref($lhs), $c.value); }

//gen a := CONSTANT(value==0)
//	{ E("\txra a\n"); }
//
//gen a|b|d|h := CONSTANT():rhs
//	{ E("\tmvi %s, %d\n", regref($$), $rhs.value); }
//
//gen bc|de|hl := CONSTANT():rhs
//	{ E("\tlxi %s, %d\n", regref($$), $rhs.value); }
//
//gen bc|de|hl := ADDRESS():rhs
//	{ E("\tlxi %s, %s\n", regref($$), symref($rhs.sym, $rhs.off)); }
//
//gen stk4 := CONSTANT():c uses hl
//{
//	E("\tlxi h, %d\n", $c.value >> 16);
//	E("\tpush h\n");
//	E("\tlxi h, %d\n", $c.value & 0xffff);
//	E("\tpush h\n");
//}

// --- 8-bit arithmetic -----------------------------------------------------

//gen a := ADD1(a, b|d|h:rhs)
//	{ E("\tadd %s\n", regref($rhs)); }
//
//gen a := ADD1(a, CONSTANT():rhs)
//	{ E("\tadi %d\n", $rhs.value); }
//
//gen a := ADD1(a|b|d|h:lhs, CONSTANT(value==1))
//	{ E("\tinc %s\n", regref($lhs)); }
//
//gen a := ADD1(a|b|d|h:lhs, CONSTANT(value==2))
//{
//	E("\tinc %s\n", regref($lhs));
//	E("\tinc %s\n", regref($lhs));
//}
//
//gen a := ADD1(a|b|d|h:lhs, CONSTANT(value==-1))
//	{ E("\tdec %s\n", regref($lhs)); }
//
//gen a := ADD1(a|b|d|h:lhs, CONSTANT(value==-2))
//{
//	E("\tdec %s\n", regref($lhs));
//	E("\tdec %s\n", regref($lhs));
//}
//
//gen a := SUB1(a, b|d|h:rhs)
//	{ E("\tsub %s\n", regref($rhs)); }
//
//gen a := SUB1(a, CONSTANT():rhs)
//	{ E("\tsbi %d\n", $rhs.value); }
//
//gen a := SUB1(a|b|d|h:lhs, CONSTANT(value==1))
//	{ E("\tdec %s\n", regref($lhs)); }
//
//gen a := SUB1(a|b|d|h:lhs, CONSTANT(value==-1))
//	{ E("\tinc %s\n", regref($lhs)); }
//
//gen a := NEG1(b|d|h:lhs)
//{
//	E("\txra a\n");
//	E("\tsub %s\n", regref($lhs));
//}
//
//gen a := LSHIFT1(a, b) uses bc
//	{ E("\tcall asl1\n"); }
//
//gen a := RSHIFTU1(a, b) uses bc
//	{ E("\tcall lsr1\n"); }
//
//gen a := RSHIFTS1(a, b) uses bc
//	{ E("\tcall asr1\n"); }
//
//// --- 16-bit arithmetic ----------------------------------------------------
//
//gen hl := ADD2(hl|bc|de:lhs, hl|bc|de:rhs)
//{ 
//	if (($rhs != REG_HL) && ($lhs != REG_HL))
//	{
//		if ($rhs == REG_DE)
//		{
//			E("\txchg\n");
//			$rhs = REG_HL;
//		}
//		else if ($lhs == REG_DE)
//		{
//			E("\txchg\n");
//			$lhs = REG_HL;
//		}
//		else
//		{
//			E("\tmov h, %s\n", regref($lhs));
//			E("\tmov l, %s\n", regreflo($lhs));
//			$lhs = REG_HL;
//		}
//	}
//		
//	E("\tdad %s\n", regref(($lhs != REG_HL) ? $lhs : $rhs));
//}
//
//gen hl := ADD2(hl, CONSTANT(value==1))
//	{ E("\tinx h\n"); }
//
//gen hl := ADD2(hl, CONSTANT(value==2))
//{
//	E("\tinx h\n");
//	E("\tinx h\n");
//}
//
//gen hl := ADD2(hl, CONSTANT(value==-1))
//	{ E("\tdcx h\n"); }
//
//gen hl := ADD2(hl, CONSTANT(value==-2))
//{
//	E("\tdcx h\n");
//	E("\tdcx h\n");
//}
//
//gen bc|de|hl := SUB2(bc|de|hl:lhs, bc|de|hl:rhs) uses a
//{
//    E("\tmov a, %s\n", regreflo($lhs));
//    E("\tsub %s\n", regreflo($rhs));
//    E("\tmov %s, a\n", regreflo($$));
//    E("\tmov a, %s\n", regref($lhs));
//    E("\tsbb %s\n", regref($rhs));
//    E("\tmov %s, a\n", regref($$));
//}
//
//gen bc|de|hl := NEG2(bc|de|hl:lhs) uses a
//{
//    E("\txra a\n");
//    E("\tsub %s\n", regreflo($lhs));
//    E("\tmov %s, a\n", regreflo($$));
//	E("\tsbb a\n");
//    E("\tsub %s\n", regref($lhs));
//    E("\tmov %s, a\n", regref($$));
//}
//
//gen hl := LSHIFT2(hl, b) uses a
//	{ E("\tcall asl2\n"); }
//
//gen hl := RSHIFTU2(hl, b) uses a
//	{ E("\tcall lsr2\n"); }
//
//gen hl := RSHIFTS2(hl, b) uses a
//	{ E("\tcall asr2\n"); }

// --- 32-bit arithmetic ----------------------------------------------------

gen reg := ADD4(reg:lhs, reg:rhs)
	{ E("\tadd %s, %s, %s\n", regref($$), regref($lhs), regref($rhs)); }

gen reg := SUB4(reg:lhs, reg:rhs)
	{ E("\tadd %s, %s, %s\n", regref($$), regref($lhs), regref($rhs)); }

gen reg := NEG4(reg:lhs)
	{ E("\tneg %s, %s\n", regref($$), regref($lhs)); }

gen reg := RSHIFTU4(reg:lhs, reg:rhs)
	{ E("\tlsr %s, %s, %s\n", regref($$), regref($lhs), regref($rhs)); }

//// --- Branches -------------------------------------------------------------
//
//%{
//	static void bequ1(int truelabel, int falselabel, reg_t nota)
//	{
//		E("\tcmp %s\n", regref(nota));
//		E("\tjz %s\n", labelref(truelabel));
//		E("\tjnz %s\n", labelref(falselabel));
//	}
//%}
//
//gen BEQU1(b|d|h:nota, a):b
//	{ bequ1($b.truelabel, $b.falselabel, $nota); }
//
//gen BEQS1(b|d|h:nota, a):b
//	{ bequ1($b.truelabel, $b.falselabel, $nota); }
//
//%{
//	static void bequ1c(int truelabel, int falselabel, int c)
//	{
//		if (!c)
//			E("\tora a\n");
//		else
//			E("\tcpi %d\n", c);
//		E("\tjz %s\n", labelref(truelabel));
//		E("\tjnz %s\n", labelref(falselabel));
//	}
//%}
//	
//gen BEQU1(a, CONSTANT():c):b
//	{ bequ1c($b.truelabel, $b.falselabel, $c.value); }
//
//gen BEQS1(a, CONSTANT():c):b
//	{ bequ1c($b.truelabel, $b.falselabel, $c.value); }
//
//gen BEQU1(CONSTANT():c, a):b
//	{ bequ1c($b.truelabel, $b.falselabel, $c.value); }
//
//gen BEQS1(CONSTANT():c, a):b
//	{ bequ1c($b.truelabel, $b.falselabel, $c.value); }
//
//gen BLTU1(a, CONSTANT():c):b
//{
//	E("\tcpi %d\n", $c.value);
//	E("\tjc %s\n", labelref($b.truelabel));
//	E("\tjmp %s\n", labelref($b.falselabel));
//}
//
//%{
//	static void bequ2(int truelabel, int falselabel, reg_t lhs, reg_t rhs)
//	{
//		E("\tmov a, %s\n", regref(lhs));
//		E("\tcmp %s\n", regref(rhs));
//		E("\tjnz %s\n", labelref(falselabel));
//		E("\tmov a, %s\n", regreflo(lhs));
//		E("\tcmp %s\n", regreflo(rhs));
//		E("\tjnz %s\n", labelref(falselabel));
//		E("\tjmp %s\n", labelref(truelabel));
//	}
//%}
//
//gen BEQU2(hl|bc|de:lhs, hl|bc|de:rhs):b
//	{ bequ2($b.truelabel, $b.falselabel, $lhs, $rhs); }
//
//gen BEQS2(hl|bc|de:lhs, hl|bc|de:rhs):b
//	{ bequ2($b.truelabel, $b.falselabel, $lhs, $rhs); }
//
//%{
//	static void bequ2c(int truelabel, int falselabel, reg_t lhs, int c)
//	{
//		E("\tlxi d, 0x%x\n", (-c) & 0xffff);
//		E("\tdad d\n");
//		E("\tmov a, l\n");
//		E("\tora h\n");
//		E("\tjnz %s\n", labelref(falselabel));
//		E("\tjmp %s\n", labelref(truelabel));
//	}
//%}
//
//gen BEQU2(hl:lhs, CONSTANT():rhs):b uses de|a
//	{ bequ2c($b.truelabel, $b.falselabel, $lhs, $rhs.value); }
//
//gen BEQS2(hl:lhs, CONSTANT():rhs):b uses de|a
//	{ bequ2c($b.truelabel, $b.falselabel, $lhs, $rhs.value); }
//
//gen BEQU2(CONSTANT():lhs, hl:rhs):b uses de|a
//	{ bequ2c($b.truelabel, $b.falselabel, $rhs, $lhs.value); }
//
//gen BEQS2(CONSTANT():lhs, hl:rhs):b uses de|a
//	{ bequ2c($b.truelabel, $b.falselabel, $rhs, $lhs.value); }
//
//gen BLTU2(hl|bc|de:lhs, hl|bc|de:rhs):b uses a
//{
//	E("\tmov a, %s\n", regreflo($lhs));
//	E("\tsub %s\n", regreflo($rhs));
//	E("\tmov a, %s\n", regref($lhs));
//	E("\tsbb %s\n", regref($rhs));
//	E("\tjc %s\n", labelref($b.truelabel));
//	E("\tjmp %s\n", labelref($b.falselabel));
//}
//
//%{
//	static void bequ4(int truelabel, int falselabel, reg_t lhs, reg_t rhs)
//	{
//		E("\tcall sub4\n");
//		E("\tcall cmpu4\n");
//		E("\tjnz %s\n", labelref(falselabel));
//		E("\tjmp %s\n", labelref(truelabel));
//	}
//%}
//
//gen BEQU4(stk4:lhs, stk4:rhs):b
//	{ bequ4($b.truelabel, $b.falselabel, $lhs, $rhs); }
//
//gen BEQS4(stk4:lhs, stk4:rhs):b
//	{ bequ4($b.truelabel, $b.falselabel, $lhs, $rhs); }
//
//// --- Casts ----------------------------------------------------------------
//
//gen a|b|d|h := CAST21(bc|de|hl:rhs)
//	{ E("\tmov %s, %s\n", regref($$), regref($rhs)); }
//	
//gen stk4 := CAST24(hl|de:rhs) uses bc
//{
//	E("\tlxi b, 0\n");
//	E("\tpush b\n");
//	E("\tpush %s\n", regref($rhs));
//}
//	
//gen a|d := CAST41(stk4) uses hl|bc
//{
//	E("\tpop b\n");
//	E("\tpop h\n");
//	E("\tmov %s, c\n", regref($$));
//}
//	
//gen hl|de := CAST41(stk4) uses bc
//{
//	E("\tpop b\n");
//	E("\tpop %s\n", regref($$));
//}
	
// --- Inline assembly ------------------------------------------------------

gen ASMSTART()
{
    asmbuffer[0] = '\0';
}

gen ASMTEXT():t
{
    strlcat(asmbuffer, $t.text, sizeof(asmbuffer));
    strlcat(asmbuffer, " ", sizeof(asmbuffer));
}

gen ASMSYMBOL():s
{
    strlcat(asmbuffer, symref($s.sym, 0), sizeof(asmbuffer));
    strlcat(asmbuffer, " ", sizeof(asmbuffer));
}

gen ASMEND()
{
    E("\t%s\n", asmbuffer);
}

//// --- Strings -----------------------------------------------------------
//
//gen bc|de|hl := STRING():s
//{
//    int sid = id++;
//    emitter_open_chunk();
//    E("\tcseg\n");
//    E("s%d:\n", sid);
//    E("\tdb ");
//    bool instring = false;
//    bool start = true;
//	const char* s = $s.text;
//    for (;;)
//    {
//        char c = *s++;
//        if (!c)
//            break;
//        if (!start && !instring)
//            E(", ");
//        start = false;
//        if (isprint(c) && (c != '\"') && (c != '\\'))
//        {
//            if (!instring)
//            {
//                E("\"");
//                instring = true;
//            }
//            E("%c", c);
//        }
//        else
//        {
//            if (instring)
//            {
//                E("\", ");
//                instring = false;
//            }
//            E("%d", c);
//        }
//    }
//    if (instring)
//        E("\"");
//    if (!start)
//        E(", ");
//    E("0\n");
//    emitter_close_chunk();
//
//    E("\tlxi %s, s%d\n", regref($$), sid);
//}
//
