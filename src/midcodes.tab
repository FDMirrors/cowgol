# In order from left to right: has sizes, number of inputs, number of outputs,
# instruction definition.
- 0 0 END()
- 0 0 STARTFILE()
- 0 0 ENDFILE()
- 0 0 STARTSUB(struct subroutine* sub) = ("%s", $$.sub->name)
- 0 0 ENDSUB(struct subroutine* sub) = ("%s", $$.sub->name)

- 0 0 ASMSTART()
- 0 0 ASMTEXT(const char* text) = ("%s", $$.text)
- 0 0 ASMSYMBOL(struct symbol* sym) = ("%s", $$.sym->name)
- 0 0 ASMEND()

# This one is used internally for bookkeeping and the backend should never see it.
- 2 1 PAIR()

- 0 0 LABEL(int label) = ("%d", $$.label)
- 0 0 JUMP(int label) = ("%d", $$.label)
y 1 1 CALL(struct subroutine* sub) = ("%s", $$.sub->name)
- 0 0 RETURN()

- 0 1 CONSTANT(int32_t value) = ("%d", $$.value)
- 0 1 STRING(const char* text) = ("'%s'", $$.text)
- 0 1 ADDRESS(struct symbol* sym) = ("%s", $$.sym->name)

y 1 1 LOAD()
y 2 0 STORE()

y 2 0 BEQS(int truelabel, int falselabel) = ("true=%d false=%d", $$.truelabel, $$.falselabel)
y 2 0 BLTS(int truelabel, int falselabel) = ("true=%d false=%d", $$.truelabel, $$.falselabel)
y 2 0 BEQU(int truelabel, int falselabel) = ("true=%d false=%d", $$.truelabel, $$.falselabel)
y 2 0 BLTU(int truelabel, int falselabel) = ("true=%d false=%d", $$.truelabel, $$.falselabel)

y 1 1 CAST(int srcwidth) = ("srcwidth=%d", $$.srcwidth)

y 2 0 SETPARAM() # left is value, right is chain to next SETPARAM
y 2 0 GETPARAM() # left is *lvalue*, right is chain to next GETPARAM

y 2 1 ADD()
y 2 1 SUB()
y 2 1 MUL()
y 2 1 DIVU()
y 2 1 DIVS()
y 2 1 REMU()
y 2 1 REMS()
y 2 1 AND()
y 2 1 OR()
y 2 1 EOR()
y 1 1 NOT()
y 1 1 NEG()
y 2 1 LSHIFT()
y 2 1 RSHIFTU()
y 2 1 RSHIFTS()

