%{
	var uint32_type: [Symbol];
	var int32_type: [Symbol];
	var uint16_type: [Symbol];
	var int16_type: [Symbol];
	var uint8_type: [Symbol];
	var int8_type: [Symbol];
	var intptr_type: [Symbol];

	const VARMEM_WS := 0;
	const PTRMEM_WS := 1;
	const VARSTACK_WS := 2;
	const PTRSTACK_WS := 3;

	const FAKE_STACK_SIZE := 32;

	var varstack: uint8[FAKE_STACK_SIZE];
	var varsp: uint8 := 0;

	var ptrstack: uint8[FAKE_STACK_SIZE];
	var ptrsp: uint8 := 0;

	record Extern
		name: string;
		id: uint16;
		next: [Extern];
	end record;

	var externs: [Extern] := (0 as [Extern]);

	record Constant
		value: Arith;
		lid: uint16;
		subr: [Subroutine];
		next: [Constant];
	end record;

	var constants: [Constant] := (0 as [Constant]);

	sub ArchAlignUp(value: Size, alignment: uint8): (newvalue: Size)
		newvalue := value;
	end sub;

	sub ArchInitTypes()
		uint32_type := MakeNumberType(4, 1, 0, "uint32");
		int32_type := MakeNumberType(4, 1, 1, "int32");
		uint16_type := MakeNumberType(2, 1, 0, "uint16");
		int16_type := MakeNumberType(2, 1, 1, "int16");
		uint8_type := MakeNumberType(1, 1, 0, "uint8");
		int8_type := MakeNumberType(1, 1, 1, "int8");

		intptr_type := uint16_type;
		AddAliasString("intptr", intptr_type);
	end sub;

	sub ArchGuessIntType(min: Arith, max: Arith): (symbol: [Symbol])
		if (min >= 0) and (max <= 255) then
			symbol := uint8_type;
		elseif (min >= -128) and (max <= 127) then
			symbol := int8_type;
		elseif (min >= 0) and (max <= 65535) then
			symbol := uint16_type;
		elseif (min >= -32768) and (max <= 32767) then
			symbol := int16_type;
		elseif (min >= 0) then
			symbol := uint32_type;
		else
			symbol := int32_type;
		end if;
	end sub;

	sub ArchInitVariable(symbol: [Symbol])
		var wsid: uint8 := VARMEM_WS;
		if IsPtr(symbol.vardata.type) != 0 then
			wsid := PTRMEM_WS;
		end if;

		var subr := symbol.vardata.subr;
		var offset := subr.workspace[wsid];
		symbol.vardata.offset := offset;
		subr.workspace[wsid] := offset + symbol.vardata.type.typedata.width;
	end sub;

	sub ArchInitMember(containing: [Symbol], member: [Symbol], position: Size)
		member.vardata.offset := position;
		position := position + member.vardata.type.typedata.width;
		if position > containing.typedata.width then
			containing.typedata.width := position;
		end if;
	end sub;

	sub Push(reg: RegId, width: uint8): (stackaddr: uint16)
		if (reg & REG_P16) != 0 then
			stackaddr := (PTRSTACK_WS<<8) | (ptrsp as uint16);
			ptrsp := ptrsp + width;
			if (current_subr.workspace[PTRSTACK_WS] as uint8) < ptrsp then
				current_subr.workspace[PTRSTACK_WS] := ptrsp as Size;
			end if;
		else
			stackaddr := (VARSTACK_WS<<8) | (varsp as uint16);
			varsp := varsp + width;
			if (current_subr.workspace[VARSTACK_WS] as uint8) < varsp then
				current_subr.workspace[VARSTACK_WS] := varsp as Size;
			end if;
		end if;
	end sub;

	sub Pop(reg: RegId, width: uint8): (stackaddr: uint16)
		if (reg & REG_P16) != 0 then
			ptrsp := ptrsp - width;
			stackaddr := (PTRSTACK_WS<<8) | (ptrsp as uint16);
		else
			varsp := varsp - width;
			stackaddr := (VARSTACK_WS<<8) | (varsp as uint16);
		end if;
	end sub;

	sub Peek(reg: RegId, width: uint8): (stackaddr: uint16)
		if (reg & REG_P16) != 0 then
			stackaddr := (PTRSTACK_WS<<8) | ((ptrsp-width) as uint16);
		else
			stackaddr := (VARSTACK_WS<<8) | ((varsp-width) as uint16);
		end if;
	end sub;

	var labelid: uint16 := 0;
	sub E_plabelref(lid: uint16)
		EmitByte(COO_ESCAPE_THISCOO);
		EmitByte('c');
		E_u16(lid);
	end sub;

	sub AllocPlabel(): (lid: uint16)
		lid := labelid;
		labelid := labelid + 1;
	end sub;

	sub E_plabel(lid: uint16)
		E_plabelref(lid);
		E(":\n");
	end sub;

	sub E_stackref(sid: uint16)
		EmitByte(COO_ESCAPE_WSREF);
		E_h16(current_subr.id);
		E_h8((sid >> 8) as uint8);
		E_h16(sid & 0xff);
	end sub;

	sub E_indstackref(sid: uint16)
		EmitByte('(');
		E_stackref(sid);
		E("),y");
	end sub;

	sub E_symref(sym: [Symbol], off: Size)
		if sym.vardata.externname != (0 as string) then
			E(sym.vardata.externname);
			E_i16(off as int16);
		else
			EmitByte(COO_ESCAPE_WSREF);
			E_h16(sym.vardata.subr.id);
			if IsPtr(sym.vardata.type) != 0 then
				E_h8(PTRMEM_WS);
			else
				E_h8(VARMEM_WS);
			end if;
			E_h16(sym.vardata.offset + off);
		end if;
	end sub;

	sub E_symrefi(sym: [Symbol], off: Size)
		EmitByte('(');
		E_symref(sym, off);
		E("),y");
	end sub;

	sub R_flushall()
		RegCacheFlush(ALL_REGS);
	end sub;

	sub R_flush(reg: RegId)
		RegCacheFlush(FindConflictingRegisters(reg));
	end sub;

	sub E_insn(insn: string)
		E_tab();
		E(insn);
		E_space();
	end sub;

	sub E_const(value: uint8)
		EmitByte('#');
		E_u8(value);
	end sub;

	sub E_jump(insn: string, label: LabelRef)
		R_flushall();
		E_tab();
		E(insn);
		E_space();
		E_labelref(label);
		E_nl();
	end sub;

	sub E_jmp(label: LabelRef)
		E_jump("jmp", label);
	end sub;

	sub IsSimpleSub(subr: [Subroutine]): (result: uint8)
		result := 0;
		if (subr.num_output_parameters > 1) or (subr.num_input_parameters > 1) then
			return;
		end if;
		if (subr.num_input_parameters == 1) and (subr.first_input_parameter.vardata.type.typedata.width == 4) then
			return;
		end if;
		if (subr.num_output_parameters == 1) and (subr.first_output_parameter.vardata.type.typedata.width == 4) then
			return;
		end if;
		result := 1;
	end sub;

	sub E_call(subr: [Subroutine])
		if IsSimpleSub(subr) != 0 then
			E("\tjsr ");
			E_subref(subr);
			E_nl();
		else
			var lid := AllocPlabel();

			E("\tldy #<");
			E_plabelref(lid);
			E_nl();
			E("\tsty rts_");
			E_subref(subr);
			E_nl();

			E("\tldy #>1+");
			E_plabelref(lid);
			E_nl();
			E("\tsty rts_");
			E_subref(subr);
			E("+1\n");

			E_insn("jmp");
			E_subref(subr);
			E_nl();
			E_plabel(lid);
		end if;
	end sub;

	sub E_rts() E("\trts\n"); end sub;
	sub E_clc() E("\tclc\n"); end sub;
	sub E_sec() E("\tsec\n"); end sub;
	sub E_pha() E("\tpha\n"); end sub;
	sub E_pla() E("\tpla\n"); end sub;
	sub E_txa() E("\ttxa\n"); end sub;
	sub E_tya() E("\ttya\n"); end sub;
	sub E_tax() E("\ttax\n"); end sub;
	sub E_tay() E("\ttay\n"); end sub;
	sub E_not() E("\teor #255\n"); end sub;

	sub E_ld(reg: RegId)
		R_flush(reg);
		case reg is
			when REG_A: E("\tlda");
			when REG_X: E("\tldx");
			when REG_Y: E("\tldy");
		end case;
		E_space();
	end sub;

	sub E_lda()
		E_ld(REG_A);
	end sub;

	sub E_st(reg: RegId)
		case reg is
			when REG_A: E("\tsta");
			when REG_X: E("\tstx");
			when REG_Y: E("\tsty");
		end case;
		E_space();
	end sub;

	sub E_sta()
		E_st(REG_A);
	end sub;

	sub E_inx()
		R_flush(REG_X);
		E("\tinx\n");
	end sub;

	sub E_iny()
		R_flush(REG_Y);
		E("\tiny\n");
	end sub;

	sub E_dex()
		R_flush(REG_X);
		E("\tdex\n");
	end sub;

	sub E_dey()
		R_flush(REG_Y);
		E("\tdey\n");
	end sub;

	sub E_inc(reg: RegId)
		case reg is
			when REG_A:
				E_clc();
				E("\tadc #1\n");

			when REG_X: E_inx();
			when REG_Y: E_iny();
		end case;
	end sub;

	sub E_dec(reg: RegId)
		case reg is
			when REG_A:
				E_clc();
				E("\tadc #1\n");

			when REG_X: E_dex();
			when REG_Y: E_iny();
		end case;
	end sub;

	sub E_loadconst(reg: RegId, value: uint8)
		var cache := RegCacheFindConstant(value as Word) & reg;
		if cache == 0 then
			E_ld(reg);
			E_const(value);
			E_nl();
			RegCacheLeavesConstant(reg, value as Word);
		end if;
	end sub;

	sub E_loadaddr(sym: [Symbol], off: Size)
		E_ld(REG_A);
		E("#<");
		E_symref(sym, off);
		E_nl();

		E_ld(REG_X);
		E("#>");
		E_symref(sym, off);
		E_nl();
	end sub;

	sub E_loadstackref(sid: uint16)
		E_ld(REG_A);
		E("#<");
		E_stackref(sid);
		E_nl();

		E_ld(REG_X);
		E("#>");
		E_stackref(sid);
		E_nl();
	end sub;

	# Does not persist the name; only call this with constant strings.
	sub E_callhelper(name: string)
		var e := externs;
		while e != (0 as [Extern]) loop
			if StrCmp(e.name, name) == 0 then
				break;
			end if;
			e := e.next;
		end loop;

		if e == (0 as [Extern]) then
			e := Alloc(@bytesof Extern) as [Extern];
			e.name := name;
			e.id := AllocSubrId();
			e.next := externs;
			externs := e;

			EmitterDeclareExternalSubroutine(e.id, name);
		end if;

		EmitterPushChunk();
		E_h16(current_subr.id);
		E_h16(e.id);
		EmitterPopChunk('R');

		R_flushall();
		E("\tjsr ");
		EmitByte(COO_ESCAPE_SUBREF);
		E_h16(e.id);
		E_nl();
	end sub;

	sub E_jumps_with_fallthrough(trueinsn: string, falseinsn: string, node: [Node])
		if node.beq0.truelabel != node.beq0.fallthrough then
			E_jump(trueinsn, node.beq0.truelabel);
		end if;
		if node.beq0.falselabel != node.beq0.fallthrough then
			E_jump(falseinsn, node.beq0.falselabel);
		end if;
	end sub;

	sub E_jumps_beq_bne(node: [Node])
		E_jumps_with_fallthrough("beq", "bne", node);
	end sub;

	sub E_jumps_bcs_bcc(node: [Node])
		E_jumps_with_fallthrough("bcs", "bcc", node);
	end sub;

	sub E_jumps_bmi_bpl(node: [Node])
		E_jumps_with_fallthrough("bmi", "bpl", node);
	end sub;

	sub AllocConst(value: Arith): (lid: uint16)
		var c := constants;
		while c != (0 as [Constant]) loop
			if c.value == value then
				break;
			end if;
			c := c.next;
		end loop;
		if c == (0 as [Constant]) then
			c := Alloc(@bytesof Constant) as [Constant];
			c.lid := AllocPlabel();
			c.value := value;
			c.next := constants;
			constants := c;
		end if;
		lid := c.lid;
	end sub;

	sub E_string(data: string): (lid: uint16)
		lid := AllocPlabel();

		EmitterPushChunk();
		E_h16(current_subr.id);

		E_plabel(lid);
		E("\t.byte ");

		loop
			var c := [data];
			if c == 0 then
				break;
			end if;
			data := data + 1;
			
			E_u8(c);
			E_comma();
		end loop;
		E("0\n");
		EmitterPopChunk('S');
	end sub;

	# Note that this *destroys* the source register.
	sub ArchEmitMove(src: RegId, dest: RegId)
		var sid: uint16;

		sub pushv8()
			sid := Push(dest, 1);
			E_st(src);
			E_stackref(sid);
			E_nl();
		end sub;

		case src is
			when REG_A:
				case dest is
					when REG_X: E_tax(); return;
					when REG_Y: E_tay(); return;
					when 0:     E_pha(); return;
					when REG_V8: pushv8(); return;
				end case;

			when 0:
				case dest is
					when REG_A:  E_pla(); return;

					when REG_XA:
						# Pop from spill stack: note: big endian!
						E_pla();
						E_tax();
						E_pla();
						return;
				end case;

			when REG_X:
				case dest is
					when REG_A:  E_txa(); return;
					when REG_V8: pushv8(); return;
				end case;

			when REG_Y:
				case dest is
					when REG_A:  E_tya(); return;
					when REG_V8: pushv8(); return;
				end case;

			when REG_XA:
				if (dest & REGCLASS_A16) != 0 then
					sid := Push(dest, 2);

					E_st(REG_A);
					E_stackref(sid);
					E_nl();

					E_st(REG_X);
					E_stackref(sid+1);
					E_nl();

					return;
				elseif dest == 0 then
					# Push to spill stack; note: big endian!
					E_pha();
					E_txa();
					E_pha();
					return;
				end if;

			when REG_V8:
				if (dest & REGCLASS_R8) != 0 then
					sid := Pop(src, 1);
					E_ld(dest);
					E_stackref(sid);
					E_nl();
					return;
				end if;
		end case;

		StartError();
		print("bad move ");
		print_hex_i16(src);
		print(" -> ");
		print_hex_i16(dest);
		EndError();
	end sub;

	sub ArchEndInstruction()
	end sub;

	sub ArchEndGroup()
	end sub;
%}

wordsize uint16;

register a x y xa;
register v8;  // value on fake stack
register v16; // value on fake stack
register p16; // pointer on fake stack
register v32; // value on fake stack;
register param;

regclass r8 := a|x|y;
regclass a16 := v16|p16;

regdata a           uses xa|a compatible v8|a|x|y;
regdata x           uses xa|x compatible v8|a|x;
regdata y                     compatible v8|a|y;
regdata xa          uses x|a  compatible a16|xa;
regdata v8  stacked           compatible v8|a|x|y;
regdata v16 stacked           compatible a16|xa;
regdata p16 stacked           compatible a16|xa;
regdata v32 stacked;
regdata param stacked;

// --- Core things ----------------------------------------------------------

gen STARTFILE();

gen ENDFILE();

gen LABEL():b
{
	R_flushall();
	E_labelref($b.label);
	E(":\n");
}

gen JUMP():j
{
	E_jmp($j.label);
}

// --- Subroutines ----------------------------------------------------------

gen STARTSUB():s
{
	RegCacheReset();

	EmitterPushChunk();
	E_h16($s.subr.id);

	E("\n\n\t; ");
	E($s.subr.name);
	E_nl();

	EmitByte(COO_ESCAPE_THISSUB);
	E(":\n");

	var count := $s.subr.num_input_parameters;
	var lastparam := count - 1;

	while count != 0 loop
		count := count - 1;
		var param := GetInputParameter($s.subr, count);

		case param.vardata.type.typedata.width is
			when 1:
				if count != lastparam then
					E_pla();
				end if;
				E_st(REG_A);
				E_symref(param, 0);
				E_nl();

			when 2:
				if count != lastparam then
					E_pla();
					E_tax();
					E_pla();
				end if;
				E_st(REG_A);
				E_symref(param, 0);
				E_nl();

				E_st(REG_X);
				E_symref(param, 1);
				E_nl();

			when 4:
				E_loadconst(REG_Y, 0);
				E_loadconst(REG_X, 3);
				E_pla();
				E_st(REG_A);
				E_symref(param, 0);
				E(",y\n");
				E_iny();
				E_dex();
				E("\tbpl *-5\n");
		end case;
	end loop;
}

gen ENDSUB():s
{
	E("end_");
	E_subref(current_subr);
	E(":\n");
	if IsSimpleSub(current_subr) != 0 then
		E_rts();
	else
		E("rts_");
		E_subref(current_subr);
		E(" = *+1\n");
		E("\tjmp $ffff\n");
	end if;

	while constants != (0 as [Constant]) loop
		var c := constants;
		constants := constants.next;

		E_plabel(c.lid);
		E("\t.word ");
		E_u16(c.value as uint16);
		E_comma();
		E_u16((c.value >> 16) as uint16);
		E_nl();
		Free(c as [uint8]);
	end loop;

	EmitterPopChunk('S');

	var i: uint8 := 0;
	while i != 4 loop
		EmitterDeclareWorkspace($s.subr, i, $s.subr.workspace[i]);
		i := i + 1;
	end loop;
}

gen RETURN()
{
	E("\tjmp end_");
	E_subref(current_subr);
	E_nl();
}

gen CALL(param):s
		{ E_call($s.subr); }
	
gen a := CALLE1(param):s
		{ E_call($s.subr); }

gen xa := CALLE2(param):s
		{ E_call($s.subr); }

gen v32 := CALLE4(param):s
		{ E_call($s.subr); }

gen param := END();

gen param := ARG1(param, a, remaining==0);

gen param := ARG1(param, a, remaining!=0)
		{ E_pha(); }
	
gen param := ARG2(param, xa, remaining==0);

// WARNING: big endian!
gen param := ARG2(param, xa, remaining!=0)
		{ E_pha(); E_txa(); E_pha(); }

gen param := ARG2(END(), CALLE2(param):s)
		{ E_call($s.subr); }

gen param := ARG4(param, v32) uses y|a
{
	var sid := Pop(REG_V32, 4);
	E_loadconst(REG_Y, 3);
	E_ld(REG_A);
	E_stackref(sid);
	E(",y\n");
	E_pha();
	E_dey();
	E("\tbpl *-4\n");
}

gen param := ARG4(END(), CALLE4(param):s)
		{ E_call($s.subr); }

gen a := POPARG1(remaining==0);

gen a := POPARG1(remaining!=0)
		{ E_pla(); }

// WARNING: big endian!
gen xa := POPARG2(remaining==0);

gen xa := POPARG2(remaining!=0)
		{ E_pha(); E_tax(); E_pha(); }

gen v32 := POPARG4() uses x|y|a
{
	var sid := Push(REG_V32, 4);
	E_loadconst(REG_Y, 0);
	E_loadconst(REG_X, 3);
	E_pla();
	E_st(REG_A);
	E_stackref(sid);
	E(",y\n");
	E_iny();
	E_dex();
	E("\tbpl *-5\n");
}

// --- Constants ------------------------------------------------------------

gen a|x|y := CONSTANT():c
{
	E_loadconst($$, $c.value as uint8);
}

// --- 8-bit memory ----------------------------------------------------------

gen STORE1(a:lhs, p16:ptr) uses y
{
	var sid := Pop($ptr, 2);
	E_loadconst(REG_Y, 0);

	E_insn("sta");
	E_indstackref(sid);
	E_nl();
}

gen STORE1(a|x|y:lhs, ADDRESS():a)
{
	E_st($lhs);
	E_symref($a.sym, $a.off);
	E_nl();
	RegCacheLeavesValue($lhs, $a.sym, $a.off);
}

gen a|x|y := LOAD1(ADDRESS():a)
{
	var cache := RegCacheFindValue($a.sym, $a.off) & $$;
	if cache == 0 then
		E_ld($$);
		E_symref($a.sym, $a.off);
		E_nl();
		RegCacheLeavesValue($$, $a.sym, $a.off);
	end if;
}

gen a := LOAD1(LOAD2(ADDRESS():a)) uses y
{
	E_loadconst(REG_Y, 0);
	E_ld($$);
	E_symrefi($a.sym, $a.off);
	E_nl();
}

gen a := LOAD1(p16:ptr) uses y
{
	var sid := Pop(REG_P16, 2);

	E_loadconst(REG_Y, 0);
	E_ld($$);
	E_indstackref(sid);
	E_nl();
}

// --- Extended operations ---------------------------------------------------

%{
	const MODE_CONST := 0;
	const MODE_STACK := 1;
	const MODE_SYMBOL := 2;
	const MODE_SYMBOLI := 3;

	record Operand
		sid @at(0): uint16;
		off @at(0): Size;
		val @at(0): Arith;
		sym: [Symbol];
		mode: uint8;
	end record;

	var paramwidth: uint8;
	var lhsparam: Operand;
	var rhsparam: Operand;
	var destparam: Operand;

	sub LhsConst(value: Arith)
		lhsparam.mode := MODE_CONST;
		lhsparam.val := value;
	end sub;

	sub RhsConst(value: Arith)
		rhsparam.mode := MODE_CONST;
		rhsparam.val := value;
	end sub;

	sub LhsPop(reg: RegId)
		lhsparam.mode := MODE_STACK;
		lhsparam.sid := Pop(reg, paramwidth);
	end sub;

	sub RhsPop(reg: RegId)
		rhsparam.mode := MODE_STACK;
		rhsparam.sid := Pop(reg, paramwidth);
	end sub;

	sub DestPush(reg: RegId)
		destparam.mode := MODE_STACK;
		destparam.sid := Push(reg, paramwidth);
	end sub;

	sub LhsSym(sym: [Symbol], off: Size)
		lhsparam.mode := MODE_SYMBOL;
		lhsparam.sym := sym;
		lhsparam.off := off;
	end sub;

	sub RhsSym(sym: [Symbol], off: Size)
		rhsparam.mode := MODE_SYMBOL;
		rhsparam.sym := sym;
		rhsparam.off := off;
	end sub;

	sub DestSym(sym: [Symbol], off: Size)
		destparam.mode := MODE_SYMBOL;
		destparam.sym := sym;
		destparam.off := off;
	end sub;

	sub LhsSymI(sym: [Symbol], off: Size)
		E_loadconst(REG_Y, 0);
		lhsparam.mode := MODE_SYMBOLI;
		lhsparam.sym := sym;
		lhsparam.off := off;
	end sub;

	sub RhsSymI(sym: [Symbol], off: Size)
		E_loadconst(REG_Y, 0);
		rhsparam.mode := MODE_SYMBOLI;
		rhsparam.sym := sym;
		rhsparam.off := off;
	end sub;

	sub DestSymI(sym: [Symbol], off: Size)
		E_loadconst(REG_Y, 0);
		destparam.mode := MODE_SYMBOLI;
		destparam.sym := sym;
		destparam.off := off;
	end sub;

	sub DoParamIndirect(operand: [Operand], insn: string)
		E_insn(insn);
		case operand.mode is
			when MODE_CONST:
				E_plabelref(AllocConst(operand.val));

			when MODE_STACK:
				E_stackref(operand.sid);

			when MODE_SYMBOL:
				E_symref(operand.sym, operand.off);

			when MODE_SYMBOLI:
				EmitByte('(');
				E_symref(operand.sym, operand.off);
				EmitByte(')');
		end case;
		E(",y\n");
	end sub;

	sub DoParamDirect(operand: [Operand], insn: string)
		E_insn(insn);
		case operand.mode is
			when MODE_CONST:
				E_const(operand.val as uint8);
				operand.val := operand.val >> 8;

			when MODE_STACK:
				E_stackref(operand.sid);
				operand.sid := operand.sid + 1;

			when MODE_SYMBOL:
				E_symref(operand.sym, operand.off);
				operand.off := operand.off + 1;

			when MODE_SYMBOLI:
				E_symrefi(operand.sym, operand.off);
				if paramwidth != 1 then
					E("\n\tiny");
				end if;
		end case;
		E_nl();
	end sub;

	sub DoXA(insn: string)
		R_flush(REG_A|REG_X|REG_XA);
		DoParamDirect(&rhsparam, insn);
		E_pha();
		E_txa();
		DoParamDirect(&rhsparam, insn);
		E_tax();
		E_pla();
	end sub;

	sub DoCopy4()
		E_loadconst(REG_Y, 0);
		E_loadconst(REG_X, paramwidth);
		var lid := AllocPlabel();
		E_plabel(lid);

		DoParamIndirect(&lhsparam, "lda");
		DoParamIndirect(&destparam, "sta");

		E_iny();
		E_dex();
		E("\tbne ");
		E_plabelref(lid);
		E_nl();
	end sub;

	sub Do3Op4(insn: string)
		E_loadconst(REG_Y, 0);
		E_loadconst(REG_X, paramwidth);
		var lid := AllocPlabel();
		E_plabel(lid);

		DoParamIndirect(&lhsparam, "lda");
		DoParamIndirect(&rhsparam, insn);
		DoParamIndirect(&destparam, "sta");

		E_iny();
		E_dex();
		E("\tbne ");
		E_plabelref(lid);
		E_nl();
	end sub;

	sub Do2Op_not()
		E("\tNOT4\n");
	end sub;

	sub Do2Op_neg()
		E("\tNEG4\n");
	end sub;

	sub DoBranch4_beq(node: [Node])
		E_loadconst(REG_Y, 3);
		var lid := AllocPlabel();
		E_plabel(lid);

		DoParamIndirect(&lhsparam, "lda");
		DoParamIndirect(&rhsparam, "cmp");
		E("\tbne ");
		E_labelref(node.beq0.falselabel);
		E_nl();
		E_dey();
		E("\tbpl ");
		E_plabelref(lid);
		E_nl();

		if node.beq0.fallthrough != node.beq0.truelabel then
			E("\tjmp ");
			E_labelref(node.beq0.truelabel);
			E_nl();
		end if;
	end sub;

	sub DoBranch4_blts(node: [Node])
		E_loadconst(REG_Y, 3);
		E_sec();
		var lid := AllocPlabel();
		E_plabel(lid);

		DoParamIndirect(&lhsparam, "lda");
		DoParamIndirect(&rhsparam, "sbc");
		E_dey();
		E("\tbpl ");
		E_plabelref(lid);
		E_nl();

		E_jumps_bmi_bpl(node);
	end sub;

	sub DoBranch4_bltu(node: [Node])
		E_loadconst(REG_Y, 3);
		E_sec();
		var lid := AllocPlabel();
		E_plabel(lid);

		DoParamIndirect(&lhsparam, "lda");
		DoParamIndirect(&rhsparam, "sbc");
		E("\tbvc .+5\n");
		E("\teor #$80\n");
		E_dey();
		E("\tbpl ");
		E_plabelref(lid);
		E_nl();

		E_jumps_bmi_bpl(node);
	end sub;
%}

// --- 8-bit maths -----------------------------------------------------------

%{
	sub DoAlu1S(insn: string)
		var rhssid := Pop(REG_V8, 1);

		R_flush(REG_A);
		E_insn(insn);
		E_stackref(rhssid);
		E_nl();
	end sub;

	sub DoAlu1C(insn: string, value: uint8)
		R_flush(REG_A);
		E_insn(insn);
		E_const(value);
		E_nl();
	end sub;

	sub DoAlu1M(insn: string, sym: [Symbol], off: Size)
		R_flush(REG_A);
		E_insn(insn);
		E_symref(sym, off);
		E_nl();
	end sub;

	sub DoAlu1PS(insn: string)
		var rhssid := Pop(REG_P16, 2);

		E_loadconst(REG_Y, 0);
		R_flush(REG_A);
		E_insn(insn);
		E_indstackref(rhssid);
		E_nl();
	end sub;
%}

gen a := ADD1(a, v8)                 { E_clc(); DoAlu1S("adc"); }
gen a := SUB1(a, v8)                 { E_sec(); DoAlu1S("sbc"); }

gen a := ADD1(a, LOAD1(ADDRESS():a)) { E_clc(); DoAlu1M("adc", $a.sym, $a.off); }
gen a := SUB1(a, LOAD1(ADDRESS():a)) { E_sec(); DoAlu1M("sbc", $a.sym, $a.off); }

gen a := ADD1(a, LOAD1(p16))         { E_clc(); DoAlu1PS("adc"); }
gen a := SUB1(a, LOAD1(p16))         { E_sec(); DoAlu1PS("sbc"); }

gen a := ADD1(a, CONSTANT():c)       { E_clc(); DoAlu1C("adc", $c.value as uint8); }
gen a := SUB1(a, CONSTANT():c)       { E_sec(); DoAlu1C("sbc", $c.value as uint8); }

gen a := NOT1(a) { E_not(); }

gen a := NEG1(a)
{
	R_flush(REG_A);
	E_sec();
	E_not();
	E("\tadc #0\n");
}

gen a := OR1(a, v8) { E("\tOR1\n"); }
gen a := AND1(a, v8) { E("\tAND1\n"); }
gen a := EOR1(a, v8) { E("\tEOR1\n"); }

gen a := LSHIFT1(a, y) { E_callhelper("_lshift1"); }
gen a := RSHIFTU1(a, y) { E_callhelper("_rshiftu1"); }
gen a := RSHIFTS1(a, y) { E_callhelper("_rshifts1"); }

gen v8 := MUL1(v8, a)
		{ E("\tMUL1\n"); }

gen v8 := DIVU1(v8, a)
		{ E("\tDIVU1\n"); }

gen v8 := DIVS1(v8, a)
		{ E("\tDIVS1\n"); }

gen v8 := REMU1(v8, a)
		{ E("\tREMU1\n"); }

gen v8 := REMS1(v8, a)
		{ E("\tREMS1\n"); }

// --- Conditionals ---------------------------------------------------------

%{
	sub beqc(node: [Node], lhs: Arith, rhs: Arith)
		var label := node.beq0.falselabel;
		if lhs == rhs then
			label := node.beq0.truelabel;
		end if;
		if label != node.beq0.fallthrough then
			E_jmp(label);
		end if;
	end sub;
%}

gen BEQ0(CONSTANT():c1, CONSTANT():c2):b
		{ beqc(self.n[0], $c1.value, $c2.value); }

gen BEQ1(v8, a):c
{
	var sid := Pop(REG_V8, 1);

	E_insn("cmp");
	E_stackref(sid);
	E_nl();
	E_jumps_beq_bne(self.n[0]);
}

gen BLTU1(a, v8):c
{
	var sid := Pop(REG_V8, 1);

	E_insn("cmp");
	E_stackref(sid);
	E_nl();
	E_jumps_bcs_bcc(self.n[0]);
}

gen BEQ2(xa:lhs, CONSTANT():c):b
{
	E_insn("cmp");
	E_const($c.value as uint8);
	E_nl();

	E("\tbne ");
	E_labelref($b.falselabel);
	E_nl();

	E_insn("cpx");
	E_const(($c.value>>8) as uint8);
	E_nl();

	E_jumps_beq_bne(self.n[0]);
}

gen BEQ2(v16:lhs, xa:rhs):c
{
	E("\tBEQ2\n");
}

gen BLTU2(v16:lhs, xa:rhs):c
{
	E("\tBLTU2\n");
}

gen BEQ4(v32:lhs, v32:rhs):c
{
	var sid := Pop(REG_V32, 8);
	E_callhelper("_cmp4");
	E_jumps_beq_bne(self.n[0]);
}

gen BLTU4(v32:lhs, v32:rhs):c
{
	var sid := Pop(REG_V32, 8);
	E_callhelper("_cmp4");
	E_jumps_bcs_bcc(self.n[0]);
}

gen BLTS4(v32:lhs, v32:rhs):c
{
	var sid := Pop(REG_V32, 8);
	E_callhelper("_cmps4");
	E_jumps_bcs_bcc(self.n[0]);
}

// --- 16-bit ---------------------------------------------------------------

gen xa := LOAD2(ADDRESS():a)
{
	var cache := RegCacheFindValue($a.sym, $a.off);
	if cache != REG_XA then
		E_ld(REG_A);
		E_symref($a.sym, $a.off);
		E_nl();

		E_ld(REG_X);
		E_symref($a.sym, $a.off+1);
		E_nl();
	end if;
	RegCacheLeavesValue(REG_XA, $a.sym, $a.off);
}

gen xa := LOAD2(p16:ptr)
{
	var sid := Pop($ptr, 2);

	E_loadconst(REG_Y, 0);

	E_ld(REG_A);
	E_indstackref(sid);
	E_nl();

	E_iny();

	E_ld(REG_X);
	E_indstackref(sid);
	E_nl();
}

gen xa := CONSTANT():c
{
	var cache := RegCacheFindConstant($c.value as Word);
	if cache != REG_XA then
		E_loadconst(REG_A, $c.value as uint8);
		E_loadconst(REG_X, ($c.value>>8) as uint8);
	end if;
	RegCacheLeavesConstant(REG_XA, $c.value as Word);
}

gen xa := ADDRESS():a
{
	E_loadaddr($a.sym, $a.off);
}

gen STORE2(xa, ADDRESS():a)
{
	E_st(REG_A);
	E_symref($a.sym, $a.off);
	E_nl();

	E_st(REG_X);
	E_symref($a.sym, $a.off+1);
	E_nl();
	RegCacheLeavesValue(REG_XA, $a.sym, $a.off);
}

gen STORE2(xa, p16:rhs)
{
	var sid := Pop($rhs, 2);

	E_loadconst(REG_Y, 0);

	E_st(REG_A);
	E_indstackref(sid);
	E_nl();

	E_iny();

	E_st(REG_X);
	E_indstackref(sid);
	E_nl();
}

gen xa := LSHIFT2(xa, y) { E_callhelper("_lshift2"); }
gen xa := RSHIFTU2(xa, y) { E_callhelper("_rshiftu2"); }
gen xa := RSHIFTS2(xa, y) { E_callhelper("_rshifts2"); }

gen v16 := MUL2(v16, xa)
		{ E("\tRMUL2\n"); }

gen v16 := DIVU2(v16, xa)
		{ E("\tDIVU2\n"); }

gen v16 := DIVS2(v16, xa)
		{ E("\tDIVS2\n"); }

// --- 32 bit ---------------------------------------------------------------

gen v32 := MUL4(v32, v32) { E_callhelper("_mul4"); }
gen v32 := DIVU4(v32, v32) { E_callhelper("_divu4"); }
gen v32 := REMU4(v32, v32) { E_callhelper("_remu4"); }
gen v32 := DIVU4(v32, v32) { E_callhelper("_divu4"); }

gen v32 := LSHIFT4(v32, y)
{
	var sid := Peek(REG_V32, 4);
	E_loadstackref(sid);
	E_callhelper("_lshift4");
}

gen v32 := RSHIFTU4(v32, y)
{
	var sid := Peek(REG_V32, 4);
	E_loadstackref(sid);
	E_callhelper("_rshiftu4");
}

gen v32 := RSHIFTS4(v32, y)
{
	var sid := Peek(REG_V32, 4);
	E_loadstackref(sid);
	E_callhelper("_rshifts4");
}

// --- Casts ----------------------------------------------------------------

gen v32 := CAST14(a, sext==0)
{
	var sid := Push(REG_V32, 4);

	E_st(REG_A);
	E_stackref(sid);
	E_nl();

	E_loadconst(REG_A, 0);

	E_st(REG_A);
	E_stackref(sid+1);
	E_nl();

	E_st(REG_A);
	E_stackref(sid+2);
	E_nl();

	E_st(REG_A);
	E_stackref(sid+3);
	E_nl();
}

gen v32 := CAST24(xa, sext==0)
{
	var sid := Push(REG_V32, 4);

	E_st(REG_A);
	E_stackref(sid);
	E_nl();

	E_st(REG_X);
	E_stackref(sid+1);
	E_nl();

	E_loadconst(REG_A, 0);

	E_st(REG_A);
	E_stackref(sid+2);
	E_nl();

	E_st(REG_A);
	E_stackref(sid+3);
	E_nl();
}

gen a := CAST21(xa|a16:rhs)
{
	if $rhs != REG_XA then
		var sid := Pop(REG_V32, 2);
		E_ld(REG_A);
		E_stackref(sid);
		E_nl();
	end if;
}

gen a := CAST41(v32)
{
	var sid := Pop(REG_V32, 4);
	E_ld(REG_A);
	E_stackref(sid);
	E_nl();
}

// --- Case -----------------------------------------------------------------

gen STARTCASE1(a);

gen STARTCASE2(xa);

gen STARTCASE4(v32)
{
	E("\tSTARTCASE4\n");
}

gen WHENCASE1():c
{
	E("\tWHENCASE1\n");
}

gen WHENCASE2():c uses a
{
	E("\tWHENCASE2\n");
}

gen WHENCASE4():c uses a
{
	E("\tWHENCASE4\n");
}

gen ENDCASE();

// --- Strings --------------------------------------------------------------

gen xa := STRING():s
{
	R_flush($$);
	var sid := E_string($s.text);

	E_ld(REG_A);
	E("#<");
	EmitByte(COO_ESCAPE_THISCOO);
	EmitByte('c');
	E_u16(sid);
	E_nl();

	E_ld(REG_X);
	E("#>");
	EmitByte(COO_ESCAPE_THISCOO);
	EmitByte('c');
	E_u16(sid);
	E_nl();
}

// --- Initialisers ---------------------------------------------------------

gen STARTINIT():s
{
	EmitterPushChunk();
	E_h16(current_subr.id);
	E($s.sym.vardata.externname);
	E(":\n");
}

gen ENDINIT()
{
	EmitterPopChunk('S');
}

gen INIT1():c
{
	E("\t.byte ");
	E_u8($c.value as uint8);
	E_nl();
}

gen INIT2():c
{
	E("\t.word ");
	E_u16($c.value as uint16);
	E_nl();
}

gen INIT4():c
{
	E("\t.dword ");
	E_u32($c.value as uint32);
	E_nl();
}

gen INITS():s
{
	var sid := E_string($s.text);

	E("\t.word ");
	EmitByte(COO_ESCAPE_THISCOO);
	EmitByte('c');
	E_u16(sid);
	E_nl();
}

// --- Inline assembly ------------------------------------------------------

gen ASMSTART()
{
	R_flushall();
	E_tab();
}

gen ASMTEXT():t
{
	E($t.text);
	E_space();
}

gen ASMSYMBOL():s
{
	if $s.sym.kind == VAR then
		E_symref($s.sym, 0);
	else
		E_subref($s.sym.subr);
	end if;
	E_space();
}

gen ASMVALUE():c
{
	EmitByte('(');
	E_i32($c.value);
	EmitByte(')');
}

gen ASMEND()
{
    E_nl();
}

$include "arch6502.ng.h"


