#sub arch_gen_copy_word(iop: [BEIop])
#    $if DEBUG
#        print("* copy ");
#        print_ea(&iop.left);
#        print(" to ");
#        print_ea(&iop.dest);
#        print_newline();
#    $endif
#    
#    sub address_of()
#        var candidates: uint8;
#        if iop.dest.flags == EA_DEREF then
#            candidates := REG_A;
#        else
#            candidates := REG_A|REG_X;
#        end if;
#
#        var location: uint8 := allocate_reg(candidates);
#        ld_imm_adr_lo(location, &iop.left);
#        save_value_with_index_or_offset(location, &iop.dest, 0);
#        ld_imm_adr_hi(location, &iop.left);
#        save_value_with_index_or_offset(location, &iop.dest, 1);
#    end sub;
#
#    check_wide_ea(&iop.left);
#    check_wide_ea(&iop.dest);
#    if is_number_thing(iop.left.obj_id) != 0 then
#        var value: uint16 := get_value_of_number(iop.left.obj_id) as uint16;
#        var candidates: uint8;
#        if iop.dest.flags == EA_DEREF then
#            candidates := REG_A;
#        else
#            candidates := REG_A|REG_X;
#        end if;
#
#        var location: uint8 := find_or_load_int(value as uint8, candidates);
#        save_value_with_index_or_offset(location, &iop.dest, 0);
#        free_reg(location);
#        location := find_or_load_int((value >> 8) as uint8, candidates);
#        save_value_with_index_or_offset(location, &iop.dest, 1);
#    elseif is_data_thing(iop.left.obj_id) != 0 then
#        if iop.left.flags == EA_LEA then
#            address_of();
#        else
#            arch_gen_copy_wide(iop);
#        end if;
#    elseif is_string_thing(iop.left.obj_id) != 0 then
#        address_of();
#    else
#        print("don't know how to load ");
#        print_ea(&iop.left);
#        halt();
#    end if;
#end sub;

sub regular_alu_word_op(iop: [BEIop], opcode: uint8)
    $if DEBUG
        print("* GENERATE: aluop 0x");
        print_hex_i8(opcode);
        print(": ");
        print_ea(&iop.left);
        if opcode != 0 then
            print(", ");
            print_ea(&iop.right);
        end if;
        print(" => ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    check_widec_ea(&iop.left);
    if opcode != 0 then
        check_widec_ea(&iop.right);
    end if;
    check_widec_ea(&iop.dest);

    var offset: uint8;
    sub aluop(ea: [EffectiveAddress], subopcode: uint8)
        if ea.flags == EA_DEREF then
            find_or_load_fixed_int(offset + (get_value_of_number(ea.numoff_id) as uint8), REG_Y);
            var old_numoff_id: uint16 := ea.numoff_id;
            ea.numoff_id := 0;
            aluop_value_with_index(ea, REG_Y, subopcode);
            ea.numoff_id := old_numoff_id;
            free_reg(REG_Y);
        else
            aluop_value_with_offset(ea, offset, subopcode);
        end if;
    end sub;

    sub iterate()
        aluop(&iop.left, 0xad);    # LDA abs
        if opcode != 0 then
            aluop(&iop.right, opcode); # actual ALU operation
        end if;
        aluop(&iop.dest, 0x8d);    # STA abs
    end sub;

    allocate_fixed_reg(REG_A);
    offset := 0;
    iterate();
    offset := 1;
    iterate();
    free_reg(REG_A);
end sub;

sub arch_gen_copy_word(iop: [BEIop])
    regular_alu_word_op(iop, 0); # simple copy, no actual ALU involved
end sub;

sub arch_gen_add_word(iop: [BEIop])
    write_byte(0x18); # CLC
    regular_alu_word_op(iop, 0x6D); # ADC abs
end sub;

sub arch_gen_sub_word(iop: [BEIop])
    write_byte(0x38); # SEC
    regular_alu_word_op(iop, 0xED); # SBC abs
end sub;