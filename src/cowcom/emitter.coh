var outfcb: FCB;

const RECORD_SIZE := 128;

record EmitterRecord is
	data: uint8[RECORD_SIZE];
	ptr: uint8;
	next: [EmitterRecord];
end record;

record EmitterChunk is
	next: [EmitterChunk];
	first_record: [EmitterRecord];
	current_record: [EmitterRecord];
	length: uint16;
end record;

var current_chunk: [EmitterChunk];

sub E_b8(byte: uint8) is
	if current_chunk != (0 as [EmitterChunk]) then
		var r := current_chunk.current_record;
		if r.ptr == RECORD_SIZE then
			r := Alloc(@bytesof EmitterRecord) as [EmitterRecord];
			current_chunk.current_record.next := r;
			current_chunk.current_record := r;
		end if;

		r.data[r.ptr] := byte;
		r.ptr := r.ptr + 1;
		current_chunk.length := current_chunk.length + 1;
	end if;
end sub;

sub E_b16(word: uint16) is
	E_b8(word as uint8);
	E_b8((word>>8) as uint8);
end sub;

sub E_b32(quad: uint32) is
	E_b16(quad as uint16);
	E_b16((quad>>16) as uint16);
end sub;

sub E_space() is
	E_b8(' ');
end sub;

sub E_comma() is
	E_b8(',');
end sub;

sub E_tab() is
	E_b8('\t');
end sub;

sub E_nl() is
	E_b8('\n');
end sub;

sub E_openp() is
	E_b8('(');
end sub;

sub E_closep() is
	E_b8(')');
end sub;

sub E(text: string) is
	loop
		var c := [text];
		text := text + 1;
		if c == 0 then
			break;
		end if;
		E_b8(c);
	end loop;
end sub;

sub E_u32(value: uint32) is
	var buffer: uint8[12];
	var p := &buffer[0];
	var pe := UIToA(value, 10, p);

	loop
		var c := [p];
		if c == 0 then
			break;
		end if;
		E_b8(c);
		p := @next p;
	end loop;
end sub;

sub E_u16(value: uint16) is
	E_u32(value as uint32);
end sub;

sub E_u8(value: uint8) is
	E_u32(value as uint32);
end sub;

sub E_i8(value: int8) is
	if value < 0 then
		E_b8('-');
		value := -value;
	else
		E_b8('+');
	end if;
	E_u8(value as uint8);
end sub;

sub E_i16(value: int16) is
	if value < 0 then
		E_b8('-');
		value := -value;
	else
		E_b8('+');
	end if;
	E_u16(value as uint16);
end sub;

sub E_i32(value: int32) is
	if value < 0 then
		E_b8('-');
		value := -value;
	else
		E_b8('+');
	end if;
	E_u32(value as uint32);
end sub;

sub E_h(value: uint32, width: uint8) is
	var buffer: uint8[5];
	var pe := UIToA(value as uint32, 16, &buffer[0]);
	var padding := width - (pe - &buffer[0]) as uint8;
	while padding != 0 loop
		E_b8('0');
		padding := padding - 1;
	end loop;
	E(&buffer[0]);
end sub;

sub E_h8(value: uint8) is
	E_h(value as uint32, 2);
end sub;

sub E_h16(value: uint16) is
	E_h(value as uint32, 4);
end sub;

sub E_h32(value: uint32) is
	E_h(value as uint32, 8);
end sub;

sub E_labelref(labelid: uint16) is
	E_b8(COO_ESCAPE_THISCOO);
	E_h16(labelid);
end sub;

sub E_subref(subr: [Subroutine]) is
	if subr == current_subr then
		E_b8(COO_ESCAPE_THISSUB);
	else
		E_b8(COO_ESCAPE_SUBREF);
		E_b16(subr.id);
	end if;
end sub;

sub E_wsref(id: uint16, wsid: uint8, off: uint16) is
	E_b8(COO_ESCAPE_WSREF);
	E_b16(id);
	E_b8(wsid);
	E_b16(off);
end sub;

sub EmitterPushChunk() is
	var chunk := Alloc(@bytesof EmitterChunk) as [EmitterChunk];
	chunk.current_record := Alloc(@bytesof EmitterRecord) as [EmitterRecord];
	chunk.first_record := chunk.current_record;
	chunk.next := current_chunk;
	current_chunk := chunk;
end sub;

sub EmitterPopChunk(type: uint8) is
	FCBPutChar(&outfcb, type);

	var len := current_chunk.length;
	FCBPutChar(&outfcb, len as uint8);
	FCBPutChar(&outfcb, (len>>8) as uint8);

	var r := current_chunk.first_record;
	while r != (0 as [EmitterRecord]) loop
		var i: uint8 := 0;
		while i != r.ptr loop
			FCBPutChar(&outfcb, r.data[i]);
			i := i + 1;
		end loop;

		var nextr := r.next;
		Free(r as [uint8]);
		r := nextr;
	end loop;

	var nextchunk := current_chunk.next;
	Free(current_chunk as [uint8]);
	current_chunk := nextchunk;
end sub;

sub EmitterOpenfile(filename: string) is
	if FCBOpenOut(&outfcb, filename) != 0 then
		SimpleError("cannot open output file");
	end if;
end sub;

sub EmitterClosefile() is
	FCBPutChar(&outfcb, 'E');
	FCBPutChar(&outfcb, 0);
	FCBPutChar(&outfcb, 0);
	if FCBClose(&outfcb) != 0 then
		SimpleError("cannot close output file");
	end if;
end sub;

sub EmitterDeclareSubroutine(subr: [Subroutine]) is
	EmitterPushChunk();
	E_b16(subr.id);
	E(subr.name);
	EmitterPopChunk('N');
end sub;

sub EmitterDeclareExternalSubroutine(id: uint16, external: string) is
	EmitterPushChunk();
	E_b16(id);
	E(external);
	EmitterPopChunk('X');
end sub;

sub EmitterReferenceSubroutine(user: [Subroutine], used: [Subroutine]) is
	EmitterPushChunk();
	E_b16(user.id);
	E_b16(used.id);
	EmitterPopChunk('R');
end sub;

sub EmitterDeclareWorkspace(subr: [Subroutine], wid: uint8, workspace: Size) is
	EmitterPushChunk();
	E_b16(subr.id);
	E_b8(wid);
	E_b16(workspace as uint16);
	EmitterPopChunk('W');
end sub;

