sub InitVariable(subr: [Subroutine], symbol: [Symbol], type: [Type]) is
	CheckNotPartialType(type);
	symbol.vardata.type := type;
	symbol.vardata.subr := subr;
	ArchInitVariable(symbol);
	#print("var ");
	#print(symbol.name);
	#print(" at ");
	#print(current_subr.name);
	#print(" 0x");
	#print_hex_i16(symbol.vardata.offset as uint16);
	#print("+");
	#print_hex_i16(symbol.vardata.type.typedata.width as uint16);
	#print_nl();
end sub;

sub MakePointerType(type: [Type]): (ptrtype: [Type]) is
	ptrtype := type.pointerto;
	if ptrtype == (0 as [Type]) then
		ptrtype := AllocNewType();
		ptrtype.kind := TYPE_POINTER;
		ptrtype.width := intptr_type.width;
		ptrtype.alignment := intptr_type.alignment;
		ptrtype.stride := intptr_type.stride;
		ptrtype.pointertype.element := type;
		type.pointerto := ptrtype;

		AddTypeToNamespace(type.symbol.namespace, ptrtype, StrDupBraced(type.symbol.name));
	end if;
end sub;

sub MakeArrayType(type: [Type], size: Size): (arraytype: [Type]) is
	CheckNotPartialType(type);

	arraytype := AllocNewType();
	arraytype.kind := TYPE_ARRAY;
	var w: Size := 0;
	if size > 0 then
		w := type.stride * (size - 1) + type.width;
	end if;
	arraytype.width := w;
	arraytype.alignment := type.alignment;
	arraytype.stride := type.stride * size;
	arraytype.arraytype.element := type;
	arraytype.arraytype.size := size;
	arraytype.arraytype.indextype := ArchGuessIntType(0, (size-1) as Arith);

	AddTypeToNamespace(type.symbol.namespace, arraytype, StrDupArrayed(type.symbol.name, size));
end sub;

sub MakeSubroutineType(subr: [Subroutine]): (type: [Type]) is
	type := subr.type;
	if type == (0 as [Type]) then
		type := AllocNewType();
		type.kind := TYPE_SUBROUTINE;
		type.width := intptr_type.width;
		type.alignment := intptr_type.alignment;
		type.stride := intptr_type.stride;
		type.subrtype.subr := subr;
		subr.type := type;

		AddTypeToNamespace(subr.symbol.namespace, type, InternalStrDup(subr.symbol.name));
	end if;
end sub;

# Called after a subroutine has been generated. This allows us to free up some
# of the resources used. Note that we can't free *everything* until our parent
# gets destructed, because parameters and types which they depend on might be
# referred to.
sub DestructSubroutineContents(subr: [Subroutine]) is
	var pending: [Symbol] := 0 as [Symbol];

	# Destroys a sumbol (which isn't a subroutine).
	sub DestructSymbol(symbol: [Symbol]) is
		Free(symbol.name);
		FreeSymbol(symbol);
	end sub;

	# Adds all members of the namespace to the pending list.
	sub QueueNamespace(namespace: [Namespace]) is
		while namespace.first != (0 as [Symbol]) loop
			var s := namespace.first;
			namespace.first := s.next;

			s.next := pending;
			pending := s;
		end loop;
	end sub;

	# Destroys a subroutine, freeing all parameters, variables, types etc.
	sub QueueSubroutine(subr: [Subroutine]) is
		QueueNamespace(&subr.namespace);
		Free(subr as [uint8]);
	end sub;

	# Find the last parameter.

	var last_parameter := subr.first_output_parameter;
	if last_parameter == (0 as [Symbol]) then
		last_parameter := subr.first_input_parameter;
	end if;
	if last_parameter != (0 as [Symbol]) then
		loop
			var next := last_parameter.vardata.next_parameter;
			if next == (0 as [Symbol]) then
				break;
			end if;
			last_parameter := next;
		end loop;
	end if;

	# last_parameter is now pointing at the last parameter, or null if there
	# are none.

	pending := subr.namespace.first;
	if last_parameter != (0 as [Symbol]) then
		pending := last_parameter.next;
	end if;

	while pending != (0 as [Symbol]) loop
		var symbol := pending;
		pending := pending.next;
		
		case symbol.kind is
			when SUB:
				QueueSubroutine(symbol.subr);

			when TYPE:
				if symbol.typedata.kind == TYPE_RECORD then
					QueueNamespace(&symbol.typedata.recordtype.namespace);
				end if;

			when VAR:
				# Do not destruct the variable type, as it will be destructed
				# via the owning namespace or type.
		end case;
		DestructSymbol(symbol);
	end loop;

	if last_parameter != (0 as [Symbol]) then
		last_parameter.next := 0 as [Symbol];
	else
		subr.namespace.first := 0 as [Symbol];
	end if;
	subr.namespace.last := last_parameter;
end sub;

sub CopyParameterList(param: [Symbol], subr: [Subroutine]): (newparam: [Symbol]) is
	newparam := 0 as [Symbol];
	var lastparam := 0 as [Symbol];

	while param != 0 as [Symbol] loop
		var p := AddSymbol(&subr.namespace, InternalStrDup(param.name));
		p.kind := VAR;
		p.vardata.type := param.vardata.type;
		p.vardata.subr := param.vardata.subr;
		p.vardata.offset := param.vardata.offset;
		if lastparam != 0 as [Symbol] then
			lastparam.vardata.next_parameter := p;
		end if;
		lastparam := p;
		if newparam == 0 as [Symbol] then
			newparam := p;
		end if;

		param := param.vardata.next_parameter;
	end loop;
end sub;

