record StackSlot
    operator: uint8; # or 0
    left: EffectiveAddress;
    right: EffectiveAddress;
end record;

var stack: StackSlot[32];
var stack_pos: uint8;
var empty_slot: StackSlot[1];

sub init_stack()
    zero_memory(&stack[0] as [int8], stack@bytes);
    zero_memory(&empty_slot[0] as [int8], empty_slot@bytes);
    stack_pos := 0;
end sub;

sub print_stack()
    print("stack:\n");
    var i: uint8 := 0;
    while i < stack_pos loop
        print(" 0x");
        print_hex_i8(stack[i].operator);
        print_char(' ');
        print_ea(&stack[i].left);
        print_char(' ');
        print_ea(&stack[i].right);
        print_newline();
        i := i + 1;
    end loop;
end sub;

sub copy_slot(src: [StackSlot], dest: [StackSlot])
    copy_memory(src as [int8], dest as [int8], StackSlot@bytes);
end sub;

sub push_new_slot(): (slot: [StackSlot])
    slot := &stack[stack_pos];
    zero_memory(slot as [int8], StackSlot@bytes);
    stack_pos := stack_pos + 1;
    if stack_pos == stack@size then
        print("stack overflow");
        halt();
    end if;
end sub;

sub peek_slot(offset: int8): (slot: [StackSlot])
    var i: uint8 := stack_pos + offset;
    if i >= stack_pos then
        slot := &empty_slot[0];
    else
        slot := &stack[i];
    end if;
end sub;

sub pop_slot(slot: [StackSlot])
    if stack_pos == 0 then
        print("stack underflow");
        halt();
    end if;
    stack_pos := stack_pos - 1;
    copy_slot(&stack[stack_pos], slot);
end sub;

sub discard_slots(count: uint8)
    if stack_pos < count then
        print("stack underflow");
        halt();
    end if;
    stack_pos := stack_pos - count;
end sub;

#sub peek_ea(offset: int8): (ea: [EffectiveAddress])
#    var i: uint8 := stack_pos + offset;
#    if i >= stack_pos then
#        ea := &blank_ea[0];
#    else
#        ea := &stack[i];
#    end if;
#end sub;
#
#sub pop_eas(count: uint8)
