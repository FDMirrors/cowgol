sub check_widec_ea(ea: [EffectiveAddress])
    if (ea.flags == EA_VALUE) and (is_number_thing(ea.obj_id) != 0) then
        var thing: [NumberThing] := find_thing(ea.obj_id) as [NumberThing];
        thing.segment := SEGMENT_CONST;
    end if;
end sub;

sub check_wide_ea(ea: [EffectiveAddress])
    check_widec_ea(ea);
    if (ea.flags == EA_DEREF) and (get_value_of_number(ea.numoff_id) != 0) then
        print("wide pointer EA with numeric offset: ");
        print_ea(ea);
        halt();
    end if;
end sub;

sub addressing_mode(iop: [BEIop]): (mode: uint8)
    if iop.dest.flags == EA_DEREF then
        mode := 0b001;
    else
        mode := 0b000;
    end if;
    if iop.left.flags == EA_DEREF then
        mode := mode | 0b010;
    end if;
    if iop.right.flags == EA_DEREF then
        mode := mode | 0b100;
    end if;
end sub;

sub inc_numoff(numoff_id: uint16): (new_numoff_id: uint16)
        new_numoff_id := add_number_by_value(get_value_of_number(numoff_id) + 1);
end sub;

sub regular_alu_wide_op(iop: [BEIop], opcode: uint8, looped: uint8)
    $if DEBUG
        print("* GENERATE: wide aluop 0x");
        print_hex_i8(opcode);
        print(": ");
        print_ea(&iop.left);
        if opcode != 0 then
            print(", ");
            print_ea(&iop.right);
        end if;
        print(" => ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    sub check(ea: [EffectiveAddress])
        check_widec_ea(ea);
        if (ea.flags == EA_LEA) or
            ((ea.flags == EA_DEREF) and (ea.numoff_id != 0)) or
            (ea.varoff_id != 0) then
            looped := 0;
        end if;
    end sub;

    check(&iop.left);
    if opcode != 0 then
        check(&iop.right);
    end if;
    check(&iop.dest);

    if iop.width == 4 then
        looped := 1;
    end if;

    if looped != 0 then
        $if DEBUG
            print("* using looped implementation\n");
        $endif

        allocate_fixed_reg(REG_A);
        find_or_load_fixed_int(iop.width - 1, REG_X);
        find_or_load_fixed_int(0, REG_Y);
        var label: uint8 := create_label();
        write_label_iop(label);

        sub setup_looped(ea: [EffectiveAddress])
            insn_init();
            insn.obj_id := ea.obj_id;
            insn.indexreg := REG_Y;
            insn.datareg := REG_A;
            if ea.flags == EA_DEREF then
                insn.mode := MODE_IND;
            else
                insn.mode := MODE_DIR;
                insn.offset := get_value_of_number(ea.numoff_id) as uint16;
            end if;
        end sub;

        setup_looped(&iop.left);
        insn_load_object();

        if opcode != 0 then
            setup_looped(&iop.right);
            insn_alu_object(opcode);
        end if;

        setup_looped(&iop.dest);
        insn_save_object();

        write_byte(0xC8); # INY
        write_byte(0xCA); # DEX
        write_cg_6502_conditional_iop(0x10, label); # BPL rel

        flush_cached_values(REG_X|REG_Y);
        free_reg(REG_A|REG_X|REG_Y);
    else
        $if DEBUG
            print("* using unrolled implementation\n");
        $endif
        
        var offset: uint8;
        sub iterate_unrolled()
            var indexreg: uint8;

            indexreg := setup_insn(&iop.left, offset, REG_A);
            allocate_fixed_reg(REG_A);
            insn_load_object();
            free_reg(indexreg);

            if opcode != 0 then
                indexreg := setup_insn(&iop.right, offset, REG_A);
                insn_alu_object(opcode);
                free_reg(indexreg);
            end if;

            indexreg := setup_insn(&iop.dest, offset, REG_A);
            insn_save_object();
            free_reg(REG_A);
            free_reg(indexreg);
        end sub;

        offset := 0;
        while offset != iop.width loop
            iterate_unrolled();
            offset := offset + 1;
        end loop;
    end if;
end sub;

sub arch_gen_copy_wide(iop: [BEIop])
    regular_alu_wide_op(iop, 0, 0);
end sub;

sub copy_value_to_param(ea: [EffectiveAddress], param: uint8)
    var iop: BEIop;
    zero_memory(&iop as [int8], iop@bytes);
    iop.width := 2;

    copy_ea(ea, &iop.left);
    if iop.left.flags == EA_VALUE then
        iop.left.flags := EA_LEA;
    elseif iop.left.flags == EA_DEREF then
        iop.left.flags := EA_VALUE;
    elseif iop.left.flags == EA_LEA then
        print("can't have LEA here");
        halt();
    end if;

    iop.dest.flags := EA_VALUE;
    iop.dest.obj_id := find_bootstrap_symbol(TOKEN_PARAMS);
    iop.dest.numoff_id := add_number_by_value(param as int32);

    regular_alu_wide_op(&iop, 0, 0);
end sub;

sub do_2op_helper(iop: [BEIop])
    check_wide_ea(&iop.left);
    check_wide_ea(&iop.dest);

    write_back_precious_values(REG_MASK);

    copy_value_to_param(&iop.dest, 0);
    copy_value_to_param(&iop.left, 2);

    flush_cached_values(REG_MASK);
end sub;

sub do_3op_helper(iop: [BEIop])
    check_wide_ea(&iop.left);
    check_wide_ea(&iop.right);
    check_wide_ea(&iop.dest);

    write_back_precious_values(REG_MASK);

    copy_value_to_param(&iop.dest, 0);
    copy_value_to_param(&iop.left, 2);
    copy_value_to_param(&iop.right, 4);

    flush_cached_values(REG_MASK);
end sub;

sub fast_increment_wide(width: uint8, src: [EffectiveAddress], dest: [EffectiveAddress])
    $if DEBUG
        print("* GENERATE: fast increment in place: ");
        print_ea(src);
        print(" => ");
        print_ea(dest);
        print_newline();
    $endif

    if is_same_ea_ignoring_type(src, dest) == 0 then
        print("can't increment in place");
        halt();
    end if;

    var indexreg: uint8;
    var noinclabel: uint8 := create_label();

    var offset: uint8;
    sub inc_once()
        indexreg := setup_insn(src, offset, 0);
        insn_mutate_object(0xEE); # INC abs
        free_reg(indexreg);
    end sub;

    offset := 0;
    inc_once();
    offset := 1;
    while offset != width loop
        write_cg_6502_conditional_iop(0xD0, noinclabel); # BNE label
        inc_once();
        offset := offset + 1;
    end loop;
    write_label_iop(noinclabel);
end sub;

sub arch_gen_sext(iop: [BEIop])
    $if DEBUG
        print("* GENERATE: sext: ");
        print_ea(&iop.left);
        print(" => ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    flush_value(&iop.left);

    var srcwidth: uint8 := get_width_of_type(iop.left.type_id) as uint8;
    var destwidth: uint8 := iop.width;

    var datacandidates: uint8;
    var hicandidates: uint8;
    if (iop.left.flags == EA_DEREF) or (iop.dest.flags == EA_DEREF) then
        datacandidates := REG_A;
        hicandidates := REG_X;
    else
        datacandidates := REG_A|REG_X|REG_Y;
        hicandidates := REG_X|REG_Y;
    end if;

    var hireg: uint8 := find_or_load_int(0, hicandidates);
    var datareg: uint8 := allocate_reg(datacandidates);
    var indexreg: uint8;

    find_or_load_fixed_int(0, REG_X);

    # Copy the low bytes, intact.

    var offset: uint8 := 0;
    loop
        indexreg := setup_insn(&iop.left, offset, datareg);
        insn_load_object();
        free_reg(indexreg);

        indexreg := setup_insn(&iop.dest, offset, datareg);
        insn_save_object();
        free_reg(indexreg);

        offset := offset + 1;
        if offset == srcwidth then
            break;
        end if;
    end loop;

    # Compute the high byte.

    write_byte(0x10); # BPL rel
    write_byte(0x01); # one byte forwards
    if hireg == REG_X then
        write_byte(0xCA); # DEX
    else
        write_byte(0x88); # DEY
    end if;

    if iop.dest.flags == EA_DEREF then
        t_reg_reg(hireg, datareg);
        hireg := datareg;
    end if;

    # Now fill the high bytes.

    loop
        indexreg := setup_insn(&iop.dest, offset, hireg);
        insn_save_object();
        free_reg(indexreg);

        offset := offset + 1;
        if offset == destwidth then
            break;
        end if;
    end loop;
end sub;

sub arch_gen_zext(iop: [BEIop])
    $if DEBUG
        print("* GENERATE: zext: ");
        print_ea(&iop.left);
        print(" => ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    var srcwidth: uint8 := get_width_of_type(iop.left.type_id) as uint8;
    var destwidth: uint8 := iop.width;

    var datacandidates: uint8;
    if (iop.left.flags == EA_DEREF) or (iop.dest.flags == EA_DEREF) then
        datacandidates := REG_A;
    else
        datacandidates := REG_A|REG_X|REG_Y;
    end if;

    var offset: uint8;
    var datareg: uint8;
    var indexreg: uint8;
    if srcwidth == 1 then
        # Optimised code path because we're reading from a byte.

        datareg := find_or_load_value(&iop.left, datacandidates);

        indexreg := setup_insn(&iop.dest, 0, datareg);
        insn_save_object();
        free_reg(indexreg);
        offset := 1;
    else
        # Copy the low bytes, intact.

        offset := 0;
        flush_value(&iop.left);
        datareg := allocate_reg(datacandidates);
        loop
            indexreg := setup_insn(&iop.left, offset, datareg);
            insn_load_object();
            free_reg(indexreg);

            indexreg := setup_insn(&iop.dest, offset, datareg);
            insn_save_object();
            free_reg(indexreg);

            offset := offset + 1;
            if offset == srcwidth then
                break;
            end if;
        end loop;
    end if;
    free_reg(datareg);

    # Now fill the high bytes.

    datareg := find_or_load_int(0, datacandidates);
    loop
        indexreg := setup_insn(&iop.dest, offset, datareg);
        insn_save_object();
        free_reg(indexreg);

        offset := offset + 1;
        if offset == destwidth then
            break;
        end if;
    end loop;
    free_reg(datareg);
end sub;

sub arch_gen_lsl_wide(iop: [BEIop])
    do_2op_helper(iop);

    find_or_load_fixed_int(iop.width, REG_X);
    find_or_load_fixed_value(&iop.right, REG_A);

    var helper: uint16;
    if iop.width == 2 then
        helper := TOKEN_LSL16;
    else
        helper := TOKEN_LSL32;
    end if;
    write_byte(0x20); # JSR abs
    write_address_iop(IOP_ADDRESS, find_bootstrap_symbol(helper), 0);

    flush_cached_values(REG_MASK);
end sub;

sub arch_gen_lsr_wide(iop: [BEIop])
    do_2op_helper(iop);

    find_or_load_fixed_value(&iop.right, REG_A);

    var helper: uint16;
    if iop.width == 2 then
        helper := TOKEN_LSR16;
    else
        helper := TOKEN_LSR32;
    end if;
    write_byte(0x20); # JSR abs
    write_address_iop(IOP_ADDRESS, find_bootstrap_symbol(helper), 0);

    flush_cached_values(REG_MASK);
end sub;

sub arch_gen_asr_wide(iop: [BEIop])
    do_2op_helper(iop);

    find_or_load_fixed_value(&iop.right, REG_A);

    var helper: uint16;
    if iop.width == 2 then
        helper := TOKEN_ASR16;
    else
        helper := TOKEN_ASR32;
    end if;
    write_byte(0x20); # JSR abs
    write_address_iop(IOP_ADDRESS, find_bootstrap_symbol(helper), 0);

    flush_cached_values(REG_MASK);
end sub;

sub arch_gen_simple_wide(iop: [BEIop], token: uint16)
    do_3op_helper(iop);

    write_byte(0x20); # JSR abs
    write_address_iop(IOP_ADDRESS, find_bootstrap_symbol(token), 0);

    flush_cached_values(REG_MASK);
end sub;

sub arch_gen_not_wide(iop: [BEIop])
    $if DEBUG
        print("* GENERATE: wide not: ");
        print_ea(&iop.left);
        if opcode != 0 then
            print(", ");
            print_ea(&iop.right);
        end if;
        print(" => ");
        print_ea(&iop.dest);
        print_newline();
    $endif

    check_widec_ea(&iop.left);
    check_widec_ea(&iop.dest);

    var offset: uint8;
    sub iterate_unrolled()
        var indexreg: uint8;

        indexreg := setup_insn(&iop.left, offset, REG_A);
        allocate_fixed_reg(REG_A);
        insn_load_object();
        free_reg(indexreg);

        write_word(0xFF49); # eor #0xff

        indexreg := setup_insn(&iop.dest, offset, REG_A);
        insn_save_object();
        free_reg(REG_A);
        free_reg(indexreg);
    end sub;

    offset := 0;
    while offset != iop.width loop
        iterate_unrolled();
        offset := offset + 1;
    end loop;
end sub;
