%[
	record ImmOp is
		value: Arith;
	end record;

	record AdrOp is
		sym: [Symbol];
		off: Size;
	end record;

	record Operand is
		imm @at(0): ImmOp;
		adr @at(0): AdrOp;
	end record;
%]

%{
	sub ArchAlignUp(value: Size, alignment: uint8): (newvalue: Size) is
		var a := (alignment-1) as Size;
		newvalue := (value+a) & ~a;
	end sub;

	sub E_symref(sym: [Symbol], off: Size) is
		if sym.wsid == WSID_STATIC then
			E_wsref(sym.subr.id, sym.wsid, sym.off);
			if off != 0 then
				E_i16(off as int16);
			end if;
		else
			E_wsref(sym.subr.id, sym.wsid, sym.off + off);
		end if;
	end sub;

	sub R_flushall() is
		RegCacheFlush(ALL_REGS);
	end sub;

	sub R_flush(reg: RegId) is
		RegCacheFlush(FindConflictingRegisters(reg));
	end sub;

	sub AllocPLabel(): (lid: uint16) is
		# Cheap and cheerful way to allocate a label which won't overlap the
		# frontend's numbering.
		lid := -AllocLabel();
	end sub;

	sub E_const() is
		E_b8('#');
	end sub;
	
	sub E_label(label: LabelRef) is
		E_labelref(label);
		E(":\n");
	end sub;

	sub E_reg(reg: RegId) is
		case reg is
			when REG_D0B: E("d0");
			when REG_D1B: E("d1");
			when REG_D2B: E("d2");
			when REG_D3B: E("d3");
			when REG_D4B: E("d4");
			when REG_D5B: E("d5");
			when REG_D6B: E("d6");
			when REG_D0W: E("d0");
			when REG_D1W: E("d1");
			when REG_D2W: E("d2");
			when REG_D3W: E("d3");
			when REG_D4W: E("d4");
			when REG_D5W: E("d5");
			when REG_D6W: E("d6");
			when REG_D0L: E("d0");
			when REG_D1L: E("d1");
			when REG_D2L: E("d2");
			when REG_D3L: E("d3");
			when REG_D4L: E("d4");
			when REG_D5L: E("d5");
			when REG_D6L: E("d6");
			when REG_A0: E("a0");
			when REG_A1: E("a1");
			when REG_A2: E("a2");
			when REG_A3: E("a3");
			when REG_A4: E("a4");
			when else:
				StartError();
				print("bad reg ");
				print_hex_i32(reg as uint32);
				EndError();
		end case;
	end sub;

	sub E_insn(insn: string) is
		E_tab();
		E(insn);
		E_space();
	end sub;

	sub E_push(reg: RegId) is
		E_insn("stwu");
		E_reg(reg);
		E(",-4(1)\n");
	end sub;

	sub E_pop(reg: RegId) is
		R_flush(reg);
		E_insn("lwz");
		E_reg(reg);
		E(",0(1)\n");
		E("\taddi 1,1,4\n");
	end sub;

	sub E_jump(insn: string, label: LabelRef) is
		E_insn(insn);
		E_labelref(label);
		E_nl();
	end sub;

	sub E_b(label: LabelRef) is
		E_jump("b", label);
	end sub;

	sub E_op(rhs: RegId, rhsop: [Operand]) is
		if (rhs & (REGCLASS_R32|REGCLASS_R16|REGCLASS_R8)) != 0 then
			E_reg(rhs);
		elseif rhs == REG_ADR then
			E_const();
			E_symref(rhsop.adr.sym, rhsop.adr.off);
		elseif rhs == REG_IMM then
			E_const();
			E_i32(rhsop.imm.value);
		else
			SimpleError("bad op");
		end if;
	end sub;

	sub is_i16(value: Arith): (result: uint8) is
		if (value >= -32768) and (value <= 32767) then
			result := 1;
		else
			result := 0;
		end if;
	end sub;

	sub is_u16(value: Arith): (result: uint8) is
		if (value >= 0) and (value <= 65535) then
			result := 1;
		else
			result := 0;
		end if;
	end sub;

	sub is_u3(value: Arith): (result: uint8) is
		result := 0;
		if (value >= 0) and (value <= 7) then
			result := 1;
		end if;
	end sub;

	sub is_short(sym: [Symbol]): (result: uint8) is
		result := 0;
		if (sym.subr == current_subr) and (sym.off < 0x7000) and (sym.wsid != WSID_STATIC) then
			result := 1;
		end if;
	end sub;

    sub ArchBeginComment() is
        E("\t# ");
    end sub;

    sub ArchEndComment() is
        E_nl();
    end sub;

	sub ArchEmitMove(src: RegId, dest: RegId) is
		if src == 0 then
			E_pop(dest);
		elseif dest == 0 then
			E_push(src);
#		elseif ((src & REGCLASS_R32) != 0) and ((dest & REGCLASS_R32) != 0) then
#			E_insn("mr");
#			E_reg(dest);
#			E_comma();
#			E_reg(src);
#			E_nl();
		else
			StartError();
			print("bad move ");
			print_hex_i32(src as uint32);
			print(" -> ");
			print_hex_i32(dest as uint32);
			EndError();
		end if;
	end sub;

	sub ArchEndInstruction() is
	end sub;

	sub ArchEndGroup() is
	end sub;
%}

wordsize uint32;

register d0b d1b d2b d3b d4b d5b d6b;
register d0w d1w d2w d3w d4w d5w d6w;
register d0l d1l d2l d3l d4l d5l d6l;
register a0 a1 a2 a3 a4;

operand param;
operand imm adr mem1 mem2 mem4;

regclass d8reg := d0b|d1b|d2b|d3b|d4b|d5b|d6b;
regclass d16reg := d0w|d1w|d2w|d3w|d4w|d5w|d6w;
regclass d32reg := d0l|d1l|d2l|d3l|d4l|d5l|d6l;
regclass areg := a0|a1|a2|a3|a4;
regclass r8 := d8reg;
regclass r16 := d16reg;
regclass r32 := d32reg|areg;

regclass op8 := r8|imm|mem1;
regclass op16 := r16|imm|mem2;
regclass op32 := r32|imm|adr|mem4;

regdata d0b uses d0b|d0w|d0l compatible r8;
regdata d1b uses d1b|d1w|d1l compatible r8;
regdata d2b uses d2b|d2w|d2l compatible r8;
regdata d3b uses d3b|d3w|d3l compatible r8;
regdata d4b uses d4b|d4w|d4l compatible r8;
regdata d5b uses d5b|d5w|d5l compatible r8;
regdata d6b uses d6b|d6w|d6l compatible r8;
regdata d0w uses d0b|d0w|d0l compatible r16;
regdata d1w uses d1b|d1w|d1l compatible r16;
regdata d2w uses d2b|d2w|d2l compatible r16;
regdata d3w uses d3b|d3w|d3l compatible r16;
regdata d4w uses d4b|d4w|d4l compatible r16;
regdata d5w uses d5b|d5w|d5l compatible r16;
regdata d6w uses d6b|d6w|d6l compatible r16;
regdata d0l uses d0b|d0w|d0l compatible r32;
regdata d1l uses d1b|d1w|d1l compatible r32;
regdata d2l uses d2b|d2w|d2l compatible r32;
regdata d3l uses d3b|d3w|d3l compatible r32;
regdata d4l uses d4b|d4w|d4l compatible r32;
regdata d5l uses d5b|d5w|d5l compatible r32;
regdata d6l uses d6b|d6w|d6l compatible r32;
regdata a0 compatible r32;
regdata a1 compatible r32;
regdata a2 compatible r32;
regdata a3 compatible r32;
regdata a4 compatible r32;

// --- Core things ----------------------------------------------------------

gen STARTFILE();
gen ENDFILE();

gen LABEL():b uses all
{
	R_flushall();
	E_label($b.label);
}

//gen JUMP():j uses all
//{
//	R_flushall();
//	E_b($j.label);
//}

// --- Subroutines ----------------------------------------------------------

gen STARTSUB() uses all
{
	RegCacheReset();

	EmitterOpenStream(current_subr);

	E("\n\n\t# ");
	E(current_subr.name);
	E(" workspace at ");
	E_b8(COO_ESCAPE_WSREF);
	E_b16(current_subr.id);
	E_b8(0);
	E_b16(0);
	E(" length ");
	E_b8(COO_ESCAPE_WSSIZE);
	E_b16(current_subr.id);
	E_b8(0);
	E_nl();

	E(".text\n");
	E_b8(COO_ESCAPE_THISSUB);
	E(":\n");

#	sub load_r31() is
#		E("\tlis 31,");
#		E_wsref(current_subr.id, 0, 0);
#		E("@h\n\tori 31,31,");
#		E_wsref(current_subr.id, 0, 0);
#		E("@l\n");
#	end sub;
#
#	E("\tmflr 0\n");
#	var count := current_subr.num_input_parameters;
#	if count == 0 then
#		E("\tstwu 0,-4(1)\n");
#		E("\tstwu 31,-4(1)\n");
#		load_r31();
#	else
#		E("\tmr 4,31\n");
#		load_r31();
#
#		var lastparam := count - 1;
#
#		while count != 0 loop
#			count := count - 1;
#			var param := GetInputParameter(current_subr, count);
#
#			var reg: RegId;
#			if count != lastparam then
#				E_pop(REG_R3);
#			end if;
#			if param.subr != current_subr then
#				E("\tlis 5,");
#				E_symref(param as [Symbol], 0);
#				E("@h\n\tori 5,5,");
#				E_symref(param as [Symbol], 0);
#				E("@l\n");
#			end if;
#
#			case param.width is
#				when 1: E_insn("stb");
#				when 2: E_insn("sth");
#				when 4: E_insn("stw");
#			end case;
#			E_reg(REG_R3);
#			E_comma();
#			if param.subr != current_subr then
#				E("0(5)\n");
#			else
#				E_u16(param.off);
#				E("(31)\n");
#			end if;
#		end loop;
#
#		E("\tstwu 0,-4(1)\n");
#		E("\tstwu 4,-4(1)\n");
#	end if;

	R_flushall();
}

gen ENDSUB() uses all
{
	E("end_");
	E_subref(current_subr);
	E(":\n");

	var count: uint8 := 0;
	var params := current_subr.num_output_parameters;

#	E("\tlwz 4,4(1)\n"); # return address
#	if params == 0 then
#		E("\tlwz 31,0(1)\n"); # old ws
#		E("\taddi 1,1,8\n");
#	else
#		E("\tlwz 5,0(1)\n"); # old ws
#		E("\taddi 1,1,8\n");
#
#		while count != params loop
#			var param := GetOutputParameter(current_subr, count);
#
#			if param.subr != current_subr then
#				E("\tlis 30,");
#				E_symref(param as [Symbol], 0);
#				E("@h\n\tori 30,30,");
#				E_symref(param as [Symbol], 0);
#				E("@l\n");
#			end if;
#
#			case param.width is
#				when 1: E_insn("lbz");
#				when 2: E_insn("lhz");
#				when 4: E_insn("lwz");
#			end case;
#			E_reg(REG_R3);
#			E_comma();
#			if param.subr == current_subr then
#				E_u16(param.off);
#				E("(31)\n");
#			else
#				E("0(30)\n");
#			end if;
#
#			if count != (params-1) then
#				E_push(REG_R3);
#			end if;
#
#			count := count + 1;
#		end loop;
#
#		E("\tmr 31,5\n");
#	end if;
#	E("\tmtlr 4\n");
#	E("\tblr\n");

	EmitterCloseStream();
	R_flushall();
}

gen RETURN() uses all
{
	R_flushall();
	E("\tb end_");
	E_subref(current_subr);
	E_nl();
}

// --- Miscellaneous --------------------------------------------------------

//gen r32 := SUBREF():s
//{
//	R_flush($$);
//	E_insn("lis");
//	E_reg($$);
//	E(", (");
//	E_subref($s.subr);
//	E(")@h\n");
//	E_insn("ori");
//	E_reg($$);
//	E_comma();
//	E_reg($$);
//	E_comma();
//	E_subref($s.subr);
//	E("@l\n");
//}

gen r8|r16|r32 := CONSTANT():c
{
	var r := RegCacheFindConstant($c.value as uint32);
	if r != 0 then
		if (r & $$) != 0 then
			return;
		end if;
		r := FindFirst(r);
		E_insn("move.l");
		E_reg(r);
	else
		E_insn("move.l");
		E_const();
		E_i32($c.value);
	end if;
	E_comma();
	E_reg($$);
	E_nl();

	R_flush($$);
	RegCacheLeavesConstant($$, $c.value as uint32);
}

gen areg := ADDRESS():a
{
	var r := RegCacheFindAddress(&$a.sym, $a.off);
	if r != 0 then
		if (r & $$) != 0 then
			return;
		end if;
		r := FindFirst(r);
		E_insn("move.l");
		E_reg(r);
	else
		E_insn("move.l");
		E_const();
		E_symref(&$a.sym, $a.off);
	end if;
	E_comma();
	E_reg($$);
	E_nl();

	R_flush($$);
	RegCacheLeavesAddress($$, &$a.sym, $a.off);
}

// --- Calls ----------------------------------------------------------------

//%{
//	sub Call(addr: [MidcodeSubref]) is
//		R_flushall();
//		E_insn("bl");
//		E_subref(addr.subr);
//		E_nl();
//	end sub;
//
//	sub CallR4() is
//		R_flushall();
//		E("\tmtlr 4\n");
//		E("\tblrl\n");
//	end sub;
//%}
//
//gen       CALL(  END(), SUBREF():a) uses all { Call(&$a); }
//gen r3 := CALLE1(END(), SUBREF():a) uses all { Call(&$a); }
//gen r3 := CALLE2(END(), SUBREF():a) uses all { Call(&$a); }
//gen r3 := CALLE4(END(), SUBREF():a) uses all { Call(&$a); }
//
//gen       CALL(  r3, SUBREF():a) uses all { Call(&$a); }
//gen r3 := CALLE1(r3, SUBREF():a) uses all { Call(&$a); }
//gen r3 := CALLE2(r3, SUBREF():a) uses all { Call(&$a); }
//gen r3 := CALLE4(r3, SUBREF():a) uses all { Call(&$a); }
//
//gen       CALL(  END(), r4) uses all { CallR4(); }
//gen r3 := CALLE1(END(), r4) uses all { CallR4(); }
//gen r3 := CALLE2(END(), r4) uses all { CallR4(); }
//gen r3 := CALLE4(END(), r4) uses all { CallR4(); }
//
//gen       CALL(  r3, r4) uses all { CallR4(); }
//gen r3 := CALLE1(r3, r4) uses all { CallR4(); }
//gen r3 := CALLE2(r3, r4) uses all { CallR4(); }
//gen r3 := CALLE4(r3, r4) uses all { CallR4(); }
//
//gen param := END();
//
//gen r3 := END();
//gen r3 := ARG1(param, r3:lhs);
//gen r3 := ARG2(param, r3:lhs);
//gen r3 := ARG4(param, r3:lhs);
//
//gen param := ARG1(param, r32:lhs) { E_push($lhs); }
//gen param := ARG2(param, r32:lhs) { E_push($lhs); }
//gen param := ARG4(param, r32:lhs) { E_push($lhs); }
//
//gen r3 := POPARG1(remaining==0);
//gen r3 := POPARG2(remaining==0);
//gen r3 := POPARG4(remaining==0);
//
//gen r32 := POPARG1(remaining!=0) { E_pop($$); }
//gen r32 := POPARG2(remaining!=0) { E_pop($$); }
//gen r32 := POPARG4(remaining!=0) { E_pop($$); }

// --- Operands -------------------------------------------------------------

gen imm := CONSTANT():c cost 5
	{ $@$.operand.imm.value := $c.value; }

gen adr := ADDRESS():a cost 5
	{ $@$.operand.adr.sym := &$a.sym; $@$.operand.adr.off := $a.off; }

// --- Loads/stores ---------------------------------------------------------

%{
	sub StoreReg(src: RegId, srcop: [Operand], insn: string, reg1: RegId, off: int16) is
		RegCacheFlushValues();

		E_insn(insn);
		E_op(src, srcop);
		E_comma();
		E_openp();
		E_i16(off);
		E_comma();
		E_reg(reg1);
		E_closep();
		E_nl();
	end sub;

#	sub LoadStoreRegX(src: RegId, insn: string, reg1: RegId, reg2: RegId) is
#		RegCacheFlushValues();
#		E_insn(insn);
#		E_reg(src);
#		E_comma();
#		E_reg(reg1);
#		E_comma();
#		E_reg(reg2);
#		E_nl();
#	end sub;

	sub StoreAddress(src: RegId, srcop: [Operand], insn: string, sym: [Symbol], off: Size) is
		RegCacheFlushValues();

		E_insn(insn);
		E_op(src, srcop);
		E_comma();
		E_openp();
		E_symref(sym, off);
		E_closep();
		E_nl();

		if (src & REGCLASS_R32) != 0 then
			RegCacheLeavesValue(src, sym, off);
		end if;
	end sub;

#	sub StoreShortAddress(src: RegId, insn: string, sym: [Symbol], off: Size) is
#		RegCacheFlushValues();
#
#		E_insn(insn);
#		E_reg(src);
#		E_comma();
#		E_u16(sym.off + off);
#		E("(31)\n");
#
#		RegCacheLeavesValue(src, sym, off);
#	end sub;

	sub LoadReg(dest: RegId, insn: string, reg1: RegId, off: int16) is
		RegCacheFlushValues();

		E_insn(insn);
		E_openp();
		E_i16(off);
		E_comma();
		E_reg(reg1);
		E_closep();
		E_comma();
		E_reg(dest);
		E_nl();
	end sub;

	sub LoadAddress(dest: RegId, insn: string, sym: [Symbol], off: Size) is
		var r := RegCacheFindValue(sym, off);
		if r != 0 then
			if (r & dest) != 0 then
				return;
			end if;
			r := FindFirst(r);
			E_insn("move.l");
			E_reg(r);
			E_comma();
			E_reg(dest);
		else
			RegCacheFlushValues();

			E_insn(insn);
			E_openp();
			E_symref(sym, off);
			E_closep();
			E_comma();
			E_reg(dest);
		end if;
		E_nl();

		R_flush(dest);
		RegCacheLeavesValue(dest, sym, off);
	end sub;
%}

gen STORE1(op8:lhs, DEREF1(areg:rhs))
	{ StoreReg($lhs, &$@lhs.operand, "move.b", $rhs, 0); }
gen STORE1(op8:lhs, DEREF1(ADD4(areg:rhs, CONSTANT():c)))
	{ StoreReg($lhs, &$@lhs.operand, "move.b", $rhs, $c.value as int16); }
gen STORE1(op8:lhs, DEREF1(ADDRESS():a))
	{ StoreAddress($lhs, &$@lhs.operand, "move.b", &$a.sym, $a.off); }

gen STORE2(op16:lhs, DEREF2(areg:rhs))
	{ StoreReg($lhs, &$@lhs.operand, "move.w", $rhs, 0); }
gen STORE2(op16:lhs, DEREF2(ADD4(areg:rhs, CONSTANT():c)))
	{ StoreReg($lhs, &$@lhs.operand, "move.w", $rhs, $c.value as int16); }
gen STORE2(op16:lhs, DEREF2(ADDRESS():a))
	{ StoreAddress($lhs, &$@lhs.operand, "move.w", &$a.sym, $a.off); }

gen STORE4(op32:lhs, DEREF4(areg:rhs))
	{ StoreReg($lhs, &$@lhs.operand, "move.l", $rhs, 0); }
gen STORE4(op32:lhs, DEREF4(ADD4(areg:rhs, CONSTANT():c)))
	{ StoreReg($lhs, &$@lhs.operand, "move.l", $rhs, $c.value as int16); }
gen STORE4(op32:lhs, DEREF4(ADDRESS():a))
	{ StoreAddress($lhs, &$@lhs.operand, "move.l", &$a.sym, $a.off); }

gen r8 := DEREF1(areg:rhs)
	{ R_flush($$); LoadReg($$, "move.b", $rhs, 0); }
gen r8 := DEREF1(ADD4(areg:rhs, CONSTANT():c))
	{ R_flush($$); LoadReg($$, "move.b", $rhs, $c.value as int16); }
gen r8 := DEREF1(ADDRESS():a)
	{ LoadAddress($$, "move.b", &$a.sym, $a.off); }

gen r16 := DEREF2(areg:rhs)
	{ R_flush($$); LoadReg($$, "move.w", $rhs, 0); }
gen r16 := DEREF2(ADD4(areg:rhs, CONSTANT():c))
	{ R_flush($$); LoadReg($$, "move.w", $rhs, $c.value as int16); }
gen r16 := DEREF2(ADDRESS():a)
	{ LoadAddress($$, "move.w", &$a.sym, $a.off); }

gen r32 := DEREF4(areg:rhs)
	{ R_flush($$); LoadReg($$, "move.l", $rhs, 0); }
gen r32 := DEREF4(ADD4(areg:rhs, CONSTANT():c))
	{ R_flush($$); LoadReg($$, "move.l", $rhs, $c.value as int16); }
gen r32 := DEREF4(ADDRESS():a)
	{ LoadAddress($$, "move.l", &$a.sym, $a.off); }

// --- Arithmetic -----------------------------------------------------------

%{
	sub Alu2(insn: string, dest: RegId) is
		R_flush(dest);
		E_insn(insn);
		E_reg(dest);
		E_nl();
	end sub;

	sub Alu3(insn: string, dest: RegId, rhs: RegId, rhsop: [Operand]) is
		R_flush(dest);
		E_insn(insn);
		E_op(rhs, rhsop);
		E_comma();
		E_reg(dest);
		E_nl();
	end sub;

#	sub Rem(insn: string, dest: RegId, lhs: RegId, rhs: RegId) is
#		R_flush(dest);
#
#		E_insn(insn);
#		E("0, ");
#		E_reg(lhs);
#		E_comma();
#		E_reg(rhs);
#		E_nl();
#
#		E_insn("mullw");
#		E("0,0,");
#		E_reg(rhs);
#		E_nl();
#
#		E_insn("subf");
#		E_reg(dest);
#		E(",0,");
#		E_reg(lhs);
#		E_nl();
#	end sub;
#
#	sub Extend(dest: RegId, src: RegId, sext: uint8, width: uint8) is
#		R_flush(dest);
#		if sext == 0 then
#			E_insn("andi.");
#			E_reg(dest);
#			E_comma();
#			E_reg(src);
#			E_comma();
#			if width == 1 then
#				E("0xff");
#			else
#				E("0xffff");
#			end if;
#		else
#			if width == 1 then
#				E_insn("extsb");
#			else
#				E_insn("extsh");
#			end if;
#			E_reg(dest);
#			E_comma();
#			E_reg(src);
#		end if;
#		E_nl();
#	end sub;
%}

gen r8 := ADD1($$:lhs, op8:rhs)
	{ Alu3("add.b", $$, $rhs, &$@rhs.operand); }
gen r16 := ADD2($$:lhs, op16:rhs)
	{ Alu3("add.w", $$, $rhs, &$@rhs.operand); }
gen r32 := ADD4($$:lhs, op32:rhs)
	{ Alu3("add.l", $$, $rhs, &$@rhs.operand); }

gen r8 := SUB1($$:lhs, op8:rhs)
	{ Alu3("sub.b", $$, $rhs, &$@rhs.operand); }
gen r16 := SUB2($$:lhs, op16:rhs)
	{ Alu3("sub.w", $$, $rhs, &$@rhs.operand); }
gen r32 := SUB4($$:lhs, op32:rhs)
	{ Alu3("sub.l", $$, $rhs, &$@rhs.operand); }

gen r8 := MUL1($$:lhs, r8|imm:rhs)
	{ Alu3("muls.w", $$, $rhs, &$@rhs.operand); }
gen r16 := MUL1($$:lhs, op16:rhs)
	{ Alu3("muls.w", $$, $rhs, &$@rhs.operand); }

gen r8 := DIVS1($$:lhs, r8|imm:rhs)
	{ Alu3("divs.w", $$, $rhs, &$@rhs.operand); }
gen r16 := DIVS2($$:lhs, op16:rhs)
	{ Alu3("divs.w", $$, $rhs, &$@rhs.operand); }

gen r8 := DIVU1($$:lhs, r8|imm:rhs)
	{ Alu3("divu.w", $$, $rhs, &$@rhs.operand); }
gen r16 := DIVU2($$:lhs, op16:rhs)
	{ Alu3("divu.w", $$, $rhs, &$@rhs.operand); }

gen r8 := EOR1($$:lhs, r8|imm:rhs)
	{ Alu3("eor.b", $$, $rhs, &$@rhs.operand); }
gen r16 := EOR2($$:lhs, r16|imm:rhs)
	{ Alu3("eor.w", $$, $rhs, &$@rhs.operand); }
gen d32reg := EOR4($$:lhs, r32|adr|imm:rhs)
	{ Alu3("eor.l", $$, $rhs, &$@rhs.operand); }

gen r8 := AND1($$:lhs, r8|imm:rhs)
	{ Alu3("and.b", $$, $rhs, &$@rhs.operand); }
gen r16 := AND2($$:lhs, r16|imm:rhs)
	{ Alu3("and.w", $$, $rhs, &$@rhs.operand); }
gen d32reg := AND4($$:lhs, r32|adr|imm:rhs)
	{ Alu3("and.l", $$, $rhs, &$@rhs.operand); }

gen r8 := OR1($$:lhs, r8|imm:rhs)
	{ Alu3("or.b", $$, $rhs, &$@rhs.operand); }
gen r16 := OR2($$:lhs, r16|imm:rhs)
	{ Alu3("or.w", $$, $rhs, &$@rhs.operand); }
gen d32reg := OR4($$:lhs, r32|adr|imm:rhs)
	{ Alu3("or.l", $$, $rhs, &$@rhs.operand); }

%{
	sub ShiftI(reg: RegId, insn: string, shift: uint8) is
		R_flush(reg);
		E_insn(insn);
		E_const();
		E_u8(shift);
		E_comma();
		E_reg(reg);
		E_nl();
	end sub;
%}

gen r8 := LSHIFT1($$:lhs, CONSTANT(value is u3):c)
	{ ShiftI($$, "lsl.b", $c.value as uint8); }
gen r16 := LSHIFT2($$:lhs, CONSTANT(value is u3):c)
	{ ShiftI($$, "lsl.w", $c.value as uint8); }
gen d32reg := LSHIFT4($$:lhs, CONSTANT(value is u3):c)
	{ ShiftI($$, "lsl.l", $c.value as uint8); }

gen r8 := RSHIFTU1($$:lhs, CONSTANT(value is u3):c)
	{ ShiftI($$, "lsr.b", $c.value as uint8); }
gen r16 := RSHIFTU2($$:lhs, CONSTANT(value is u3):c)
	{ ShiftI($$, "lsr.w", $c.value as uint8); }
gen d32reg := RSHIFTU4($$:lhs, CONSTANT(value is u3):c)
	{ ShiftI($$, "lsr.l", $c.value as uint8); }

gen r8 := RSHIFTS1($$:lhs, CONSTANT(value is u3):c)
	{ ShiftI($$, "asr.b", $c.value as uint8); }
gen r16 := RSHIFTS2($$:lhs, CONSTANT(value is u3):c)
	{ ShiftI($$, "asr.w", $c.value as uint8); }
gen d32reg := RSHIFTS4($$:lhs, CONSTANT(value is u3):c)
	{ ShiftI($$, "asr.l", $c.value as uint8); }

gen r8 := LSHIFT1($$:lhs, r8:rhs)
	{ Alu3("lsl.b", $$, $rhs, 0 as [Operand]); }
gen r16 := LSHIFT2($$:lhs, r8:rhs)
	{ Alu3("lsl.w", $$, $rhs, 0 as [Operand]); }
gen d32reg := LSHIFT4($$:lhs, r8:rhs)
	{ Alu3("lsl.l", $$, $rhs, 0 as [Operand]); }

gen r8 := RSHIFTU1($$:lhs, r8:rhs)
	{ Alu3("lsr.b", $$, $rhs, 0 as [Operand]); }
gen r16 := RSHIFTU2($$:lhs, r8:rhs)
	{ Alu3("lsr.w", $$, $rhs, 0 as [Operand]); }
gen d32reg := RSHIFTU4($$:lhs, r8:rhs)
	{ Alu3("lsr.l", $$, $rhs, 0 as [Operand]); }

gen r8 := RSHIFTS1($$:lhs, r8:rhs)
	{ Alu3("asr.b", $$, $rhs, 0 as [Operand]); }
gen r16 := RSHIFTS2($$:lhs, r8:rhs)
	{ Alu3("asr.w", $$, $rhs, 0 as [Operand]); }
gen d32reg := RSHIFTS4($$:lhs, r8:rhs)
	{ Alu3("asr.l", $$, $rhs, 0 as [Operand]); }

gen r8 := NOT1($$)     { Alu2("not.b", $$); }
gen r16 := NOT2($$)    { Alu2("not.w", $$); }
gen d32reg := NOT4($$) { Alu2("not.l", $$); }

gen r8 := NEG1($$)     { Alu2("neg.b", $$); }
gen r16 := NEG2($$)    { Alu2("neg.w", $$); }
gen d32reg := NEG4($$) { Alu2("neg.l", $$); }
//
//gen r32 := REMU1(r32:lhs, r32:rhs) { Extend($lhs, $lhs, 0, 1); Extend($rhs, $rhs, 0, 1); Rem("divwu", $$, $lhs, $rhs); }
//gen r32 := REMU2(r32:lhs, r32:rhs) { Extend($lhs, $lhs, 0, 2); Extend($rhs, $rhs, 0, 2); Rem("divwu", $$, $lhs, $rhs); }
//gen r32 := REMU4(r32:lhs, r32:rhs) {                                                     Rem("divwu", $$, $lhs, $rhs); }
//
//gen r32 := REMS1(r32:lhs, r32:rhs) { Extend($lhs, $lhs, 1, 1); Extend($rhs, $rhs, 1, 1); Rem("divw", $$, $lhs, $rhs); }
//gen r32 := REMS2(r32:lhs, r32:rhs) { Extend($lhs, $lhs, 1, 2); Extend($rhs, $rhs, 1, 2); Rem("divw", $$, $lhs, $rhs); }
//gen r32 := REMS4(r32:lhs, r32:rhs) {                                                     Rem("divw", $$, $lhs, $rhs); }

// --- Casts ----------------------------------------------------------------

//gen r32 := CAST21($$:lhs);
//gen r32 := CAST41($$:lhs);
//gen r32 := CAST42($$:lhs);

//gen r32 := CAST12(r32:lhs):c { Extend($$, $lhs, $c.sext, 1); }
//gen r32 := CAST14(r32:lhs):c { Extend($$, $lhs, $c.sext, 1); }
//gen r32 := CAST24(r32:lhs):c { Extend($$, $lhs, $c.sext, 2); }

// --- Conditionals ---------------------------------------------------------

gen BEQ0(CONSTANT():lhs, CONSTANT():rhs):b uses all
{
    var label := $b.falselabel;
    if $lhs.value == $rhs.value then
        label := $b.truelabel;
    end if;
    if label != $b.fallthrough then
        E_b(label);
    end if;
}

//%{
//	sub Cmp2(reginsn: string, imminsn: string, lhs: RegId, rhs: RegId, rhsop: [Operand]) is
//		if (rhs & REGCLASS_R32) != 0 then
//			E_insn(reginsn);
//		else
//			E_insn(imminsn);
//		end if;
//		E_reg(lhs);
//		E_comma();
//		E_op(rhs, rhsop);
//		E_nl();
//	end sub;
//
//	sub Cmp2U(lhs: RegId, rhs: RegId, rhsop: [Operand]) is
//		Cmp2("cmplw", "cmplwi", lhs, rhs, rhsop);
//	end sub;
//
//	sub Cmp2S(lhs: RegId, rhs: RegId, rhsop: [Operand]) is
//		Cmp2("cmpw", "cmpwi", lhs, rhs, rhsop);
//	end sub;
//
//	sub CmpJumps(trueinsn: string, falseinsn: string, node: [Node]) is
//		if node.beq.truelabel != node.beq.fallthrough then
//			E_jump(trueinsn, node.beq.truelabel);
//		end if;
//		if node.beq.falselabel != node.beq.fallthrough then
//			E_jump(falseinsn, node.beq.falselabel);
//		end if;
//	end sub;
//%}
//
//gen BEQ4(r32:lhs, r32|imms16|immu16:rhs):b uses all
//{
//	if $rhs == REG_IMMS16 then
//		Cmp2S($lhs, $rhs, &$@rhs.operand);
//	else
//		Cmp2U($lhs, $rhs, &$@rhs.operand);
//	end if;
//	CmpJumps("beq", "bne", $@$);
//}
//
//gen BLTU4(r32:lhs, r32|immu16:rhs):b uses all
//{
//	Cmp2U($lhs, $rhs, &$@rhs.operand);
//	CmpJumps("blt", "bge", $@$);
//}
//
//gen BLTS4(r32:lhs, r32|imms16:rhs):b uses all
//{
//	Cmp2S($lhs, $rhs, &$@rhs.operand);
//	CmpJumps("blt", "bge", $@$);
//}
//
//gen BEQ2(r32:lhs, r32|immu16|imms16:rhs):b uses all
//{
//	if $rhs == REG_IMMS16 then
//		Extend($lhs, $lhs, 1, 2);
//		Cmp2S($lhs, $rhs, &$@rhs.operand);
//	elseif $rhs == REG_IMMU16 then
//		Extend($lhs, $lhs, 0, 2);
//		Cmp2U($lhs, $rhs, &$@rhs.operand);
//	else
//		Extend($lhs, $lhs, 0, 2);
//		Extend($rhs, $rhs, 0, 2);
//		Cmp2U($lhs, $rhs, 0 as [Operand]);
//	end if;
//	CmpJumps("beq", "bne", $@$);
//}
//
//gen BLTU2(r32:lhs, r32|immu16:rhs):b uses all
//{
//	Extend($lhs, $lhs, 0, 2);
//	if ($rhs & REGCLASS_R32) != 0 then
//		Extend($rhs, $rhs, 0, 2);
//	end if;
//	Cmp2U($lhs, $rhs, &$@rhs.operand);
//	CmpJumps("blt", "bge", $@$);
//}
//
//gen BLTS2(r32:lhs, r32|imms16:rhs):b uses all
//{
//	Extend($lhs, $lhs, 1, 2);
//	if ($rhs & REGCLASS_R32) != 0 then
//		Extend($rhs, $rhs, 1, 2);
//	end if;
//	Cmp2S($lhs, $rhs, &$@rhs.operand);
//	CmpJumps("blt", "bge", $@$);
//}
//
//gen BEQ1(r32:lhs, r32|immu16:rhs):b uses all
//{
//	if $rhs == REG_IMMS16 then
//		Extend($lhs, $lhs, 1, 1);
//		Cmp2S($lhs, $rhs, &$@rhs.operand);
//	elseif $rhs == REG_IMMU16 then
//		Extend($lhs, $lhs, 0, 1);
//		Cmp2U($lhs, $rhs, &$@rhs.operand);
//	else
//		Extend($lhs, $lhs, 0, 1);
//		Extend($rhs, $rhs, 0, 1);
//		Cmp2U($lhs, $rhs, 0 as [Operand]);
//	end if;
//	CmpJumps("beq", "bne", $@$);
//}
//
//gen BEQ1(r32:lhs, r32|imms16:rhs):b uses all
//{
//	Extend($lhs, $lhs, 1, 1);
//	if ($rhs & REGCLASS_R32) != 0 then
//		Extend($rhs, $rhs, 1, 1);
//	end if;
//	Cmp2S($lhs, $rhs, &$@rhs.operand);
//	CmpJumps("beq", "bne", $@$);
//}
//
//gen BLTU1(r32:lhs, r32|imms16:rhs):b uses all
//{
//	Extend($lhs, $lhs, 0, 1);
//	if ($rhs & REGCLASS_R32) != 0 then
//		Extend($rhs, $rhs, 0, 1);
//	end if;
//	Cmp2U($lhs, $rhs, &$@rhs.operand);
//	CmpJumps("blt", "bge", $@$);
//}
//
//gen BLTS1(r32:lhs, r32|imms16:rhs):b uses all
//{
//	Extend($lhs, $lhs, 1, 1);
//	if ($rhs & REGCLASS_R32) != 0 then
//		Extend($rhs, $rhs, 1, 1);
//	end if;
//	Cmp2S($lhs, $rhs, &$@rhs.operand);
//	CmpJumps("blt", "bge", $@$);
//}

// --- Case -----------------------------------------------------------------

//gen STARTCASE1(r32:lhs) uses all { Extend(REG_R3, $lhs, 0, 1); }
//gen STARTCASE2(r32:lhs) uses all { Extend(REG_R3, $lhs, 0, 2); }
//gen STARTCASE4(r3) uses all;
//
//%{
//	sub WhenCase(c: [MidcodeWhencase], v: uint32) is
//		R_flushall();
//		if (v >= 0) and (v <= 65535) then
//			E("\tcmplwi 3,");
//			E_u16(v as uint16);
//		else
//			E("\tlis 0,");
//			E_u16((v >> 16) as uint16);
//			E_nl();
//			E("\tori 0,0,");
//			E_u16(v as uint16);
//			E_nl();
//			E("\tcmplw 3,0");
//		end if;
//		E_nl();
//		E_jump("bne", c.falselabel);
//	end sub;
//%}
//
//gen WHENCASE1():c uses all { WhenCase(&$c, ($c.value as uint32) & 0xff); }
//gen WHENCASE2():c uses all { WhenCase(&$c, ($c.value as uint32) & 0xffff); }
//gen WHENCASE4():c uses all { WhenCase(&$c, $c.value as uint32); }
//
//gen ENDCASE1() { R_flushall(); };
//gen ENDCASE2() { R_flushall(); };
//gen ENDCASE4() { R_flushall(); };

// --- Initialisers ---------------------------------------------------------

gen STARTINIT():s
{
	EmitterOpenStream(current_subr);
	E(".data 4\n");
	E_symref(&$s.sym, 0);
	E(":\n");
}

gen ENDINIT()
{
	EmitterCloseStream();
}

gen INIT1():c
{
	E("\t.byte ");
	E_u8($c.value as uint8);
	E_nl();
}

gen INIT2():c
{
	E("\t.short ");
	E_u16($c.value as uint16);
	E_nl();
}

gen INIT4():c
{
	E("\t.long ");
	E_u32($c.value as uint32);
	E_nl();
}

gen INITADDRESS():a
{
	E("\t.long ");
    E_symref(&$a.sym, $a.off);
    E_nl();
}

gen INITSUBREF():a
{
	E("\t.long ");
    E_subref($a.subr);
    E_nl();
}

gen INITSTRING():s
{
	E("\t.long ");
	var lid := E_string($s.text);
	E_labelref(lid);
    E_nl();
}

// --- Strings --------------------------------------------------------------

%{
    sub E_string(data: string): (lid: uint16) is
        lid := AllocPLabel();

        EmitterOpenStream(current_subr);

		E(".data 1\n");
        E_label(lid);
		E_insn(".byte");

        loop
            var c := [data];
            if c == 0 then
                break;
            end if;
            data := data + 1;
            
            E_u8(c);
            E_comma();
        end loop;
        E("0\n");
        EmitterCloseStream();
    end sub;
%}

//gen r32 := STRING():s
//{
//	var lid := E_string($s.text);
//	R_flush($$);
//}

// --- Inline assembly ------------------------------------------------------

gen ASMGROUPSTART() uses all;
gen ASMGROUPEND();

gen ASMSTART()
{
	E_tab();
}

gen ASMTEXT():t
{
	E($t.text);
	E_space();
}

gen ASMSYMBOL():s
{
	E_symref(&$s.sym, 0);
    E_space();
}

gen ASMSUBREF():s
{
	E_subref($s.subr);
    E_space();
}

gen ASMVALUE():c
{
	E_b8('(');
	E_i32($c.value);
	E_b8(')');
}

gen ASMEND()
{
    E_nl();
}

