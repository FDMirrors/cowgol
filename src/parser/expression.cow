var expr_true_label_id: uint16;
var expr_false_label_id: uint16;
var data_stack_size: uint8;

sub expression_state_machine()
    const STATE_BEFORE := 0;
    const STATE_AFTER := 1;

    var operator_stack: uint16[32];
    var operator_stack_pos: uint8 := 0;
    var state: uint8 := STATE_BEFORE;
    data_stack_size := 0;

    sub peek_op(out op_id: uint16)
        if operator_stack_pos == 0 then
            op_id := 0;
        else
            op_id := operator_stack[operator_stack_pos-1];
        end if;
    end sub;

    sub push_op(op: uint16)
        if operator_stack_pos == operator_stack@size then
            print("expression too complex");
            halt();
        end if;

        operator_stack[operator_stack_pos] := op;
        operator_stack_pos := operator_stack_pos + 1;
    end sub;

    sub discard_op()
        if operator_stack_pos == 0 then
            print("expression stack underflow");
            halt();
        end if;

        operator_stack_pos := operator_stack_pos - 1;
    end sub;

    sub pop_op(out op: uint16)
        discard_op();
        op := operator_stack[operator_stack_pos];
    end sub;

    sub check_b_op()
        if (expr_true_label_id == 0) | (expr_false_label_id == 0) then
            print("boolean operator cannot be used in this context");
            halt();
        end if;
    end sub;

    sub apply_op()
        if operator_stack_pos == 0 then
            print("apply on empty stack");
            halt();
        end if;

        operator_stack_pos := operator_stack_pos - 1;
        var op_id: uint16 := operator_stack[operator_stack_pos];
        var op: [Thing] := find_thing(op_id);

        sub alu_2op(iop: uint8)
            if data_stack_size < 2 then
                print("binary arithmetic operator cannot be used in this context");
                halt();
            end if;

            emit_simple_pushing(iop);
            data_stack_size := data_stack_size - 1;
        end sub;

        sub alu_1op(iop: uint8)
            if data_stack_size < 1 then
                print("unary arithmetic operator cannot be used in this context");
                halt();
            end if;

            emit_simple_pushing(iop);
        end sub;

        sub b_2op(iop: uint8)
            check_b_op();
            emit_conditional_branch(iop, expr_true_label_id);
            emit_goto(expr_false_label_id);
            data_stack_size := data_stack_size - 2;
        end sub;

        sub b_not()
            check_b_op();
            var t: uint16 := expr_true_label_id;
            expr_true_label_id := expr_false_label_id;
            expr_false_label_id := t;
        end sub;

        if op_id == TOKEN_PLUS then
            alu_2op(IOP_ADDOP);
        elseif op_id == TOKEN_MINUS then
            alu_2op(IOP_SUBOP);
        elseif op_id == TOKEN_STAR then
            alu_2op(IOP_MULOP);
        elseif op_id == TOKEN_SLASH then
            alu_2op(IOP_DIVOP);
        elseif op_id == TOKEN_PERCENT then
            alu_2op(IOP_MODOP);
        elseif op_id == TOKEN_TILDE then
            alu_1op(IOP_NOTOP);
        elseif op_id == TOKEN_EQOP then
            b_2op(IOP_BEQ);
        elseif op_id == TOKEN_NEOP then
            b_2op(IOP_BNE);
        elseif op_id == TOKEN_LTOP then
            b_2op(IOP_BLT);
        elseif op_id == TOKEN_LEOP then
            b_2op(IOP_BLE);
        elseif op_id == TOKEN_GTOP then
            b_2op(IOP_BGT);
        elseif op_id == TOKEN_GEOP then
            b_2op(IOP_BGE);
        elseif op_id == TOKEN_NOT then
            b_not();
        elseif (op_id == TOKEN_AND) | (op_id == TOKEN_OR) then
            merge_label(expr_false_label_id, pop_op());
            merge_label(expr_true_label_id, pop_op());
        else
            print("unknown operator ");
            show_identifier(op_id);
            halt();
        end if;
    end sub;

    sub operator_precedence(op_id: uint16, out precedence: uint8)
        if op_id < TOKEN_START_OF_OPS then
            precedence := 0;
        elseif op_id < TOKEN_PRECEDENCE_BAND_1 then
            precedence := 1;
        elseif op_id < TOKEN_PRECEDENCE_BAND_2 then
            precedence := 2;
        elseif op_id < TOKEN_PRECEDENCE_BAND_3 then
            precedence := 3;
        elseif op_id < TOKEN_PRECEDENCE_BAND_4 then
            precedence := 4;
        elseif op_id < TOKEN_PRECEDENCE_BAND_5 then
            precedence := 5;
        elseif op_id < TOKEN_PRECEDENCE_BAND_6 then
            precedence := 6;
        elseif op_id < TOKEN_PRECEDENCE_BAND_7 then
            precedence := 7;
        elseif op_id < TOKEN_PRECEDENCE_BAND_8 then
            precedence := 8;
        elseif op_id < TOKEN_PRECEDENCE_BAND_9 then
            precedence := 9;
        elseif op_id < TOKEN_PRECEDENCE_BAND_10 then
            precedence := 10;
        else
            precedence := 99; # unary operators
        end if;
    end sub;

    sub apply_higher_precedence_ops(op_id: uint16)
        var op_p: uint8 := operator_precedence(op_id);
        loop
            var topop_id: uint16 := peek_op();
            var topop_p: uint8 := operator_precedence(topop_id);
            if (topop_p == 0) | (topop_p < op_p) then
                break;
            end if;
            apply_op();
        end loop;
    end sub;

    sub flush_ops()
        while operator_stack_pos > 0 loop
            apply_op();
        end loop;
    end sub;

    sub apply_until_closer(out topop_id: uint16)
        loop
            topop_id := peek_op();
            if (topop_id == 0) | (topop_id == TOKEN_OPENPAREN) then
                break;
            end if;
            apply_op();
        end loop;
    end sub;

    sub close_parenthesis()
        var closer_id: uint16 := apply_until_closer();
        if closer_id == 0 then
            return;
        elseif closer_id != TOKEN_OPENPAREN then
            print(") matched with ");
            show_identifier(closer_id);
            print(", not (");
            halt();
        end if;
        discard_op();
    end sub;

    var thing: [Thing];
    var thing_iop: [ThingIop];
    loop
        if state == STATE_BEFORE then
            # Before a leaf.
            if current_token == TOKEN_OPENPAREN then
                push_op(TOKEN_OPENPAREN);
                next_token();
            elseif (current_token >= TOKEN_START_OF_UNARY_OPS) & (current_token < TOKEN_END_OF_UNARY_OPS) then
                push_op(current_token);
                next_token();
            else
                thing := find_thing(current_token);
                if (thing.thing_type == THING_IDENTIFIER) | (thing.thing_type == THING_NUMBER) then
                    thing_iop := emit(IOP_THING, ThingIop@bytes) as [ThingIop];
                    thing_iop.thing_id := current_token;
                    next_token();
                    state := STATE_AFTER;
                    data_stack_size := data_stack_size + 1;
                else
                    print("bad token ");
                    show_identifier(current_token);
                    halt();
                end if;
            end if;
        else
            # After a leaf (this is the only valid place to end an expression).
            if current_token < TOKEN_LAST_EXPR_END then
                break;
            elseif current_token == TOKEN_COMMA then
                break;
            elseif current_token == TOKEN_CLOSEPAREN then
                close_parenthesis();
                if peek_op() == 0 then
                    break;
                end if;
                next_token();
            elseif (current_token == TOKEN_AND) | (current_token == TOKEN_OR) then
                check_b_op();
                apply_higher_precedence_ops(current_token);

                if (current_token == TOKEN_AND) then
                    emit_label(expr_true_label_id);
                    push_op(create_label());
                    push_op(expr_false_label_id);
                else
                    emit_label(expr_false_label_id);
                    push_op(expr_true_label_id);
                    push_op(create_label());
                end if;
                push_op(current_token);

                expr_true_label_id := create_label();
                expr_false_label_id := create_label();

                next_token();
                state := STATE_BEFORE;
            elseif (current_token >= TOKEN_START_OF_BINARY_OPS) & (current_token < TOKEN_END_OF_BINARY_OPS) then
                apply_higher_precedence_ops(current_token);
                push_op(current_token);
                next_token();
                state := STATE_BEFORE;
            else
                print("bad state ");
                show_identifier(current_token);
                halt();
            end if;
        end if;
    end loop;

    flush_ops();
    if operator_stack_pos != 0 then
        print("unmatched expression");
        halt();
    end if;
end sub;

sub do_expression()
    expr_true_label_id := 0;
    expr_false_label_id := 0;
    expression_state_machine();
    if data_stack_size != 1 then
        print("expression left ");
        print_i8(data_stack_size);
        print(" items on the stack, but expected 1");
        halt();
    end if;
end sub;

sub do_conditional(out true_label: uint16, out false_label: uint16)
    expr_true_label_id := create_thing(THING_LABEL, LabelThing@bytes);
    expr_false_label_id := create_thing(THING_LABEL, LabelThing@bytes);

    expression_state_machine();

    true_label := expr_true_label_id;
    false_label := expr_false_label_id;
    if data_stack_size != 0 then
        print("expression left ");
        print_i8(data_stack_size);
        print(" items on the stack, but expected 0");
        halt();
    end if;
end sub;
