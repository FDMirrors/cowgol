include ".obj/arch8080/inssel.decl.coh";

record Register
	name: string;
	id: RegId;
	uses: RegId;
	compatible: RegId;
	is_stacked: uint8;
end record;

record Rule
	flags: uint8;
	compatible_producable_regs: RegId;
	producable_regs: RegId;
	uses_regs: RegId;
	consumable_regs: RegId[INSTRUCTION_TEMPLATE_DEPTH];
	matchbytes: uint8[INSTRUCTION_TEMPLATE_DEPTH];
	copyable_nodes: uint8;
	register_nodes: uint8;
end record;

include ".obj/arch8080/inssel.coh";

# Free up the node tree routed in the parameter. This is more exciting than it
# should be because we don't have recursion.
sub Discard(node: [Node])
	var pending := node;
	while pending != (0 as [Node]) loop
		node := pending;
		pending := node.dlink;

		# Unlink and push any children.
		if node.left != (0 as [Node]) then
			node.left.dlink := pending;
			pending := node.left;
		end if;
		if node.right != (0 as [Node]) then
			node.right.dlink := pending;
			pending := node.right;
		end if;

		# Now free this node.
		Free(node as [uint8], @bytesof Node);
	end loop;
end sub;

sub Generate(node: [Node])
	Discard(node);
end sub;

