sub check_16bit_ea(ea: [EffectiveAddress])
    if (ea.flags == EA_VALUE) and (is_number_thing(ea.obj_id) != 0) then
        var thing: [NumberThing] := find_thing(ea.obj_id) as [NumberThing];
        thing.segment := SEGMENT_CONST;
    end if;

    if ea.varoff_id != 0 then
        print("wide EA with variable offset: ");
        print_ea(ea);
        halt();
    end if;

    if (ea.flags == EA_DEREF) and (get_value_of_number(ea.numoff_id) != 0) then
        print("wide pointer EA with numeric offset: ");
        print_ea(ea);
        halt();
    end if;

    var width: uint8 := get_width_of_type(ea.type_id);
    if (width != 0) and (width != 2) then
        print("wide iop with non-wide parameter: ");
        print_ea(ea);
        halt();
    end if;
end sub;

sub regular_alu_word_op(iop: [BEIop], opcode: uint8)
    check_16bit_ea(&iop.left);
    check_16bit_ea(&iop.right);

    find_or_load_fixed_int(0, REG_Y);
    find_or_load_fixed_int(1, REG_X);
    allocate_fixed_reg(REG_A);

    var label: uint16 := create_label();
    write_label_iop(label);
    load_value_with_index(REG_A, &iop.left, REG_Y);
    aluop_value_with_index(&iop.right, REG_Y, opcode);
    save_value_with_index(REG_A, &iop.dest, REG_Y);
    write_byte(0xC8); # INY
    write_byte(0xCA); # DEX
    write_cg_6502_conditional_iop(0x10, label); # BPL rel

    flush_cached_values(REG_A|REG_X|REG_Y);
end sub;

sub arch_gen_add_word(iop: [BEIop])
    write_byte(0x18); # CLC
    regular_alu_word_op(iop, 0x6D); # ADC abs
end sub;

sub arch_gen_sub_word(iop: [BEIop])
    write_byte(0x38); # SEC
    regular_alu_word_op(iop, 0xED); # SBC abs
end sub;

sub arch_gen_copy_word(iop: [BEIop])
    sub address_of()
        var candidates: uint8;
        if iop.dest.flags == EA_DEREF then
            candidates := REG_A;
        else
            candidates := REG_A|REG_X;
        end if;

        var location: uint8 := allocate_reg(candidates);
        ld_imm_adr_lo(location, &iop.left);
        save_value_with_index_or_offset(location, &iop.dest, 0);
        ld_imm_adr_hi(location, &iop.left);
        save_value_with_index_or_offset(location, &iop.dest, 1);
    end sub;

    if is_number_thing(iop.left.obj_id) != 0 then
        var value: int32 := get_value_of_number(iop.left.obj_id);
        var candidates: uint8;
        if iop.dest.flags == EA_DEREF then
            candidates := REG_A;
        else
            candidates := REG_A|REG_X;
        end if;

        var location: uint8 := find_or_load_int(value, candidates);
        save_value_with_index_or_offset(location, &iop.dest, 0);
        free_reg(location);
        location := find_or_load_int(value >> 8, candidates);
        save_value_with_index_or_offset(location, &iop.dest, 1);
    elseif is_string_thing(iop.left.obj_id) != 0 then
        address_of();
    elseif is_typed_thing(iop.left.obj_id) != 0 then
        if iop.left.flags == EA_LEA then
            address_of();
        else
            find_or_load_fixed_int(1, REG_Y);
            allocate_fixed_reg(REG_A);

            var label: uint16 := create_label();
            write_label_iop(label);
            load_value_with_index(REG_A, &iop.left, REG_Y);
            save_value_with_index(REG_A, &iop.dest, REG_Y);
            write_byte(0x88); # DEY
            write_cg_6502_conditional_iop(0x30, label); # BMI

            flush_cached_values(REG_Y);
        end if;
    else
        print("don't know how to load ");
        print_ea(&iop.left);
        halt();
    end if;
end sub;

sub arch_gen_sext_word(iop: [BEIop])
    find_or_load_fixed_int(0, REG_X);

    find_or_load_fixed_value_with_flags(&iop.left, REG_A);
    write_byte(0x10); # BPL rel
    write_byte(0x01); # skip one byte
    write_byte(0xCA); # DEX

    save_value_with_offset(REG_A, &iop.dest, 0);
    save_value_with_offset(REG_X, &iop.dest, 1);
end sub;

sub arch_gen_zext_word(iop: [BEIop])
    var location: uint8 := find_or_load_value(&iop.left, REG_A|REG_X|REG_Y);
    save_value_with_offset(location, &iop.dest, 0);

    location := find_or_load_int(0, REG_A|REG_X|REG_Y);
    save_value_with_offset(location, &iop.dest, 1);
end sub;

sub do_2op_helper(iop: [BEIop])
    if (iop.left.flags != EA_VALUE) or (iop.dest.flags != EA_VALUE) then
        print("unimplemented");
        halt();
    end if;

    check_16bit_ea(&iop.left);
    check_16bit_ea(&iop.dest);

    write_back_precious_values(REG_MASK);

    write_byte(0x20); # JSR abs
    write_address_iop(IOP_ADDRESS, find_bootstrap_symbol(TOKEN_LOAD4BYTES), 0);
    write_address_iop(IOP_ADDRESS, iop.left.obj_id, get_value_of_number(iop.left.numoff_id));
    write_address_iop(IOP_ADDRESS, iop.dest.obj_id, get_value_of_number(iop.dest.numoff_id));

    flush_cached_values(REG_MASK);
end sub;

sub do_3op_helper(iop: [BEIop])
    if (iop.left.flags != EA_VALUE) or (iop.right.flags != EA_VALUE)
        or (iop.dest.flags != EA_VALUE)
    then
        print("unimplemented");
        halt();
    end if;

    check_16bit_ea(&iop.left);
    check_16bit_ea(&iop.right);
    check_16bit_ea(&iop.dest);

    write_back_precious_values(REG_MASK);

    write_byte(0x20); # JSR abs
    write_address_iop(IOP_ADDRESS, find_bootstrap_symbol(TOKEN_LOAD6BYTES), 0);
    write_address_iop(IOP_ADDRESS, iop.left.obj_id, get_value_of_number(iop.left.numoff_id));
    write_address_iop(IOP_ADDRESS, iop.right.obj_id, get_value_of_number(iop.right.numoff_id));
    write_address_iop(IOP_ADDRESS, iop.dest.obj_id, get_value_of_number(iop.dest.numoff_id));

    flush_cached_values(REG_MASK);
end sub;

sub arch_gen_lsl_word(iop: [BEIop])
    do_2op_helper(iop);

    find_or_load_fixed_value(&iop.right, REG_A);
    if is_number_thing(iop.right.obj_id) == 0 then
        write_byte(0x29); # AND imm
        write_byte(0x07);
    end if;
    write_byte(0x20); # JSR abs
    write_address_iop(IOP_ADDRESS, find_bootstrap_symbol(TOKEN_LSL16), 0);

    flush_cached_values(REG_MASK);
end sub;

sub arch_gen_lsr_word(iop: [BEIop])
    do_2op_helper(iop);

    find_or_load_fixed_value(&iop.right, REG_A);
    write_byte(0x20); # JSR abs
    write_address_iop(IOP_ADDRESS, find_bootstrap_symbol(TOKEN_LSR16), 0);

    flush_cached_values(REG_MASK);
end sub;

sub arch_gen_asr_word(iop: [BEIop])
    do_2op_helper(iop);

    find_or_load_fixed_value(&iop.right, REG_A);
    write_byte(0x20); # JSR abs
    write_address_iop(IOP_ADDRESS, find_bootstrap_symbol(TOKEN_ASR16), 0);

    flush_cached_values(REG_MASK);
end sub;

sub arch_gen_mul_word(iop: [BEIop])
    do_3op_helper(iop);

    write_byte(0x20); # JSR abs
    write_address_iop(IOP_ADDRESS, find_bootstrap_symbol(TOKEN_MUL16), 0);

    flush_cached_values(REG_MASK);
end sub;

sub arch_gen_cmp_word(ciop: [BEConditionalIop], liop: [LabelIop])
    write_back_precious_values(REG_MASK);
    check_16bit_ea(&ciop.left);
    check_16bit_ea(&ciop.right);

    var shortcircuit_label: uint16;
    var fallthrough_label: uint16;
    var opcode: uint8;
    # The opcodes below assume we're jumping to the *false* label ---
    # if not, we adjust things later.
    var iopkind: uint8 := ciop.iop_kind;
    if iopkind == IOP_BE_BEQ then
        # BNE rel: branch if zero clear.
        # Branches if A!=M.
        # Short-circuiting happens if the condition is FALSE.
        opcode := 0xD0; # BNE rel
        shortcircuit_label := ciop.iffalse_label;
        fallthrough_label := ciop.iftrue_label;
    else
        if (iopkind & IOP_TYPE_COMPARISON_S) != 0 then
            # BMI rel: branch if negative.
            # Branches if result of comparison is negative, which isn't the same
            # thing as M<A (signed). This needs the sign adjust in emit_comparison().
            # Short-circuiting happens if the condition is TRUE.
            opcode := 0x30; # BMI rel
        else
            # BCS: branch if carry set.
            #Â Branches if M<A (unsigned).
            # Short-circuiting happens if the condition is TRUE.
            opcode := 0x90; # BCC rel
        end if;
        shortcircuit_label := ciop.iftrue_label;
        fallthrough_label := ciop.iffalse_label;
    end if;

    sub emit_comparison(ea: [EffectiveAddress])
        if (iopkind & IOP_TYPE_COMPARISON_S) != 0 then
            write_byte(0x38); # SEC
            aluop_value_with_index(ea, REG_Y, 0xED); # SBC abs
            write_word_iop(0x0250); # BVC .+2
            write_word_iop(0x8049); # EOR #80
        else
            aluop_value_with_index(ea, REG_Y, 0xCD); # CMP abs
        end if;
    end sub;

    find_or_load_fixed_int(1, REG_Y); # word size minus one
    allocate_fixed_reg(REG_A);

    var label: uint16 := create_label();
    write_label_iop(label);

    # Remember, with BEQ we don't care about the order.
    if (iopkind & IOP_TYPE_COMPARISON_GT) == 0 then
        load_value_with_index(REG_A, &ciop.left, REG_Y);
        emit_comparison(&ciop.right);
    else
        load_value_with_index(REG_A, &ciop.right, REG_Y);
        emit_comparison(&ciop.left);
    end if;

    write_cg_6502_conditional_iop(opcode, shortcircuit_label);
    write_byte(0x88); # DEY
    write_cg_6502_conditional_iop(0x10, label); # BPL rel

    if liop.label != fallthrough_label then
        write_cg_6502_conditional_iop(0x80, fallthrough_label);
    end if;
end sub;
