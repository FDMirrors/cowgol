sub try_copy(iop: [BEIop])
    if iop.width == 1 then
        arch_gen_copy_byte(iop);
        return;
    end if;

    print("can't copy ");
    print_ea(&iop.left);
    print(" -> ");
    print_ea(&iop.dest);
    print(" width ");
    print_i8(iop.width);
    halt();
end sub;

sub cant_do_3op(iop: [BEIop], op: [int8])
    print("can't do ");
    print_ea(&iop.left);
    print(" ");
    print(op);
    print(" ");
    print_ea(&iop.right);
    print(" -> ");
    print_ea(&iop.dest);
    print(" width ");
    print_i8(iop.width);
    halt();
end sub;

sub try_add(iop: [BEIop])
    if iop.width == 1 then
        arch_gen_add_byte(iop);
        return;
    end if;

    cant_do_3op(iop, "+");
end sub;

sub try_sub(iop: [BEIop])
    if iop.width == 1 then
        arch_gen_sub_byte(iop);
        return;
    end if;

    cant_do_3op(iop, "-");
end sub;

sub global_rules(): (matched: uint8)
    matched := 1;

    if queue0.iop_kind == IOP_BE_COPY then
        try_copy(queue0 as [BEIop]);
        consume_iops(1);
        return;
    end if;

    if queue0.iop_kind == IOP_BE_ADD then
        try_add(queue0 as [BEIop]);
        consume_iops(1);
        return;
    end if;

    if queue0.iop_kind == IOP_BE_SUB then
        try_sub(queue0 as [BEIop]);
        consume_iops(1);
        return;
    end if;

    if queue0.iop_kind == IOP_RETURN then
        arch_gen_return();
        consume_iops(1);
        return;
    end if;

    matched := 0;
end sub;
