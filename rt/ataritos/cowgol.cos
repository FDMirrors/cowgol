# 32-bit multiply: d0 = d0*d1. Uses d2, d3.
&X _mul4
``:
	move.w d1, d2
	mulu.w d0, d2
	move.l d1, d3
	swap d3
	mulu.w d0, d3
	swap d3
	clr.w d3
	add.l d3, d2
	swap d0
	mulu.w d1, d0
	swap d0
	clr.w d0
	add.l d2, d0
	rts

# 32-bit unsigned divide of d0/d1 leaving the result in d0 and the remainder in d2.
# You can't use the 68000's 32/16=16 division instruction for this, so we have to
# do it the hard way.
# Uses d3.
&X _divremu4
``:
	move.w #31, d3		| loop count
	clr.l d2			| clear remainder
``_loop:
	lsl.l #1, d0		| shift left LHS...
	roxl.l #1, d2		| ...putting the result into the remainder
	cmp.l d2, d1		| compare remainder against RHS
	bgt.b ``_noadd
	add.l #1, d0		| set bottom bit of result (guaranteed clear)
	sub.l d1, d2		| decrease remainder
``_noadd:
	dbra d3, ``_loop
	rts

# 32-bit signed divide.
&X _divrems4
``:
	rts

