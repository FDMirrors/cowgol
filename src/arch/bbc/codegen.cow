const REG_A    := 0b0000_0001;
const REG_X    := 0b0000_0010;
const REG_Y    := 0b0000_0100;
const REG_MASK := 0b0111_1111;
const PRECIOUS := 0b1000_0000;

record CachedValue
    location: uint8;
    ea: EffectiveAddress;
end record;

var values: CachedValue[32];
var regusage: uint8[3];

sub bad_register()
    print("bad register");
    halt();
end sub;

sub arch_init_codegen()
    zero_memory(&values[0] as [int8], values@bytes);
    zero_memory(&regusage[0] as [int8], regusage@bytes);
end sub;

sub find_unused_regs(candidates: uint8): (mask: uint8)
    var i: uint8 := 0;
    while i < values@size loop
        candidates := candidates & (values[i].location ^ 0xff);
        i := i + 1;
    end loop;
    mask := candidates & REG_MASK;
end sub;

sub find_first_bit(value: uint8): (mask: uint8)
    mask := 1;
    loop
        if (value & mask) != 0 then
            return;
        end if;
        if mask == 0x80 then
            break;
        end if;
        mask := mask << 1;
    end loop;
    mask := 0;
end sub;

sub allocate_reg(candidates: uint8): (mask: uint8)
    mask := find_unused_regs(candidates);
    if mask == 0 then
        print("no unused registers");
        halt();
    end if;
    mask := find_first_bit(mask);
end sub;

sub find_reg_with_value(value: [EffectiveAddress]): (mask: uint8)
    var index: uint8 := 0;
    while index < values@size loop
        if is_same_ea(&values[index].ea, value) == 1 then
            mask := values[index].location & REG_MASK;
            return;
        end if;
        index := index + 1;
    end loop;
    mask := 0;
end sub;

sub value_is_cached_in_reg(value: [EffectiveAddress], mask: uint8)
    var index: uint8 := 0;
    while index < values@size loop
        if values[index].location == 0 then
            print("* using cache slot ");
            print_i8(index);
            print(" for ");
            print_ea(value);
            print_newline();
            values[index].location := mask;
            copy_ea(value, &values[index].ea);
            return;
        end if;
        index := index + 1;
    end loop;
    print("value cache is full");
    halt();
end sub;

sub value_is_precious_in_reg(value: [EffectiveAddress], mask: uint8)
    var index: uint8 := 0;
    while index < values@size loop
        if values[index].location == 0 then
            print("* using cache slot ");
            print_i8(index);
            print(" for precious ");
            print_ea(value);
            print_newline();
            values[index].location := mask | PRECIOUS;
            copy_ea(value, &values[index].ea);
            return;
        end if;
        index := index + 1;
    end loop;
    print("value cache is full");
    halt();
end sub;

sub write_6502_mem_iop(opcode: uint8, thing_id: uint16, offset_id: uint16)
    var thing: [DataThing] := find_thing(thing_id) as [DataThing];
    if thing.segment == SEGMENT_ZEROPAGE then
        write_byte(opcode & 0xf7);
        write_cg_6502_zeropage_iop(thing_id, offset_id);
    else
        write_byte(opcode);
        write_address_iop(thing_id, offset_id);
    end if;
end sub;

sub write_back_precious_value(location: uint8, ea: [EffectiveAddress])
    print("* writing back 0x");
    print_hex_i8(location);
    print(" to precious value ");
    print_ea(ea);
    print_newline();

    if ea.type == EA_OBJVAL then
        var opcode: uint8;
        if location == REG_A then
            opcode := 0x8D; # STA abs
        elseif location == REG_X then
            opcode := 0x8E; # STX abs
        elseif location == REG_Y then
            opcode := 0x8C; # STY abs
        else
            bad_register();
        end if;
        write_6502_mem_iop(opcode, ea.obj_id, ea.numoff_id);
    else
        print("can't write precious value ");
        print_ea(ea);
        print(" yet");
        halt();
    end if;
end sub;

sub write_back_precious_values(mask: uint8)
    var index: uint8 := 0;
    while index < values@size loop
        var location: uint8 := values[index].location;
        if (location & mask) != 0 then
            if (location & PRECIOUS) != 0 then
                location := location - PRECIOUS;
                write_back_precious_value(location, &values[index].ea);
                values[index].location := location;
            end if;
        end if;
        index := index + 1;
    end loop;
end sub;

sub flush_cached_values(mask: uint8)
    write_back_precious_values(mask);
    var index: uint8 := 0;
    while index < values@size loop
        var location: uint8 := values[index].location;
        if (location & mask) != 0 then
            print("* flushing cache slot ");
            print_i8(index);
            print_newline();
            values[index].location := 0;
        end if;
        index := index + 1;
    end loop;
end sub;

sub find_or_load_value(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := find_reg_with_value(ea);
    if location != 0 then
        print("* found in 0x");
        print_hex_i8(location);
        print(" value ");
        print_ea(ea);
        print_newline();
        return;
    end if;

    location := allocate_reg(candidates);
    print("* allocating 0x");
    print_hex_i8(location);
    print(" for ");
    print_ea(ea);
    print_newline();

    var opcode: uint8;

    flush_cached_values(location);
    value_is_cached_in_reg(ea, location);
    if (ea.type == EA_OBJVAL) and (is_number_thing(ea.obj_id) != 0) then
        if location == REG_A then
            opcode := 0xA9; # LDA imm
        elseif location == REG_X then
            opcode := 0xA2; # LDX imm
        elseif location == REG_Y then
            opcode := 0xA0; # LDY imm
        else
            bad_register();
        end if;
        write_byte(opcode);
        write_byte(get_value_of_number(ea.obj_id));
#    elseif ea.type == EA_VAR_PLUS_CONST then
#        if location == REG_A then
#            opcode := 0xAD; # LDA abs
#        elseif location == REG_X then
#            opcode := 0xAE; # LDX abs
#        elseif location == REG_Y then
#            opcode := 0xAC; # LDY abs
#        else
#            bad_register();
#        end if;
#        write_cg_6502_mem_iop(opcode, ea.thing_id, ea.constant);
    else
        print("can't implicit load this ea yet");
    end if;
end sub;

sub arch_gen_return()
    flush_cached_values(REG_MASK);
    write_byte(0x60); # RTS
end sub;

sub arch_gen_call(thing_id: uint16)
    flush_cached_values(REG_MASK);
    write_byte(0x20); # JSR
    write_address_iop(thing_id, 0);
end sub;

sub arch_gen_label()
    flush_cached_values(REG_MASK);
end sub;

sub arch_gen_goto(thing_id: uint16)
    flush_cached_values(REG_MASK);
    write_byte(0x4C); # JMP abs
    write_address_iop(thing_id, 0);
end sub;

sub arch_gen_copy(src: [EffectiveAddress], dest: [EffectiveAddress]): (matched: uint8)
    matched := 0;
end sub;

sub arch_gen_copy_byte_to_byte(src: [EffectiveAddress], dest: [EffectiveAddress])
    var location: uint8 := find_or_load_value(src, REG_A|REG_X|REG_Y);
    value_is_precious_in_reg(dest, location);
end sub;

sub arch_gen_copy_word_to_word(src: [EffectiveAddress], dest: [EffectiveAddress])
    write_byte(0x40); # JSR abs
    print("unsupported");
    halt();
#    write_address_iop(IOP_CG_COPY2, 0);
#    write_address_iop(src.thing_id, src.constant);
#    write_address_iop(dest.thing_id, dest.constant);
end sub;

sub arch_gen_copy_number_to_byte(src: [EffectiveAddress], dest: [EffectiveAddress])
    arch_gen_copy_byte_to_byte(src, dest);
end sub;

sub arch_gen_copy_number_to_word(src: [EffectiveAddress], dest: [EffectiveAddress])
    write_byte(0x20); # JSR abs
    print("unsupported");
    halt();
#    write_address_iop(deref_symbol_or_fail(TOKEN_CG_LOAD2), 0);
#    write_address_iop(src.thing_id, src.constant);
#    write_address_iop(dest.thing_id, dest.constant);
end sub;

#sub arch_gen_load_ptr_offset_bytevar_to_byte(ptr_id: uint16, offsetvar_id: uint16,
#        dest: [EffectiveAddress])
#    var ptr: [VariableThing] := find_thing(ptr_id) as [VariableThing];
#    #ptr.section := SECTION_POINTER;
#
#    var ea: EffectiveAddress[1];
#    ea[0].type := EA_VAR_PLUS_CONST;
#    ea[0].width := 2;
#    ea[0].thing_id := offsetvar_id;
#    ea[0].constant := 0;
#    var xreg: uint8 := find_or_load_value(&ea[0], REG_X);
#    write_byte(0xA1); # LDA ind,X
#    write_cg_6502_zeropage_iop(ptr_id, 0);
#    value_is_precious_in_reg(dest, REG_A);
#end sub;

#sub arch_gen_alu2op(iop: uint8,
#        left: [EffectiveAddress], right: [EffectiveAddress], dest: [EffectiveAddress]):
#        (matched: uint8)
#    matched := 1;
#
#    sub major_8bit(opcodebase: uint8)
#        var accumulator: uint8 := find_or_load_value(left, REG_A);
#        var buf: uint8[2];
#        if right.type == EA_VAR_PLUS_CONST then
#            # OPCODE abs
#            write_cg_6502_mem_iop(opcodebase | 0x0D, right.thing_id, right.constant);
#            value_is_precious_in_reg(dest, REG_A);
#        else
#            print("can't add this EA yet");
#            halt();
#        end if;
#    end sub;
#
#    if iop == IOP_ADDOP then
#        if left.width <= 1 then
#            write_byte(0x18); # CLC
#            major_8bit(0x60); # base ADC
#            return;
#        end if;
#    end if;
#
#    matched := 0;
#end sub;

#sub arch_gen_alu1op(iop: uint8, left: [EffectiveAddress], dest: [EffectiveAddress]): (matched: uint8)
#    matched := 1;
#
#    sub do_not()
#        var accumulator: uint8 := find_or_load_value(left, REG_A);
#        write_byte(0x4D); # EOR imm
#        write_byte(0xFF);
#        value_is_precious_in_reg(dest, REG_A);
#    end sub;
#
#    if iop == IOP_NOTOP then
#        if left.width == 1 then
#            do_not();
#            return;
#        end if;
#    end if;
#
#    matched := 0;
#end sub;

#sub arch_gen_conditional_fallthrough(iop: uint8,
#        left: [EffectiveAddress], right: [EffectiveAddress], inverted: uint8, label_id: uint16):
#        (matched: uint8)
#    matched := 1;
#
#    var opcode: uint8;
#    if (left.width <= 1) and (right.width <= 1) then
#        var reg: uint8 := find_or_load_value(left, REG_A|REG_X|REG_Y);
#        write_back_precious_values(REG_MASK);
#
#        if right.type == EA_NUMBER then
#            if reg == REG_A then
#                opcode := 0xC9; # CMP imm
#            elseif reg == REG_X then
#                opcode := 0xE0; # CPX imm
#            elseif reg == REG_Y then
#                opcode := 0xC0; # CPY imm
#            else
#                bad_register();
#            end if;
#            write_byte(opcode);
#            write_byte(right.constant);
#        else
#            print("can't compare these types yet");
#            halt();
#        end if;
#    else
#        matched := 0;
#        return;
#    end if;
#
#    if iop == IOP_BEQ then
#        opcode := 0xF0; # BNE
#    else
#        print("can't do this comparison yet");
#    end if;
#    if inverted == 1 then
#        opcode := opcode ^ 0x20;
#    end if;
#
#    flush_cached_values(REG_MASK);
#    write_cg_6502_conditional_iop(opcode, label_id);
#end sub;
