sub print_type_name(type_id: uint16)
    var brackets: uint8 := 0;
    loop
        var ptr_type: [PointerThing] := find_thing(type_id) as [PointerThing];
        if ptr_type.thing_type != THING_POINTER then
            break;
        end if;
        brackets := brackets + 1;
        print_char('[');
        type_id := ptr_type.element_id;
    end loop;

    show_identifier(find_name_of_value(type_id));

    while brackets > 0 loop
        print_char(']');
        brackets := brackets - 1;
    end loop;
end sub;

sub check_type_assignability(src_type_id: uint16, dest_type_id: uint16)
    var src_type: [TypeThing] := find_thing(src_type_id) as [TypeThing];
    var dest_type: [TypeThing] := find_thing(dest_type_id) as [TypeThing];

    # It's legal to assign any number to any other number.
    if ((src_type.thing_type & THING_NUMERIC) != 0) and
       ((dest_type.thing_type & THING_NUMERIC) != 0) then
        return;
    end if;

    # Otherwise, the type must match exactly.
    if src_type_id != dest_type_id then
        print_type_name(src_type_id);
        print(" cannot be assigned to ");
        print_type_name(dest_type_id);
        halt();
    end if;
end sub;

sub check_type_compatibility(left_type_id: uint16, right_type_id: uint16): (result_type_id: uint16)
    var left_type: [TypeThing] := find_thing(left_type_id) as [TypeThing];
    var right_type: [TypeThing] := find_thing(right_type_id) as [TypeThing];

    if left_type_id == right_type_id then
        result_type_id := left_type_id;
    elseif ((left_type.thing_type & THING_NUMERIC) != 0) and
       ((right_type.thing_type & THING_NUMERIC) != 0) then
        if left_type.width < right_type.width then
            result_type_id := right_type_id;
        else
            result_type_id := left_type_id;
        end if;
        return;
    else
        print_type_name(left_type_id);
        print(" and ");
        print_type_name(right_type_id);
        print(" are not compatible in this context");
        halt();
    end if;
end sub;

sub must_be_simplified(node: [Node])
    if node.iop != IOP_FEX_PUSH then
        print("operation on non-simplified node");
        halt();
    end if;
end sub;

sub alloc_ea_node(ea: [EffectiveAddress]): (node: [Node])
    node := alloc_node();
    node.iop := IOP_FEX_PUSH;
    node.flags := FLAG_RVALUE;
    node.type_id := uint16_type;
    copy_ea_ref(ea, &node.left);
end sub;

sub alloc_const_node(number_id: uint16): (node: [Node])
    node := alloc_node();
    node.iop := IOP_FEX_PUSH;
    node.flags := FLAG_RVALUE;
    node.type_id := uint16_type;
    node.left.obj_id := number_id;
end sub;

sub alloc_thing_node(thing_id: uint16): (node: [Node])
    node := alloc_node();
    node.iop := IOP_FEX_PUSH;
    node.type_id := get_type_of_thing(thing_id);
    node.left.obj_id := thing_id;
    ref_temporary(thing_id);
end sub;

sub gen_operator(beiop: uint8, left: [Node], right: [Node]): (dest: [Node])
    must_be_simplified(left);
    must_be_simplified(right);

    var node: [Node] := alloc_node();
    node.iop := beiop;
    node.type_id := uint16_type;
    node.flags := FLAG_RVALUE;
    copy_ea_ref(&left.left, &node.left);
    copy_ea_ref(&right.left, &node.right);

    dest := simplify_node_to_ea_and_deref(node);
end sub;

sub process_subroutine(thing_id: uint16)
    var subroutine: [SubroutineThing] := find_thing(thing_id) as [SubroutineThing];
    init_tree();
    init_temporaries();
    current_namespace_id := subroutine.namespace_id;

    sub fex_push(iop: [FEPushIop])
        var thing: [Thing] := find_thing(iop.thing_id);
        if thing.thing_type == THING_IDENTIFIER then
            iop.thing_id := deref_symbol_or_fail(iop.thing_id);
            thing := find_thing(iop.thing_id);
        end if;

        var node: [Node] := push_empty_node();

        node.iop := IOP_FEX_PUSH;
        node.left.obj_id := iop.thing_id;
        if thing.thing_type == THING_NUMBER then
            node.type_id := numeric_type;
            node.flags := FLAG_RVALUE;
        elseif thing.thing_type == THING_STRING then
            node.type_id := pointer_of(int8_type);
            node.flags := FLAG_RVALUE;
        elseif (thing.thing_type & THING_TYPED) != 0 then
            var typed_thing: [TypedThing] := thing as [TypedThing];
            if typed_thing.type_id == 0 then
                print("forward reference to type inferred value");
                halt();
            end if;
            node.type_id := typed_thing.type_id;
        else
            print("can't push things of type 0x");
            print_hex_i8(thing.thing_type);
            halt();
        end if;
        print("type_id=0x");
        print_hex_i16(node.type_id);
        print_newline();
    end sub;

    sub fe_swap()
        var n1: [Node] := pop();
        var n2: [Node] := pop();
        push_node(n1);
        push_node(n2);
    end sub;

    sub fe_assign()
        var src: [Node] := pop();
        var dest: [Node] := simplify_node_to_ea_and_deref(pop());

        if (dest.flags & FLAG_RVALUE) != 0 then
            print("cannot assign to rvalue");
            halt();
        end if;

        check_type_assignability(src.type_id, dest.type_id);
        dest := simplify_node_to_ea_and_deref(dest);
        arch_simplify_node_to(src, dest);
        deref_node(src);
        deref_node(dest);
    end sub;

    sub fe_simple_alu2op(beiop: uint8)
        var right: [Node] := simplify_node_to_ea_and_deref(pop());
        var left: [Node] := simplify_node_to_ea_and_deref(pop());

        var node: [Node] := push_empty_node();
        node.iop := beiop;
        node.flags := FLAG_RVALUE;
        copy_ea_ref(&left.left, &node.left);
        copy_ea_ref(&right.left, &node.right);
        # if you change this, change the non-pointer case in addsub as well
        node.type_id := check_type_compatibility(left.type_id, right.type_id);

        deref_node(right);
        deref_node(left);
    end sub;

    sub maybe_signed_biop(signed_beiop: uint8, unsigned_beiop: uint8): (beiop: uint8)
        var right: [Node] := peek(1);
        var left: [Node] := peek(2);

        var left_type: [TypeThing] := find_thing(left.type_id) as [TypeThing];
        var right_type: [TypeThing] := find_thing(right.type_id) as [TypeThing];

        var left_signedness: uint8;
        if ((left_type.thing_type == THING_SIGNED) or (left_type.thing_type == THING_NUMERIC))
            and ((right_type.thing_type == THING_SIGNED) or (right_type.thing_type == THING_NUMERIC))
        then
            beiop := signed_beiop;
        else
            beiop := unsigned_beiop;
        end if;
    end sub;

    sub fe_addsub(kind: uint8)
        var right: [Node] := simplify_node_to_ea_and_deref(pop());
        var left: [Node] := simplify_node_to_ea_and_deref(pop());

        var node: [Node] := push_empty_node();
        node.iop := kind;
        node.flags := FLAG_RVALUE;
        copy_ea_ref(&left.left, &node.left);
        copy_ea_ref(&right.left, &node.right);

        var left_type: [PointerThing] := find_thing(left.type_id) as [PointerThing];
        var right_type: [PointerThing] := find_thing(right.type_id) as [PointerThing];
        if left_type.thing_type != THING_POINTER then
            # this is the same as simple_alu2op above
            node.type_id := check_type_compatibility(left.type_id, right.type_id);
        elseif (kind == IOP_BE_SUB)
                and (left_type.thing_type == THING_POINTER)
                and (right_type.thing_type == THING_POINTER) then
            # Pointer difference.
            node.type_id := uint16_type;
        elseif (kind == IOP_BE_ADD)
                and (left_type.thing_type == THING_POINTER)
                and ((right_type.thing_type & THING_NUMERIC) != 0) then
            # Pointer offsetting.
            node.type_id := left.type_id;
        else
            halt();
        end if;

        deref_node(right);
        deref_node(left);
    end sub;

    sub fe_index()
        var right: [Node] := simplify_node_to_ea_and_deref(pop());
        var left: [Node] := pop();

        var left_type: [WithElementsThing] := find_thing(left.type_id) as [WithElementsThing];
        var right_type: [TypeThing] := find_thing(right.type_id) as [TypeThing];
        var element_type: [TypeThing] := find_thing(left_type.element_id) as [TypeThing];

        if (right_type.thing_type & THING_NUMERIC) == 0 then
            print("index must be numeric");
            halt();
        end if;

        var node: [Node] := push_empty_node();
        node.iop := IOP_FEX_PUSH;
        node.type_id := left_type.element_id;
        node.left.obj_id := left.left.obj_id;
        ref_temporary(node.left.obj_id);

        if left_type.thing_type == THING_POINTER then
            left := simplify_node_to_var_and_deref(left);
            node.left.flags := EA_DEREF;
        elseif left_type.thing_type == THING_ARRAY then
            left := simplify_node_to_ea_and_deref(left);
        else
            print("only pointers or arrays can be indexed");
            halt();
        end if;

        if (right_type.thing_type == THING_NUMERIC)
            and ((left.left.off_id == 0) or (is_number_thing(left.left.off_id) != 0)) then

            node.left.off_id := add_number_by_value(
                get_value_of_number(left.left.off_id) +
                    get_value_of_number(right.left.obj_id) * element_type.width);
        else
            var new_delta_node: [Node];
            var delta_node: [Node] := alloc_ea_node(&right.left);
            if element_type.width != 1 then
                var num_node: [Node] := alloc_const_node(add_number_by_value(element_type.width));
                new_delta_node := gen_operator(IOP_BE_MUL, delta_node, num_node);
                deref_node(num_node);
                deref_node(delta_node);
                delta_node := new_delta_node;
            end if;

            if left.left.off_id != 0 then
                var old_delta_node: [Node] := alloc_thing_node(left.left.off_id);
                new_delta_node := gen_operator(IOP_BE_ADD, old_delta_node, delta_node);
                deref_node(old_delta_node);
                deref_node(delta_node);
                delta_node := new_delta_node;
            end if;

            delta_node := simplify_node_to_var_and_deref(delta_node);
            node.left.flags := EA_DEREF;
            node.left.off_id := delta_node.left.obj_id;
            ref_temporary(node.left.off_id);
            deref_node(delta_node);
        end if;
        deref_node(right);
        deref_node(left);
    end sub;

    sub fex_parameter(direction: uint8, iop: [FEParameterIop])
        var thing_id: uint16 := iop.subroutine_id;
        var thing: [Thing] := find_thing(thing_id);
        if thing.thing_type == THING_IDENTIFIER then
            thing_id := deref_symbol_or_fail(thing_id);
            thing := find_thing(thing_id);
        end if;
        if thing.thing_type != THING_SUBROUTINE then
            print("subroutine_id not a subroutine");
            halt();
        end if;

        var parameter_id: uint16 := find_nth_parameter(
            thing_id, direction, iop.parameter);
        if parameter_id == 0 then
            print("invalid parameter id");
            halt();
        end if;
        var parameter: [ParameterThing] := find_thing(parameter_id) as [ParameterThing];

        var node: [Node] := push_empty_node();
        print("found subroutine 0x");
        print_hex_i16(thing_id);
        print(" direction ");
        print_i8(direction);
        print_newline();
        node.iop := IOP_FEX_PUSH;
        node.type_id := parameter.type_id;
        node.left.obj_id := parameter_id;
    end sub;

    sub fe_materialise()
        var src: [Node] := pop();

        var dest: [Node] := push_empty_node();
        dest.iop := IOP_FEX_PUSH;
        dest.flags := FLAG_RVALUE;
        dest.type_id := src.type_id;
        dest.left.obj_id := alloc_temporary(get_width_of(src));

        arch_simplify_node_to(src, dest);
        deref_node(src);
    end sub;

#    sub shift_op(iop: [TypedIop])
#        var right_type_id: uint16;
#        var right_flags: uint8;
#        (right_type_id, right_flags) := pop_type();
#
#        var left_type_id: uint16;
#        var left_flags: uint8;
#        (left_type_id, left_flags) := pop_type();
#
#        var left_type: [TypeThing] := find_thing(left_type_id) as [TypeThing];
#        var right_type: [TypeThing] := find_thing(right_type_id) as [TypeThing];
#
#        if (left_type.thing_type & THING_NUMERIC) == 0 then
#            print("cannot shift non-numbers");
#            halt();
#        end if;
#        if (right_type.thing_type & THING_NUMERIC) == 0 then
#            print("cannot shift by non-numbers");
#            halt();
#        end if;
#        if iop.iop_kind == IOP_RSHIFTOP then
#            if left_type.thing_type == THING_SIGNED then
#                iop.iop_kind := IOP_ASROP;
#            else
#                iop.iop_kind := IOP_LSROP;
#            end if;
#        end if;
#
#        iop.type_id := left_type_id;
#        push_type(left_type_id, FLAG_RVALUE);
#        write_iop(iop as [Iop]);
#    end sub;

#    sub simple_alu1op(iop: [TypedIop])
#        var left_type_id: uint16;
#        var left_flags: uint8;
#        (left_type_id, left_flags) := pop_type();
#
#        iop.type_id := left_type_id;
#        push_type(left_type_id, FLAG_RVALUE);
#        write_iop(iop as [Iop]);
#    end sub;
#
#    sub conditional_jump(iop: [ConditionalIop])
#        var right_type_id: uint16;
#        var right_flags: uint8;
#        (right_type_id, right_flags) := pop_type();
#
#        var left_type_id: uint16;
#        var left_flags: uint8;
#        (left_type_id, left_flags) := pop_type();
#
#        var type_id: uint16 := check_type_compatibility(left_type_id, right_type_id);
#        iop.type_id := type_id;
#        write_iop(iop as [Iop]);
#    end sub;
#
#    sub call_subroutine(iop: [CallIop])
#        var thing: [SubroutineThing] := find_thing(iop.thing_id) as [SubroutineThing];
#        if thing.thing_type == THING_IDENTIFIER then
#            iop.thing_id := deref_symbol_or_fail(iop.thing_id);
#            thing := find_thing(iop.thing_id) as [SubroutineThing];
#        end if;
#        if thing.thing_type != THING_SUBROUTINE then
#            print("subroutine_id not pointing at subroutine");
#            halt();
#        end if;
#
#        if (thing.input_parameter_count != iop.input_parameter_count)
#                or (thing.output_parameter_count != iop.output_parameter_count) then
#            show_name_of(iop.thing_id);
#            print(" has ");
#            print_i8(thing.input_parameter_count);
#            print(" inputs and ");
#            print_i8(thing.output_parameter_count);
#            print(" outputs, but was called with ");
#            print_i8(iop.input_parameter_count);
#            print(" and ");
#            print_i8(iop.output_parameter_count);
#            halt();
#        end if;
#
#        write_iop(iop as [Iop]);
#    end sub;
#    sub castop(iop: [TypedIop])
#        var input_type_id: uint16;
#        var input_flags: uint8;
#        (input_type_id, input_flags) := pop_type();
#
#        var input_type: [TypeThing] := find_thing(input_type_id) as [TypeThing];
#        var output_type: [TypeThing] := find_thing(iop.type_id) as [TypeThing];
#        if (input_type.thing_type != THING_NUMERIC) and (input_type.width != output_type.width) then
#            if output_type.thing_type == THING_SIGNED then
#                iop.iop_kind := IOP_SEXTOP;
#            else
#                iop.iop_kind := IOP_ZEXTOP;
#            end if;
#
#            write_iop(iop as [Iop]);
#        end if;
#        push_type(iop.type_id, FLAG_RVALUE);
#    end sub;
#
#    sub addressop(iop: [TypedIop])
#        var input_type_id: uint16;
#        var input_flags: uint8;
#        (input_type_id, input_flags) := pop_type();
#
#        if (input_flags & FLAG_RVALUE) != 0 then
#            print("cannot take the address of an rvalue");
#            halt();
#        end if;
#
#        # The type checker's not actually smart enough to tell whether the thing that
#        # the address is being taken of is actually an array member. So we just set
#        # the type correctly and leave it at that. The codegen stage will complain
#        # if it can't be done.
#
#        iop.type_id := pointer_of(input_type_id);
#        push_type(iop.type_id, FLAG_RVALUE);
#        write_iop(iop as [Iop]);
#    end sub;
#
#    sub memberop(iop: [MemberIop])
#        var input_type_id: uint16;
#        var input_flags: uint8;
#        (input_type_id, input_flags) := pop_type();
#
#        sub find_member_of_record_type(type_id: uint16, identifier_id: uint16): (member_id: uint16)
#            var type: [RecordThing] := find_thing(type_id) as [RecordThing];
#            if type.thing_type != THING_RECORD then
#                print_type_name(type_id);
#                print(" is not a record type");
#                halt();
#            end if;
#
#            var symbol_id: uint16 := find_symbol_recursively(identifier_id, type.namespace_id);
#            if symbol_id == 0 then
#                show_identifier(identifier_id);
#                print(" is not a member of ");
#                print_type_name(type_id);
#                halt();
#            end if;
#            var symbol: [SymbolThing] := find_thing(symbol_id) as [SymbolThing];
#            member_id := symbol.value_id;
#        end sub;
#
#        var input_type: [TypeThing] := find_thing(input_type_id) as [TypeThing];
#        var member_id: uint16;
#        var member: [MemberThing];
#        if input_type.thing_type == THING_RECORD then
#            member_id := find_member_of_record_type(input_type_id, iop.thing_id);
#            member := find_thing(member_id) as [MemberThing];
#            write_offset_iop(member.offset, member.type_id);
#        elseif input_type.thing_type == THING_POINTER then
#            var ptr_input_type: [PointerThing] := input_type as [PointerThing];
#            member_id := find_member_of_record_type(ptr_input_type.element_id, iop.thing_id);
#            member := find_thing(member_id) as [MemberThing];
#            write_push_number_iop(member.offset, uint16_type);
#            write_typed_iop(IOP_ADDOP, input_type_id);
#        else
#            print(". only works on pointer and record types");
#            halt();
#        end if;
#        push_type(member.type_id, 0);
#    end sub;

    loop
        var iop: [Iop] := read_iop();
        var ioptype: uint8 := iop.iop_kind & IOP_TYPE_MASK;
        print_newline();
        print_stack();
        print("* read iop 0x");
        print_hex_i8(iop.iop_kind);
        print_newline();

        if iop.iop_kind == IOP_END then
            break;
        elseif ioptype == IOP_TYPE_UNTYPED then
            write_iop(iop);
        elseif iop.iop_kind == IOP_FE_SWAP then
            fe_swap();
        elseif iop.iop_kind == IOP_FEX_PUSH then
            fex_push(iop as [FEPushIop]);
        elseif iop.iop_kind == IOP_FE_ASSIGN then
            fe_assign();
        elseif iop.iop_kind == IOP_FE_ADD then
            fe_addsub(IOP_BE_ADD);
        elseif iop.iop_kind == IOP_FE_SUB then
            fe_addsub(IOP_BE_SUB);
        elseif iop.iop_kind == IOP_FE_MUL then
            fe_simple_alu2op(IOP_BE_MUL);
        elseif iop.iop_kind == IOP_FE_AND then
            fe_simple_alu2op(IOP_BE_AND);
        elseif iop.iop_kind == IOP_FE_OR then
            fe_simple_alu2op(IOP_BE_OR);
        elseif iop.iop_kind == IOP_FE_EOR then
            fe_simple_alu2op(IOP_BE_EOR);
        elseif iop.iop_kind == IOP_FE_DIV then
            fe_simple_alu2op(maybe_signed_biop(IOP_BE_DIVS, IOP_BE_DIVU));
        elseif iop.iop_kind == IOP_FE_INDEX then
            fe_index();
        elseif iop.iop_kind == IOP_FEX_INPUTPARAM then
            fex_parameter(DIRECTION_IN, iop as [FEParameterIop]);
        elseif iop.iop_kind == IOP_FEX_OUTPUTPARAM then
            fex_parameter(DIRECTION_OUT, iop as [FEParameterIop]);
        elseif iop.iop_kind == IOP_FE_MATERIALISE then
            fe_materialise();
#        elseif (iop.iop_kind == IOP_LSLOP) or (iop.iop_kind == IOP_RSHIFTOP) then
#            shift_op(iop as [TypedIop]);
#        elseif ioptype == IOP_TYPE_SIMPLE1OP then
#            simple_alu1op(iop as [TypedIop]);
#        elseif iop.iop_kind == IOP_BEQ then
#            conditional_jump(iop as [ConditionalIop]);
#        elseif iop.iop_kind == IOP_BGT then
#            maybe_signed_biop(IOP_BGTS, IOP_BGTU, iop as [TypedIop]);
#            conditional_jump(iop as [ConditionalIop]);
#        elseif iop.iop_kind == IOP_BLT then
#            maybe_signed_biop(IOP_BLTS, IOP_BLTU, iop as [TypedIop]);
#            conditional_jump(iop as [ConditionalIop]);
#        elseif iop.iop_kind == IOP_CALL then
#            call_subroutine(iop as [CallIop]);
#        elseif iop.iop_kind == IOP_SINDEXOP then
#            sindexop(iop as [TypedIop]);
#        elseif iop.iop_kind == IOP_CASTOP then
#            castop(iop as [TypedIop]);
#        elseif iop.iop_kind == IOP_ADDRESSOP then
#            addressop(iop as [TypedIop]);
#        elseif iop.iop_kind == IOP_MEMBEROP then
#            memberop(iop as [MemberIop]);
        else
            print("unsupported iop 0x");
            print_hex_i8(iop.iop_kind);
            halt();
        end if;
    end loop;
    write_untyped_iop(IOP_END);
end sub;

sub process()
    loop
        var iheader: [IHeader] := read_iop_header();
        if iheader.thing_id == 0 then
            break;
        end if;

        write_iop_header(iheader);
        process_subroutine(iheader.thing_id);
    end loop;
    write_terminating_iop_header();
end sub;

process();
save_thing_table("things.dat");
