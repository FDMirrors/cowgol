%{
	var uint32_type: [Symbol];
	var int32_type: [Symbol];
	var uint16_type: [Symbol];
	var int16_type: [Symbol];
	var uint8_type: [Symbol];
	var int8_type: [Symbol];
	var intptr_type: [Symbol];

	const VARMEM_WS := 0;
	const PTRMEM_WS := 1;
	const VARSTACK_WS := 2;
	const PTRSTACK_WS := 3;

	const FAKE_STACK_SIZE := 32;

	var varstack: uint8[FAKE_STACK_SIZE];
	var varsp: uint8 := 0;

	var ptrstack: uint8[FAKE_STACK_SIZE];
	var ptrsp: uint8 := 0;

	record Extern
		name: string;
		id: uint16;
		next: [Extern];
	end record;

	var externs: [Extern] := (0 as [Extern]);

	sub ArchAlignUp(value: Size, alignment: uint8): (newvalue: Size)
		newvalue := value;
	end sub;

	sub ArchInitTypes()
		uint32_type := MakeNumberType(4, 1, 0, "uint32");
		int32_type := MakeNumberType(4, 1, 1, "int32");
		uint16_type := MakeNumberType(2, 1, 0, "uint16");
		int16_type := MakeNumberType(2, 1, 1, "int16");
		uint8_type := MakeNumberType(1, 1, 0, "uint8");
		int8_type := MakeNumberType(1, 1, 1, "int8");

		intptr_type := uint16_type;
		AddAliasString("intptr", intptr_type);
	end sub;

	sub ArchGuessIntType(min: Arith, max: Arith): (symbol: [Symbol])
		if (min >= 0) and (max <= 255) then
			symbol := uint8_type;
		elseif (min >= -128) and (max <= 127) then
			symbol := int8_type;
		elseif (min >= 0) and (max <= 65535) then
			symbol := uint16_type;
		elseif (min >= -32768) and (max <= 32767) then
			symbol := int16_type;
		elseif (min >= 0) then
			symbol := uint32_type;
		else
			symbol := int32_type;
		end if;
	end sub;

	sub ArchInitVariable(symbol: [Symbol])
		var wsid: uint8 := VARMEM_WS;
		if IsPtr(symbol.vardata.type) != 0 then
			wsid := PTRMEM_WS;
		end if;

		var subr := symbol.vardata.subr;
		var offset := subr.workspace[wsid];
		symbol.vardata.offset := offset;
		subr.workspace[wsid] := offset + symbol.vardata.type.typedata.width;
	end sub;

	sub ArchInitMember(containing: [Symbol], member: [Symbol], position: Size)
		member.vardata.offset := position;
		position := position + member.vardata.type.typedata.width;
		if position > containing.typedata.width then
			containing.typedata.width := position;
		end if;
	end sub;

	sub Push(reg: RegId, width: uint8): (stackaddr: uint16)
		if (reg & REG_P16) != 0 then
			stackaddr := (PTRSTACK_WS<<8) | (ptrsp as uint16);
			ptrsp := ptrsp + width;
			if (current_subr.workspace[PTRSTACK_WS] as uint8) < ptrsp then
				current_subr.workspace[PTRSTACK_WS] := ptrsp as Size;
			end if;
		else
			stackaddr := (VARSTACK_WS<<8) | (varsp as uint16);
			varsp := varsp + width;
			if (current_subr.workspace[VARSTACK_WS] as uint8) < varsp then
				current_subr.workspace[VARSTACK_WS] := varsp as Size;
			end if;
		end if;
	end sub;

	sub Pop(reg: RegId, width: uint8): (stackaddr: uint16)
		if (reg & REG_P16) != 0 then
			ptrsp := ptrsp - width;
			stackaddr := (PTRSTACK_WS<<8) | (ptrsp as uint16);
		else
			varsp := varsp - width;
			stackaddr := (VARSTACK_WS<<8) | (varsp as uint16);
		end if;
	end sub;

	sub E_stackref(sid: uint16)
		EmitByte(COO_ESCAPE_WSREF);
		E_h16(current_subr.id);
		E_h8((sid >> 8) as uint8);
		E_h16(sid & 0xff);
	end sub;

	sub E_indstackref(sid: uint16)
		EmitByte('(');
		E_stackref(sid);
		E("),y");
	end sub;

	sub E_symref(sym: [Symbol], off: Size)
		if sym.vardata.externname != (0 as string) then
			E(sym.vardata.externname);
			E_i16(off as int16);
		else
			EmitByte(COO_ESCAPE_WSREF);
			E_h16(sym.vardata.subr.id);
			if IsPtr(sym.vardata.type) != 0 then
				E_h8(PTRMEM_WS);
			else
				E_h8(VARMEM_WS);
			end if;
			E_h16(sym.vardata.offset + off);
		end if;
	end sub;

	sub E_symrefi(sym: [Symbol], off: Size)
		EmitByte('(');
		E_symref(sym, off);
		E("),y");
	end sub;

	sub E_loaddr(sym: [Symbol], off: Size)
		E("#<");
		E_symref(sym, off);
	end sub;

	sub E_hiaddr(sym: [Symbol], off: Size)
		E("#>");
		E_symref(sym, off);
	end sub;

	sub R_flushall()
		RegCacheFlush(ALL_REGS);
	end sub;

	sub R_flush(reg: RegId)
		RegCacheFlush(FindConflictingRegisters(reg));
	end sub;

	sub E_label(label: LabelRef)
		R_flushall();
		E_labelref(label);
		E(":\n");
	end sub;

	sub E_insn(insn: string)
		E_tab();
		E(insn);
		E_space();
	end sub;

	sub E_const(value: uint8)
		EmitByte('#');
		E_u8(value);
	end sub;

	sub E_jump(insn: string, label: LabelRef)
		R_flushall();
		E_tab();
		E(insn);
		E_space();
		E_labelref(label);
		E_nl();
	end sub;

	sub E_jmp(label: LabelRef)
		E_jump("jmp", label);
	end sub;

	sub E_rts() E("\trts\n"); end sub;
	sub E_clc() E("\tclc\n"); end sub;
	sub E_sec() E("\tsec\n"); end sub;
	sub E_pha() E("\tpha\n"); end sub;
	sub E_pla() E("\tpla\n"); end sub;
	sub E_txa() E("\ttxa\n"); end sub;
	sub E_tya() E("\ttya\n"); end sub;
	sub E_tax() E("\ttax\n"); end sub;
	sub E_tay() E("\ttay\n"); end sub;

	sub E_ld(reg: RegId)
		R_flush(reg);
		case reg is
			when REG_A: E("\tlda");
			when REG_X: E("\tldx");
			when REG_Y: E("\tldy");
		end case;
		E_space();
	end sub;

	sub E_lda()
		E_ld(REG_A);
	end sub;

	sub E_st(reg: RegId)
		case reg is
			when REG_A: E("\tsta");
			when REG_X: E("\tstx");
			when REG_Y: E("\tsty");
		end case;
		E_space();
	end sub;

	sub E_sta()
		E_st(REG_A);
	end sub;

	sub E_iny()
		R_flush(REG_Y);
		E("\tiny\n");
	end sub;

	sub E_inc(reg: RegId)
		case reg is
			when REG_A:
				E_clc();
				E("\tadc #1\n");

			when REG_X:
				E("\tinx\n");

			when REG_Y: E_iny();
		end case;
	end sub;

	sub E_loadconst(reg: RegId, value: uint8)
		var cache := RegCacheFindConstant(value as Word) & reg;
		if cache == 0 then
			E_ld(reg);
			E_const(value);
			E_nl();
			RegCacheLeavesConstant(reg, value as Word);
		end if;
	end sub;

	# Note that this *destroys* the source register.
	sub ArchEmitMove(src: RegId, dest: RegId)
		case src is
			when REG_A:
				case dest is
					when REG_X: E_tax(); return;
					when REG_Y: E_tay(); return;
					when 0:     E_pha(); return;
				end case;

			when 0:
				case dest is
					when REG_A: E_pla(); return;
				end case;

			when REG_X:
				case dest is
					when REG_A: E_txa(); return;
				end case;

			when REG_Y:
				case dest is
					when REG_Y: E_tya(); return;
				end case;

			when REG_XA:
				if (dest & REGCLASS_A16) != 0 then
					var sid := Push(dest, 2);

					E_st(REG_A);
					E_stackref(sid);
					E_nl();

					E_st(REG_X);
					E_stackref(sid+1);
					E_nl();

					return;
				end if;
		end case;

		StartError();
		print("bad move ");
		print_hex_i16(src);
		print(" -> ");
		print_hex_i16(dest);
		EndError();
	end sub;

	sub ArchEndInstruction()
	end sub;

	sub ArchEndGroup()
	end sub;
%}

wordsize uint16;

register a x y xa;
register v8;  // value on fake stack
register v16; // value on fake stack
register p16; // pointer on fake stack
register v32; // value on fake stack;
register param;

regclass a16 := v16|p16;

regdata a uses xa|a compatible a|x|y;
regdata x uses xa|x compatible a|x;
regdata y compatible a|y;
regdata xa uses x|a compatible a16|xa;
regdata v16 stacked compatible a16|xa;
regdata p16 stacked compatible a16|xa;
regdata v32 stacked;
regdata param stacked;

// --- Core things ----------------------------------------------------------

gen STARTFILE();
gen ENDFILE();

gen LABEL():b
{
	E_label($b.label);
}

gen JUMP():j
{
	E_jmp($j.label);
}

// --- Subroutines ----------------------------------------------------------

gen STARTSUB():s
{
	RegCacheReset();

	EmitterPushChunk();
	E_h16($s.subr.id);

	E("\n\n\t; ");
	E($s.subr.name);
	E_nl();

	E("\tcseg\n");
	EmitByte(COO_ESCAPE_THISSUB);
	E(":\n");
}

gen ENDSUB():s
{
	E_rts();
	EmitterPopChunk('S');

	var i: uint8 := 0;
	while i != 4 loop
		EmitterDeclareWorkspace($s.subr, i, $s.subr.workspace[i]);
		i := i + 1;
	end loop;
}

// --- Constants ------------------------------------------------------------

gen a|x|y := CONSTANT():c
{
	E_loadconst($$, $c.value as uint8);
}

// --- 8-bit memory ----------------------------------------------------------

gen STORE1(a:lhs, p16:ptr)
{
	var sid := Pop($ptr, 2);
	E_loadconst(REG_Y, 0);

	E_insn("sta");
	E_indstackref(sid);
	E_nl();
}

gen STORE1(a|x|y:lhs, ADDRESS():a)
{
	E_st($lhs);
	E_symref($a.sym, $a.off);
	E_nl();
	RegCacheLeavesValue($lhs, $a.sym, $a.off);
}

gen a|x|y := LOAD1(ADDRESS():a)
{
	var cache := RegCacheFindValue($a.sym, $a.off) & $$;
	if cache == 0 then
		E_ld($$);
		E_symref($a.sym, $a.off);
		E_nl();
		RegCacheLeavesValue($$, $a.sym, $a.off);
	end if;
}

// --- Extended operations ---------------------------------------------------

%{
	const MODE_CONST := 0;
	const MODE_STACK := 1;
	const MODE_SYMBOL := 2;
	const MODE_SYMBOLI := 3;

	record Operand
		sid @at(0): uint16;
		off @at(0): Size;
		val @at(0): Arith;
		sym: [Symbol];
		mode: uint8;
	end record;

	var paramwidth: uint8;
	var lhsparam: Operand;
	var rhsparam: Operand;
	var destparam: Operand;

	sub LhsConst(value: Arith)
		lhsparam.mode := MODE_CONST;
		lhsparam.val := value;
	end sub;

	sub RhsConst(value: Arith)
		rhsparam.mode := MODE_CONST;
		rhsparam.val := value;
	end sub;

	sub LhsPop(reg: RegId)
		lhsparam.mode := MODE_STACK;
		lhsparam.sid := Pop(reg, paramwidth);
	end sub;

	sub RhsPop(reg: RegId)
		rhsparam.mode := MODE_STACK;
		rhsparam.sid := Pop(reg, paramwidth);
	end sub;

	sub DestPush(reg: RegId)
		destparam.mode := MODE_STACK;
		destparam.sid := Push(reg, paramwidth);
	end sub;

	sub LhsSym(sym: [Symbol], off: Size)
		lhsparam.mode := MODE_SYMBOL;
		lhsparam.sym := sym;
		lhsparam.off := off;
	end sub;

	sub RhsSym(sym: [Symbol], off: Size)
		rhsparam.mode := MODE_SYMBOL;
		rhsparam.sym := sym;
		rhsparam.off := off;
	end sub;

	sub DestSym(sym: [Symbol], off: Size)
		destparam.mode := MODE_SYMBOL;
		destparam.sym := sym;
		destparam.off := off;
	end sub;

	sub LhsSymI(sym: [Symbol], off: Size)
		E_loadconst(REG_Y, 0);
		lhsparam.mode := MODE_SYMBOLI;
		lhsparam.sym := sym;
		lhsparam.off := off;
	end sub;

	sub RhsSymI(sym: [Symbol], off: Size)
		E_loadconst(REG_Y, 0);
		rhsparam.mode := MODE_SYMBOLI;
		rhsparam.sym := sym;
		rhsparam.off := off;
	end sub;

	sub DestSymI(sym: [Symbol], off: Size)
		E_loadconst(REG_Y, 0);
		destparam.mode := MODE_SYMBOLI;
		destparam.sym := sym;
		destparam.off := off;
	end sub;

	sub DoParam(operand: [Operand], insn: string)
		E_insn(insn);
		case operand.mode is
			when MODE_CONST:
				E_const(operand.val as uint8);
				operand.val := operand.val >> 8;

			when MODE_STACK:
				E_stackref(operand.sid);
				operand.sid := operand.sid + 1;

			when MODE_SYMBOL:
				E_symref(operand.sym, operand.off);
				operand.off := operand.off + 1;

			when MODE_SYMBOLI:
				E_symrefi(operand.sym, operand.off);
				if paramwidth != 1 then
					E("\n\tiny");
				end if;
		end case;
		E_nl();
	end sub;

	sub DoXA(insn: string)
		R_flush(REG_A|REG_X|REG_XA);
		DoParam(&rhsparam, insn);
		E_pha();
		E_txa();
		DoParam(&rhsparam, insn);
		E_tax();
		E_pla();
	end sub;

	sub DoCopy()
		R_flush(REG_A);
		while paramwidth != 0 loop
			DoParam(&lhsparam, "lda");
			DoParam(&destparam, "sta");
			paramwidth := paramwidth - 1;
		end loop;
	end sub;

	sub Do3Op(insn: string)
		R_flush(REG_A);
		while paramwidth != 0 loop
			DoParam(&lhsparam, "lda");
			DoParam(&rhsparam, insn);
			DoParam(&destparam, "sta");
			paramwidth := paramwidth - 1;
		end loop;
	end sub;

	sub DoAdc()
		E_clc();
		Do3Op("adc");
	end sub;
%}

// --- 8-bit maths -----------------------------------------------------------

%{
	sub DoAlu1S(insn: string)
		var rhssid := Pop(REG_V8, 1);

		R_flush(REG_A);
		E_insn(insn);
		E_stackref(rhssid);
		E_nl();
	end sub;

	sub DoAlu1C(insn: string, value: uint8)
		R_flush(REG_A);
		E_insn(insn);
		E_const(value);
		E_nl();
	end sub;

	sub DoAlu1M(insn: string, sym: [Symbol], off: Size)
		R_flush(REG_A);
		E_insn(insn);
		E_symref(sym, off);
		E_nl();
	end sub;

	sub DoAlu1PS(insn: string)
		var rhssid := Pop(REG_P16, 2);

		E_loadconst(REG_Y, 0);
		R_flush(REG_A);
		E_insn(insn);
		E_indstackref(rhssid);
		E_nl();
	end sub;
%}

gen a := ADD1(a, v8)                 { E_clc(); DoAlu1S("adc"); }
gen a := SUB1(a, v8)                 { E_sec(); DoAlu1S("sbc"); }

gen a := ADD1(a, LOAD1(ADDRESS():a)) { E_clc(); DoAlu1M("adc", $a.sym, $a.off); }
gen a := SUB1(a, LOAD1(ADDRESS():a)) { E_sec(); DoAlu1M("sbc", $a.sym, $a.off); }

gen a := ADD1(a, LOAD1(p16))         { E_clc(); DoAlu1PS("adc"); }
gen a := SUB1(a, LOAD1(p16))         { E_sec(); DoAlu1PS("sbc"); }

gen a := ADD1(a, CONSTANT():c)       { E_clc(); DoAlu1C("adc", $c.value as uint8); }
gen a := SUB1(a, CONSTANT():c)       { E_sec(); DoAlu1C("sbc", $c.value as uint8); }

// --- 16-bit ---------------------------------------------------------------

gen xa := LOAD2(ADDRESS():a)
{
	var cache := RegCacheFindValue($a.sym, $a.off);
	if cache != REG_XA then
		E_ld(REG_A);
		E_symref($a.sym, $a.off);
		E_nl();

		E_ld(REG_X);
		E_symref($a.sym, $a.off+1);
		E_nl();
	end if;
	RegCacheLeavesValue(REG_XA, $a.sym, $a.off);
}

gen xa := LOAD2(p16:ptr)
{
	var sid := Pop($ptr, 2);

	E_loadconst(REG_Y, 0);

	E_ld(REG_A);
	E_indstackref(sid);
	E_nl();

	E_iny();

	E_ld(REG_X);
	E_indstackref(sid);
	E_nl();
}

gen xa := CONSTANT():c
{
	var cache := RegCacheFindConstant($c.value as Word);
	if cache != REG_XA then
		E_loadconst(REG_A, $c.value as uint8);
		E_loadconst(REG_X, ($c.value>>8) as uint8);
	end if;
	RegCacheLeavesConstant(REG_XA, $c.value as Word);
}

gen xa := ADDRESS():a
{
	var sid := Push($$, 2);

	E_ld(REG_A);
	E_loaddr($a.sym, $a.off);
	E_nl();

	E_ld(REG_X);
	E_hiaddr($a.sym, $a.off);
	E_nl();
}

gen STORE2(xa, ADDRESS():a)
{
	E_st(REG_A);
	E_symref($a.sym, $a.off);
	E_nl();

	E_st(REG_X);
	E_symref($a.sym, $a.off+1);
	E_nl();
	RegCacheLeavesValue(REG_XA, $a.sym, $a.off);
}

gen STORE2(xa, p16:rhs)
{
	var sid := Pop($rhs, 2);

	E_loadconst(REG_Y, 0);

	E_st(REG_A);
	E_indstackref(sid);
	E_nl();

	E_iny();

	E_st(REG_X);
	E_indstackref(sid);
	E_nl();
}

$include "arch6502.ng.h"

