sub InitVariable(subr: [Subroutine], symbol: [Symbol], type: [Symbol]) is
	CheckNotPartialType(type);
	symbol.vardata.type := type;
	symbol.vardata.subr := subr;
	ArchInitVariable(symbol);
	#print("var ");
	#print(symbol.name);
	#print(" at ");
	#print(current_subr.name);
	#print(" 0x");
	#print_hex_i16(symbol.vardata.offset as uint16);
	#print("+");
	#print_hex_i16(symbol.vardata.type.typedata.width as uint16);
	#print_nl();
end sub;

sub MakePointerType(type: [Symbol]): (ptrtype: [Symbol]) is
	ptrtype := type.typedata.pointerto;
	if ptrtype == (0 as [Symbol]) then
		ptrtype := AddSymbol(0 as [Namespace], 0 as string);
		ptrtype.name := StrDupBraced(type.name);
		ptrtype.kind := TYPE;
		ptrtype.typedata.kind := TYPE_POINTER;
		ptrtype.typedata.width := intptr_type.typedata.width;
		ptrtype.typedata.alignment := intptr_type.typedata.alignment;
		ptrtype.typedata.stride := intptr_type.typedata.stride;
		ptrtype.typedata.pointertype.element := type;
		type.typedata.pointerto := ptrtype;
	end if;
end sub;

sub MakeArrayType(type: [Symbol], size: Size): (arraytype: [Symbol]) is
	CheckNotPartialType(type);

	arraytype := AddSymbol(0 as [Namespace], 0 as string);
	arraytype.name := StrDupArrayed(type.name, size);
	arraytype.kind := TYPE;
	arraytype.typedata.kind := TYPE_ARRAY;
	var w: Size := 0;
	if size > 0 then
		w := type.typedata.stride * (size - 1) + type.typedata.width;
	end if;
	arraytype.typedata.width := w;
	arraytype.typedata.alignment := type.typedata.alignment;
	arraytype.typedata.stride := type.typedata.stride * size;
	arraytype.typedata.arraytype.element := type;
	arraytype.typedata.arraytype.size := size;
	arraytype.typedata.arraytype.indextype := ArchGuessIntType(0, (size-1) as Arith);
end sub;

sub MakeSubroutineType(subr: [Subroutine]): (type: [Symbol]) is
	type := subr.type;
	if type == (0 as [Symbol]) then
		type := AddSymbol(0 as [Namespace], 0 as string);
		type.name := subr.name;
		type.kind := TYPE;
		type.typedata.kind := TYPE_SUBROUTINE;
		type.typedata.width := intptr_type.typedata.width;
		type.typedata.alignment := intptr_type.typedata.alignment;
		type.typedata.stride := intptr_type.typedata.stride;
		type.typedata.subrtype.subr := subr;
	end if;
end sub;

# Called after a subroutine has been generated. This allows us to free up some
# of the resources used. Note that we can't free *everything* until our parent
# gets destructed, because parameters and types which they depend on might be
# referred to.
sub DestructSubroutineContents(subr: [Subroutine]) is
	# Destroys a sumbol (which isn't a subroutine).
	sub DestructSymbol(symbol: [Symbol]) is
		if symbol.kind == TYPE then
			var pointer := symbol.typedata.pointerto;
			while pointer != (0 as [Symbol]) loop
				var p := pointer;
				pointer := pointer.typedata.pointerto;

				Free(p.name);
				Free(p as [uint8]);
			end loop;
		end if;
		Free(symbol.name);
		Free(symbol as [uint8]);
	end sub;

	# Destroys a subroutine, freeing all parameters, variables, types etc.
	sub DestructSubroutine(subr: [Subroutine]) is
		var symbol := subr.namespace.first;
		while symbol != (0 as [Symbol]) loop
			var s := symbol;
			symbol := symbol.next;
			DestructSymbol(s);
		end loop;
		Free(subr as [uint8]);
	end sub;

	# Find the last parameter.

	var last_parameter := subr.first_output_parameter;
	if last_parameter == (0 as [Symbol]) then
		last_parameter := subr.first_input_parameter;
	end if;
	if last_parameter != (0 as [Symbol]) then
		loop
			var next := last_parameter.vardata.next_parameter;
			if next == (0 as [Symbol]) then
				break;
			end if;
			last_parameter := next;
		end loop;
	end if;

	# last_parameter is now pointing at the last parameter, or null if there
	# are none.

	var symbol := subr.namespace.first;
	if last_parameter != (0 as [Symbol]) then
		symbol := last_parameter.next;
	end if;
	while symbol != (0 as [Symbol]) loop
		next := symbol.next;
		if symbol.kind == SUB then
			DestructSubroutine(symbol.subr);
		end if;
		DestructSymbol(symbol);
		symbol := next;
	end loop;

	if last_parameter != (0 as [Symbol]) then
		last_parameter.next := 0 as [Symbol];
	else
		subr.namespace.first := 0 as [Symbol];
	end if;
	subr.namespace.last := last_parameter;
end sub;

sub CopyParameterList(param: [Symbol], subr: [Subroutine]): (newparam: [Symbol]) is
	newparam := 0 as [Symbol];
	var lastparam := 0 as [Symbol];

	while param != 0 as [Symbol] loop
		var p := AddSymbol(&subr.namespace, StrDup(param.name));
		p.kind := VAR;
		p.vardata.type := param.vardata.type;
		p.vardata.subr := param.vardata.subr;
		p.vardata.offset := param.vardata.offset;
		if lastparam != 0 as [Symbol] then
			lastparam.vardata.next_parameter := p;
			lastparam := p;
		end if;
		if newparam != 0 as [Symbol] then
			newparam := p;
		end if;

		param := param.vardata.next_parameter;
	end loop;
end sub;

