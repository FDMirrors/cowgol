record CachedValue
    ea: EffectiveAddress;
    locations: uint8;
end record;

var values: CachedValue[8];
var locked_registers: uint8;

sub print_cache()
    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        if value.locations != 0 then
            print("cache slot ");
            print_i8(i);
            print(": ");
            print_ea(&value.ea);
            if (value.locations & PRECIOUS) != 0 then
                print(" precious");
            end if;
            print(" in 0x");
            print_hex_i8(value.locations & REG_MASK);
            print_newline();
        end if;
        i := i + 1;
    end loop;
end sub;

sub arch_init_codegen()
    zero_memory(&values[0] as [int8], values@bytes);
end sub;

sub write_back_precious_value(location: uint8, ea: [EffectiveAddress])
    location := find_first_bit(location);
    print("* writing back 0x");
    print_hex_i8(location);
    print(" to precious value ");
    print_ea(ea);
    print_newline();

    if ea.flags == EA_OBJVAL then
        save_objval(location, ea);
    else
        print("can't write precious value ");
        print_ea(ea);
        print(" yet");
        halt();
    end if;
end sub;

sub write_back_precious_values(mask: uint8)
    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        var locations: uint8 := value.locations;
        if (locations & mask) != 0 then
            if (locations & PRECIOUS) != 0 then
                locations := locations ^ PRECIOUS;
                write_back_precious_value(locations, &value.ea);
                value.locations := locations;
            end if;
        end if;
        i := i + 1;
    end loop;
end sub;

sub find_unused_regs(candidates: uint8): (mask: uint8)
    var i: uint8 := 0;
    while i < values@size loop
        candidates := candidates & (values[i].locations ^ 0xff);
        i := i + 1;
    end loop;
    mask := candidates & REG_MASK;
end sub;

sub allocate_reg(candidates: uint8): (mask: uint8)
    candidates := candidates & (locked_registers ^ 0xff);
    mask := find_unused_regs(candidates);
    if mask == 0 then
        mask := candidates;
        if mask == 0 then
            print_cache();
            print("locked register bitmask: 0x");
            print_hex_i8(locked_registers);
            print_newline();
            print("no available registers");
            halt();
        end if;
    end if;
    mask := find_first_bit(mask);
    write_back_precious_values(mask);
    locked_registers := locked_registers | mask;
    print("* allocating 0x");
    print_hex_i8(mask);
    print_newline();
end sub;

sub free_reg(mask: uint8)
    locked_registers := locked_registers & (mask ^ REG_MASK);
end sub;

sub allocate_fixed_reg(candidates: uint8)
    var location: uint8 := allocate_reg(candidates);
end sub;

sub find_regs_with_value(ea: [EffectiveAddress], candidates: uint8): (locations: uint8)
    var index: uint8 := 0;
    while index < values@size loop
        var value: [CachedValue] := &values[index];
        locations := value.locations & candidates & REG_MASK;
        if (locations != 0) and (is_same_ea(&value.ea, ea) != 0) then
            locations := value.locations & REG_MASK;
            print("* found in 0x");
            print_hex_i8(locations);
            print(" value ");
            print_ea(ea);
            print_newline();
            return;
        end if;
        index := index + 1;
    end loop;
    locations := 0;
    print("* did not find value ");
    print_ea(ea);
    print(" in any register\n");
end sub;

sub find_reg_with_value(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := find_regs_with_value(ea, candidates);
    if location != 0 then
        location := find_first_bit(location & candidates);
    end if;
end sub;

sub value_is_cached_in_reg(ea: [EffectiveAddress], locations: uint8)
    var i: uint8;
    var value: [CachedValue];

    sub msg()
        print("* remembering that ");
        print_ea(ea);
        print(" is also in 0x");
        print_hex_i8(locations);
        print_newline();
    end sub;

    # Look for a cache slot already containing this value.
    i := 0;
    while i < values@size loop
        value := &values[i];

        if is_same_ea(&value.ea, ea) != 0 then
            value.locations := value.locations | locations;
            msg();
            return;
        end if;
        i := i + 1;
    end loop;

    # Not found --- find an empty cache slot and use that.
    i := 0;
    while i < values@size loop
        value := &values[i];

        if value.locations == 0 then
            value.locations := locations;
            copy_ea(ea, &value.ea);
            msg();
            return;
        end if;
        i := i + 1;
    end loop;

    print("can't cache, value cache is full");
    halt();
end sub;

sub move_value_to_reg(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    print("* hunting for ");
    print_ea(ea);
    print(" in 0x");
    print_hex_i8(candidates);
    print_newline();

    location := find_reg_with_value(ea, candidates);
    if location != 0 then
        locked_registers := locked_registers | location;
        return;
    end if;

    location := find_reg_with_value(ea, REG_A|REG_X|REG_Y);
    if location == 0 then
        return;
    end if;

    var oldlocation: uint8 := location;
    location := allocate_reg(candidates);

    # Special case: can't move from X to Y or vice versa.
    if (oldlocation|location) == (REG_X|REG_Y) then
        free_reg(location);
        location := 0;
        return;
    end if;

    print("* moving value ");
    print_ea(ea);
    print(" from 0x");
    print_hex_i8(oldlocation);
    print(" to 0x");
    print_hex_i8(location);
    print_newline();

    t_reg_reg(oldlocation, location);
    value_is_cached_in_reg(ea, location);
end sub;

sub value_is_precious(ea: [EffectiveAddress])
    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        if value.locations != 0 then
            if is_same_ea(ea, &value.ea) != 0 then
                if (value.locations & PRECIOUS) == 0 then
                    print("* remembering that value ");
                    print_ea(ea);
                    print(" is precious in 0x");
                    print_hex_i8(value.locations);
                    print_newline();
                    value.locations := value.locations | PRECIOUS;
                    return;
                end if;
            end if;
        end if;
        i := i + 1;
    end loop;
    print("can't make precious, value cache is full");
    halt();
end sub;

# The contents of location are about to be replaced with a new value. If any values there
# are precious, they get written back --- except for the new value, if it's there.
# Any cached values in that location get flushed. This allows mutation of values without
# triggering writeback.
sub value_in_location_will_be_replaced_with(location: uint8, newvalue: [EffectiveAddress])
    print("* replacing value in 0x");
    print_hex_i8(location);
    print(" with ");
    print_ea(newvalue);
    print_newline();

    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        if (value.locations & location) != 0 then
            if ((value.locations & PRECIOUS) != 0) and (is_same_ea(&value.ea, newvalue) == 0) then
                write_back_precious_value(location, &value.ea);
            end if;

            print("* forgetting that ");
            print_ea(&value.ea);
            print(" is in 0x");
            print_hex_i8((value.locations & REG_MASK) ^ location);
            print_newline();

            value.locations := location;
        end if;
        i := i + 1;
    end loop;
end sub;

sub flush_cached_values(mask: uint8)
    print("* flushing cached values in 0x");
    print_hex_i8(mask);
    print_newline();

    write_back_precious_values(mask);

    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        value.locations := value.locations & (0xFF ^ mask);
        i := i + 1;
    end loop;
end sub;

sub allocate_reg_for_value(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := allocate_reg(candidates);
    flush_cached_values(location);
    value_is_cached_in_reg(ea, location);
end sub;

sub find_or_load_objval(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := move_value_to_reg(ea, candidates);
    if location != 0 then
        return;
    end if;
    location := allocate_reg_for_value(ea, candidates);

    load_objval(location, ea);
end sub;

# Loads *just the index part* of the EA into a register.
sub find_or_load_index(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    var indexea: EffectiveAddress;
    indexea.flags := EA_OBJVAL;
    indexea.varoff_id := 0;
    indexea.numoff_id := 0;
    if ea.varoff_id != 0 then
        indexea.obj_id := ea.varoff_id;
        ea.varoff_id := 0;
    else
        indexea.obj_id := ea.numoff_id;
        if indexea.obj_id == 0 then
            indexea.obj_id := add_number_by_value(0);
        end if;
        ea.numoff_id := 0;
    end if;

    print("* loading index value ");
    print_ea(&indexea);
    print_newline();

    location := find_or_load_objval(&indexea, candidates);
end sub;

sub find_or_load_ptrval(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := move_value_to_reg(ea, candidates);
    if location != 0 then
        return;
    end if;

    var indexreg: uint8 := find_or_load_index(ea, REG_Y);
    location := allocate_reg_for_value(ea, REG_A);
    ld_ind(location, indexreg, ea);
end sub;

sub save_objval_with_optional_index(location: uint8, ea: [EffectiveAddress])
    var indexreg: uint8 := 0;
    if ea.varoff_id != 0 then
        indexreg := find_or_load_index(ea, REG_X|REG_Y);
    end if;
    st_abs(location, indexreg, ea);
    free_reg(indexreg);
end sub;

sub save_ptrval_with_index(location: uint8, ea: [EffectiveAddress])
    var indexreg: uint8 := find_or_load_index(ea, REG_Y);
    st_ind(location, indexreg, ea);
    free_reg(indexreg);
end sub;

sub find_or_load_value(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    if ea.flags == EA_OBJVAL then
        location := find_or_load_objval(ea, candidates);
    elseif ea.flags == EA_PTRVAL then
        location := find_or_load_ptrval(ea, candidates);
    else
        print("can't load ");
        print_ea(ea);
        print(" yet");
        halt();
    end if;
end sub;

sub find_or_load_fixed_value(ea: [EffectiveAddress], candidates: uint8)
    var location: uint8 := find_or_load_value(ea, candidates);
end sub;

sub aluop_objval(ea: [EffectiveAddress], opcode: uint8)
    if is_number_thing(ea.obj_id) != 0 then
        op_imm(get_value_of_number(ea.obj_id), opcode & 0xFB);
    else
        var indexreg: uint8 := 0;
        if ea.varoff_id != 0 then
            indexreg := find_or_load_index(ea, REG_X|REG_Y);
            opcode := opcode | 0x10;
            if indexreg == REG_Y then
                opcode := opcode & 0xFB;
            end if;
        end if;

        op_abs(ea, opcode);

        free_reg(indexreg);
    end if;
end sub;

# Assumes the input value is in A. opcode must be an abs instruction in the 0x0D or 0x0E
# columns of the map. ea is read direct from memory (or via an immediate).
sub aluop_value(ea: [EffectiveAddress], opcode: uint8)
    if ea.flags == EA_OBJVAL then
        aluop_objval(ea, opcode);
    else
        print("can't alu ");
        print_ea(ea);
        print(" yet");
        halt();
    end if;
end sub;

sub find_or_load_int(value: uint8, candidates: uint8): (location: uint8)
    var ea: EffectiveAddress;
    ea.flags := EA_OBJVAL;
    ea.obj_id := add_number_by_value(value);
    ea.numoff_id := 0;
    ea.varoff_id := 0;
    location := find_or_load_value(&ea, candidates);
end sub;

sub find_or_load_fixed_int(value: uint8, candidates: uint8)
    var location: uint8 := find_or_load_int(value, candidates);
end sub;

sub find_or_load_value_with_flags(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    var oldlocation: uint8 := find_reg_with_value(ea, candidates);
    location := find_or_load_value(ea, candidates);
    if oldlocation != location then
        # The value was forced from memory, so the flags are set automatically.
    else
        write_byte(0x09); # ORA imm
        write_byte(0x00);
    end if;
end sub;

sub find_or_load_fixed_value_with_flags(ea: [EffectiveAddress], candidates: uint8)
    var location: uint8 := find_or_load_value_with_flags(ea, candidates);
end sub;

sub save_value(location: uint8, ea: [EffectiveAddress])
    if ea.flags == EA_OBJVAL then
        save_objval_with_optional_index(location, ea);
    elseif ea.flags == EA_PTRVAL then
        save_ptrval_with_index(location, ea);
    else
        print("can't save ");
        print_ea(ea);
        print(" yet");
        halt();
    end if;
end sub;

sub make_value_precious_or_save_now(location: uint8, ea: [EffectiveAddress])
    value_is_cached_in_reg(ea, location);
    if (ea.varoff_id != 0) or ((ea.flags & EA_DEREF_BEFORE) != 0) then
        print("* value ");
        print_ea(ea);
        print(" can't be made precious, saving now\n");
        save_value(location, ea);
    else
        value_is_precious(ea);
    end if;
end sub;

sub save_value_with_index_or_offset(location: uint8, ea: [EffectiveAddress], offset: uint8)
    if ea.flags == EA_OBJVAL then
        save_objval_with_offset(location, ea, offset);
    elseif ea.flags == EA_PTRVAL then
        find_or_load_fixed_int(offset, REG_Y);
        st_ind(location, REG_Y, ea);
        free_reg(REG_Y);
    else
        print("can't save ");
        print_ea(ea);
        print(" with offset 0x");
        print_hex_i8(offset);
        print(" yet");
        halt();
    end if;
end sub;
