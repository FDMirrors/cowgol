sub AllocLabel(): (label: LabelRef)
	label := next_label_id;
	next_label_id := next_label_id + 1;
end sub;

sub LookupSymbol(namespace: [Namespace], name: string): (symbol: [Symbol])
	if namespace == (0 as [Namespace]) then
		namespace := &current_subr.namespace;
	end if;
	
	while namespace != (0 as [Namespace]) loop
		symbol := namespace.first;
		while symbol != (0 as [Symbol]) loop
			if StrCmp(symbol.name, name) == 0 then
				while symbol.kind == TYPEDEF loop
					symbol := symbol.alias;
				end loop;
				return;
			end if;
			symbol := symbol.next;
		end loop;
		namespace := namespace.parent;
	end loop;

	symbol := (0 as [Symbol]);
end sub;

sub AddToNamespace(namespace: [Namespace], symbol: [Symbol])
	if namespace.last == (0 as [Symbol]) then
		namespace.first := symbol;
		namespace.last := symbol;
	else
		namespace.last.next := symbol;
		namespace.last := symbol;
	end if;
end sub;

# Consumes the string in Token
sub AddSymbol(namespace: [Namespace], token: [Token]): (symbol: [Symbol])
	if namespace == (0 as [Namespace]) then
		namespace := &current_subr.namespace;
	end if;

	symbol := Alloc(@bytesof Symbol) as [Symbol];
	if token != (0 as [Token]) then
		if LookupSymbol(namespace, token.string) != (0 as [Symbol]) then
			StartError();
			print("symbol '");
			print(token.string);
			print("' is already defined");
			EndError();
		end if;

		symbol.name := token.string;
		token.string := (0 as string);
	end if;

	AddToNamespace(namespace, symbol);
end sub;

# Consumes the string in Token
sub AddAlias(namespace: [Namespace], token: [Token], real: [Symbol]): (symbol: [Symbol])
	symbol := AddSymbol(namespace, token);
	symbol.kind := TYPEDEF;
	symbol.alias := real;
end sub;

sub CheckNotPartialType(type: [Symbol])
	if type.typedata.kind == TYPE_PARTIAL then
		StartError();
		print("'");
		print(type.name);
		print("' is a partial type");
		EndError();
	end if;
end sub;

sub InitVariable(symbol: [Symbol], type: [Symbol])
	CheckNotPartialType(type);
	symbol.vardata.type := type;
	symbol.vardata.subr := current_subr;
	ArchInitVariable(symbol);
	print("var ");
	print(symbol.name);
	print(" at ");
	print(current_subr.name);
	print(" 0x");
	print_hex_i16(symbol.vardata.offset as uint16);
	print("+");
	print_hex_i16(symbol.vardata.type.typedata.width as uint16);
	print_nl();
end sub;

sub MakeNumberType(width: uint8, is_signed: uint8, name: string): (symbol: [Symbol])
	symbol := Alloc(@bytesof Symbol) as [Symbol];
	symbol.kind := TYPE;
	symbol.typedata.kind := TYPE_NUMBER;
	symbol.typedata.width := width as uint16;
	symbol.typedata.stride := width as uint16;
	symbol.typedata.alignment := ArchAlignUp(1, width) as uint8;
	symbol.typedata.numbertype.is_signed := is_signed;
	symbol.name := name;
	AddToNamespace(&current_subr.namespace, symbol);
end sub;

sub MakePointerType(type: [Symbol]): (ptrtype: [Symbol])
	ptrtype := type.typedata.pointerto;
	if ptrtype == (0 as [Symbol]) then
		ptrtype := AddSymbol(0 as [Namespace], 0 as [Token]);
		ptrtype.name := StrDupBraced(type.name);
		ptrtype.kind := TYPE;
		ptrtype.typedata.kind := TYPE_POINTER;
		ptrtype.typedata.width := intptr_type.typedata.width;
		ptrtype.typedata.alignment := intptr_type.typedata.alignment;
		ptrtype.typedata.stride := intptr_type.typedata.stride;
		ptrtype.typedata.pointertype.element := type;
		type.typedata.pointerto := ptrtype;
	end if;
end sub;

