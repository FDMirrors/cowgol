
sub BadNodeWidth(width: uint8)
	print("bad midcode width ");
	print_i8(width);
	print_nl();
	ExitWithError();
end sub;

sub WidthToIndex(width: uint8): (index: uint8)
	case width is
		when 4: index := 3;
		when 8: index := 4;
		when else: index := width;
	end case;
end sub;

include "midcodes.coh";

# Free up the node tree rooted in the parameter. This is more exciting than it
# should be because we don't have recursion.
sub Discard(node: [Node])
	var pending := node;
	while pending != (0 as [Node]) loop
		node := pending;
		pending := node.dlink;

		# Unlink and push any children.
		if node.left != (0 as [Node]) then
			node.left.dlink := pending;
			pending := node.left;
		end if;
		if node.right != (0 as [Node]) then
			node.right.dlink := pending;
			pending := node.right;
		end if;

		# Now free this node.
		Free(node as [uint8]);
	end loop;
end sub;

sub NodeWidth(node: [Node]): (width: uint8)
	width := 0;
	if node.type != (0 as [Symbol]) then
		width := node.type.typedata.width as uint8;
	end if;
end sub;

sub RotateParameters(lhs: [Node], rhs: [Node]): (newlhs: [Node], newrhs: [Node])
	if lhs.type != (0 as [Symbol]) then
		newlhs := lhs;
		newrhs := rhs;
	else
		newlhs := rhs;
		newrhs := lhs;
	end if;
end sub;

sub MidCNeg(width: uint8, lhs: [Node]): (result: [Node])
	if lhs.op == MIDCODE_CONSTANT then
		lhs.constant.value := -lhs.constant.value;
		result := lhs;
	else
		result := MidNeg(width, lhs);
	end if;
end sub;

sub MidCNot(width: uint8, lhs: [Node]): (result: [Node])
	if lhs.op == MIDCODE_CONSTANT then
		lhs.constant.value := ~lhs.constant.value;
		result := lhs;
	else
		result := MidNot(width, lhs);
	end if;
end sub;

sub MidCAnd(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	(lhs, rhs) := RotateParameters(lhs, rhs);
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value := lhs.constant.value & rhs.constant.value;
		Discard(rhs);
		result := lhs;
	else
		result := MidAnd(width, lhs, rhs);
	end if;
end sub;

sub MidCOr(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	(lhs, rhs) := RotateParameters(lhs, rhs);
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value := lhs.constant.value | rhs.constant.value;
		Discard(rhs);
		result := lhs;
	else
		result := MidOr(width, lhs, rhs);
	end if;
end sub;

sub MidCEor(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	(lhs, rhs) := RotateParameters(lhs, rhs);
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value := lhs.constant.value ^ rhs.constant.value;
		Discard(rhs);
		result := lhs;
	else
		result := MidEor(width, lhs, rhs);
	end if;
end sub;

sub MidCAdd(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	(lhs, rhs) := RotateParameters(lhs, rhs);
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value := lhs.constant.value + rhs.constant.value;
		Discard(rhs);
		result := lhs;
	else
		result := MidAdd(width, lhs, rhs);
	end if;
end sub;

sub MidCSub(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value := lhs.constant.value - rhs.constant.value;
		Discard(rhs);
		result := lhs;
	elseif rhs.op == MIDCODE_CONSTANT then
		rhs.constant.value := -rhs.constant.value;
		result := MidAdd(width, lhs, rhs);
	else
		result := MidSub(width, lhs, rhs);
	end if;
end sub;

sub MidCMul(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	(lhs, rhs) := RotateParameters(lhs, rhs);
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value := lhs.constant.value + rhs.constant.value;
		Discard(rhs);
		result := lhs;
	else
		result := MidMul(width, lhs, rhs);
	end if;
end sub;
		
sub MidCDivu(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value :=
			((lhs.constant.value as uint32) / (rhs.constant.value as uint32)) as int32;
		Discard(rhs);
		result := lhs;
	else
		result := MidDivu(width, lhs, rhs);
	end if;
end sub;

sub MidCDivs(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value := lhs.constant.value / rhs.constant.value;
		Discard(rhs);
		result := lhs;
	else
		result := MidDivs(width, lhs, rhs);
	end if;
end sub;

sub MidCRems(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value :=
			((lhs.constant.value as uint32) % (rhs.constant.value as uint32)) as int32;
		Discard(rhs);
		result := lhs;
	else
		result := MidRems(width, lhs, rhs);
	end if;
end sub;

sub MidCRemu(width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value := lhs.constant.value % rhs.constant.value;
		Discard(rhs);
		result := lhs;
	else
		result := MidRemu(width, lhs, rhs);
	end if;
end sub;

sub MidCCast(width: uint8, lhs: [Node], issigned: uint8): (result: [Node])
	var srcwidth := lhs.type.typedata.width as uint8;
	if srcwidth == width then
		result := lhs;
	else
		case srcwidth is
			when 1: result := MidCast1(width, lhs, issigned);
			when 2: result := MidCast2(width, lhs, issigned);
			when 4: result := MidCast4(width, lhs, issigned);
			when 8: result := MidCast8(width, lhs, issigned);
		end case;
	end if;
end sub;

