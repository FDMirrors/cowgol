typedef LabelRef is uint16;
typedef Arith is int32;
typedef Size is uint16;

record Token is
	number @at(0): int32;
	string @at(0): string;
end record;

record Namespace is
	first: [Symbol];
	last: [Symbol];
	parent: [Namespace];
end record;

record HasElementSymbol is
	element: [Symbol];
end record;

record ArrayTypeSymbol: HasElementSymbol is
	size: Size;
	indextype: [Symbol];
end record;

record PointerTypeSymbol: HasElementSymbol is
end record;

record RecordTypeSymbol is
	namespace: Namespace;
	members: uint8;
end record;

record NumberTypeSymbol is
	is_signed: uint8;
end record;

record InterfaceTypeSymbol is
	subr: [Subroutine];
end record;

const TYPE_PARTIAL := 1;
const TYPE_NUMBER := 2;
const TYPE_POINTER := 3;
const TYPE_ARRAY := 4;
const TYPE_RECORD := 5;
const TYPE_INTERFACE := 6;

record TypeSymbol is
	numbertype @at(0): NumberTypeSymbol;
	arraytype @at(0): ArrayTypeSymbol;
	pointertype @at(0): PointerTypeSymbol;
	recordtype @at(0): RecordTypeSymbol;
	interfacetype @at(0): InterfaceTypeSymbol;

	pointerto: [Symbol];
	kind: uint8;
	alignment: uint8;
	width: Size;
	stride: Size;
end record;

record VarSymbol is
	type: [Symbol];
	subr: [Subroutine]; # null for a member
	next_parameter: [Symbol]; # for lists of parameters
	externname: string;
	offset: Size;
end record;

record Symbol is
	typedata @at(0): TypeSymbol;
	vardata @at(0): VarSymbol;
	constant @at(0): Arith;
	subr @at(0): [Subroutine];
	alias @at(0): [Symbol];

	kind: uint8;
	name: string;
	next: [Symbol];
end record;

const SUB_HAS_IMPL     := 0b01;
const SUB_IS_INTERFACE := 0b10;

record Subroutine is
	name: string;
	parent: [Subroutine];
	namespace: Namespace;
	first_input_parameter: [Symbol];
	first_output_parameter: [Symbol];
	id: uint16;
	workspace: Size[4];
	old_break_label: LabelRef;
	old_continue_label: LabelRef;
	old_call: [Subroutine];
	arch: [ArchSubroutine];
	num_input_parameters: uint8;
	num_output_parameters: uint8;
	flags: uint8;
end record;

record LoopLabels is
	loop_label: LabelRef;
	exit_label: LabelRef;
	old_break_label: LabelRef;
	old_continue_label: LabelRef;
end record;
	
record IfLabels is
	exit_label: LabelRef;
	true_label: LabelRef;
	false_label: LabelRef;
	next: [IfLabels];
end record;

record CaseLabels is
	next_label: LabelRef;
	break_label: LabelRef;
	old_break_label: LabelRef;
	old_case: [CaseLabels];
	width: uint8;
	seenelse: uint8;
end record;

record SubroutineCall is
	subr: [Subroutine];
	parent: [SubroutineCall];
	input_parameter: [Symbol];
	output_parameter: [Symbol];
	num_input_args: uint8;
	num_output_args: uint8;
end record;

var current_subr: [Subroutine];
var next_label_id: LabelRef := 1;
var next_subr_id: uint16 := 1;
var break_label: LabelRef;
var continue_label: LabelRef;
var current_if: [IfLabels];
var current_case: [CaseLabels];
var current_type: [Symbol];
var current_call: [SubroutineCall];

const REG_SAME_AS_INSTRUCTION_RESULT := -1;

# Forward references

@decl sub PushNode(node: [Node]);
@decl sub PopNode(): (node: [Node]);
@decl sub NextNode(): (node: [Node]);
var nodes: [Node][16];
var next_node := &nodes[0];

@decl sub Discard(node: [Node]);

