const SYM_UNDECLARED := 0;
const SYM_DEFINED    := 0b01;
const SYM_EXPORTED   := 0b10;

record Symbol
	next: [Symbol];
	name: string;
	id: SubId;
	state: uint8;
end record;

var main_symbol: Symbol;

var symbols: [Symbol] := &main_symbol;

var current_id: SubId := 1;
var current_subr: [Symbol] := &main_symbol;

sub GetSymbol(name: string): (symbol: [Symbol])
	symbol := symbols;
	while symbol != (0 as [Symbol]) loop
		if StrCmp(name, symbol.name) == 0 then
			return;
		end if;
		symbol := symbol.next;
	end loop;

	symbol := Alloc(@bytesof Symbol) as [Symbol];
	symbol.name := StrDup(name);
	symbol.id := current_id;
	current_id := current_id + 1;
	symbol.next := symbols;
	symbols := symbol;
end sub;
	
sub ProcessFile()
	main_symbol.name := "@";
	EmitterPushChunk();
	E_h16(current_subr.id);

	var c: uint8;
	var subrid: uint16 := 0;
	var buffer: uint8[32];

	sub GetC()
		c := FCBGetChar(&infcb);
	end sub;

	sub SkipToEndOfLine()
		loop
			if (c == 0) or (c == 26) or (c == 10) then
				break;
			end if;
			GetC();
		end loop;
	end sub;

	sub SkipWhitespace()
		loop
			if (c != ' ') and (c != '\t') then
				break;
			end if;
			GetC();
		end loop;
	end sub;

	sub ReadWord()
		SkipWhitespace();
		var p := &buffer[0];
		loop
			if (c == 0) or (c == 26) or (c == 10) or (c == ' ') or (c == '\t') then
				break;
			end if;

			[p] := c;
			p := p + 1;
			if p == &buffer[@sizeof buffer] then
				FatalError("word too long");
			end if;

			GetC();
		end loop;
		[p] := 0;
	end sub;

	sub ReadNumber(): (result: int32)
		ReadWord();
		var p: string;
		(result, p) := AToI(&buffer[0]);
		if p == &buffer[0] then
			FatalError("malformed number");
		end if;
	end sub;

	sub ExportSubroutine()
		GetC();
		ReadWord();
		var symbol := GetSymbol(&buffer[0]);
		if (symbol.state & SYM_EXPORTED) == 0 then
			symbol.state := symbol.state | SYM_EXPORTED;
			EmitterDeclareExternal(symbol.id, symbol.name);
		end if;
	end sub;

	sub CloseSubroutine()
		if current_subr != (0 as [Symbol]) then
			EmitterPopChunk('S');
			current_subr := (0 as [Symbol]);
		end if;
	end sub;

	sub DefineSubroutine()
		CloseSubroutine();

		GetC();
		ReadWord();
		current_subr := GetSymbol(&buffer[0]);
		current_subr.state := current_subr.state | SYM_DEFINED;

		if current_subr != &main_symbol then
			EmitterDeclareSubroutine(current_subr.id, current_subr.name);
		end if;
		EmitterPushChunk();
		E_h16(current_subr.id);
	end sub;

	sub SourceLine()
		loop
			if (c == 0) or (c == 10) or (c == 26) then
				break;
			end if;
			if c != 13 then
				if c == '`' then
					GetC();
					ReadWord();
					var subr := GetSymbol(&buffer[0]);
					EmitByte('`');
					E_h16(subr.id);
					EmitterReferenceSubroutine(current_subr.id, subr.id);
				else
					EmitByte(c);
					GetC();
				end if;
			end if;
		end loop;
		EmitByte(10);
	end sub;

	GetC();
	loop
		if (c == 0) or (c == 26) then
			break;
		end if;
		case c is
			when '&':
				GetC();
				case c is
					when 'X':
						ExportSubroutine();

					when 'S':
						DefineSubroutine();

					when else:
						FatalError("bad cowwrap command");
				end case;
				SkipToEndOfLine();

			when '#':
				SkipToEndOfLine();

			when else:
				SourceLine();
		end case;
		GetC();
	end loop;
	CloseSubroutine();
end sub;

sub CheckSymbols()
	var success: uint8 := 1;
	var s := symbols;
	while s != (0 as [Symbol]) loop
		if s.state == SYM_UNDECLARED then
			print("reference to undeclared symbol '");
			print(s.name);
			print("'\n");
			success := 0;
		end if;
		s := s.next;
	end loop;

	if success == 0 then
		FatalError("failed");
	end if;
end sub;

