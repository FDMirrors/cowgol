&X _mul4
&X _divu4
&X _remu4
&X _cmp4
&X _cmps4

&X _lshift1
; Shifts A left Y bits.
``:
	dey
	bmi ``_exit
	asl
	jmp ``
``_exit:
	rts

&X _rshiftu1
; Logical shift A right Y bits.
``:
	dey
	bmi ``_exit
	lsr
	jmp ``
``_exit:
	rts

&X _rshifts1
; Arithmetic shift A right Y bits.
``:
	dey
	bmi ``_exit
	cmp #$80
	ror
	jmp ``
``_exit:
	rts

&X _lshift2
&W _lshift2 1 2
; Shifts AX left Y bits.
``:
	sta `$_lshift2.1.0
	stx `$_lshift2.1.1
``_loop:
	dey
	bmi ``_exit
	asl `$_lshift2.1.0
	rol `$_lshift2.1.1
	jmp ``_loop
``_exit:
	lda `$_lshift2.1.0
	ldx `$_lshift2.1.1
	rts

&X _rshiftu2
&W _rshiftu2 1 2
; Logical shifts AX right Y bits.
``:
	sta `$_lshift2.1.0
	stx `$_lshift2.1.1
``_loop:
	dey
	bmi ``_exit
	lsr `$_lshift2.1.1
	ror `$_lshift2.1.0
	jmp ``_loop
``_exit:
	lda `$_lshift2.1.0
	ldx `$_lshift2.1.1
	rts

&X _rshifts2
&W _rshifts2 1 2
; Arithmetic shifts AX right Y bits.
``:
	sta `$_lshift2.1.0
	stx `$_lshift2.1.1
``_loop:
	dey
	bmi ``_exit
	lda `$_lshift2.1.1
	cmp #$80
	ror `$_lshift2.1.1
	ror `$_lshift2.1.0
	jmp ``_loop
``_exit:
	lda `$_lshift2.1.0
	ldx `$_lshift2.1.1
	rts

&S shiftsmem
&W shiftsmem 1 6

&S startshift
``:
	sta `$shiftsmem.1.0
	stx `$shiftsmem.1.1
	tya
	tax
	ldy #3
-
	lda (`$shiftsmem.1.0), y
	sta `$shiftsmem.1.2, y
	dey
	bpl -
	rts

&S endshift
``:
	ldy #3
-
	lda `$.1.2, y
	sta (`$.1.0), y
	dey
	bpl -
	rts

&X _lshift4
; Shifts [AX] left Y bits.
``:
	jsr `startshift
``_loop:
	dex
	bmi `endshift
	asl `$shiftsmem.1.2
	rol `$shiftsmem.1.3
	rol `$shiftsmem.1.4
	rol `$shiftsmem.1.5
	jmp ``_loop

&X _rshiftu4
; Logical shifts [AX] right Y bits.
``:
	jsr `startshift
``_loop:
	dex
	bmi `endshift
	lsr `$shiftsmem.1.5
	ror `$shiftsmem.1.4
	ror `$shiftsmem.1.3
	ror `$shiftsmem.1.2
	jmp ``_loop

&X _rshifts4
; Arithmetic shifts [AX] right Y bits.
``:
	jsr `startshift
``_loop:
	dex
	bmi `endshift
	lda `$shiftsmem.1.5
	cmp #$80
	ror `$shiftsmem.1.5
	ror `$shiftsmem.1.4
	ror `$shiftsmem.1.3
	ror `$shiftsmem.1.2
	jmp ``_loop

&X _mul1
&W _mul1 1 2
; Multiplies A = A * X.
``:
	sta `$.1.0
	stx `$.1.1
	lda #0
	ldx #8
	lsr `$.1.0
``_loop:
	bcc ``_noadd
	clc
	adc `$.1.1
``_noadd:
	ror
	ror `$.1.0
	dex
	bne ``_loop
	lda `$.1.0
	rts

&X _divu1
&W _divu1 1 2
; Unsigned divide of A = A / X, remainder in X.
``:
	sta `$.1.0
	stx `$.1.1
	lda #0
	ldx #8
	asl `$.1.0
``_1:
	rol
	cmp `$.1.1
	bcc ``_2
	sbc `$.1.1
``_2:
	rol `$.1.0
	dex
	bne ``_1
	tax
	lda `$.1.0
	rts

&X _mul2
&W _mul2 1 6
; Multiplies betos * XA. Returns XA.
``:
	sta `$.1.0+0
	stx `$.1.0+1
	tsx
	lda $103,x
	sta `$.1.2+1
	lda $104,x
	sta `$.1.2+0
	lda #0
	sta `$.1.4+1
	ldy #$11
	clc
``_loop:
	ror `$.1.4+1
	ror
	ror `$.1.0+1
	ror `$.1.0+0
	bcc ``_2
	clc
	adc `$.1.2+0
	pha
	lda `$.1.2+1
	adc `$.1.4+1
	sta `$.1.4+1
	pla
``_2:
	dey
	bne ``_loop
	lda `$.1.0+0
	ldx `$.1.0+1
	rts


