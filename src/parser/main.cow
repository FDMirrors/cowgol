# These occupy the same namespace as tokens.
const LEX_TOP := 200;

var lexical_stack: uint16[32];
var lexical_stack_ptr: uint8 := 0;

var current_namespace_id: uint16;
var current_subroutine_id: uint16;

sub halt()
    print(" at ");
    if filename_id != 0 then
        print_string_thing(filename_id);
    else
        print("?");
    end if;
    print_char(':');
    print_i16(line_no);
    print_newline();
    exit(1);
end sub;

sub lexical_push(value: uint16)
    if lexical_stack_ptr == lexical_stack'size then
        print("lexical stack overflow");
        halt();
    end if;

    lexical_stack[lexical_stack_ptr] := value;
    lexical_stack_ptr := lexical_stack_ptr + 1;
end sub;

sub lexical_pop(out value: uint16)
    if lexical_stack_ptr == 0 then
        print("lexical stack underflow");
        halt();
    end if;

    lexical_stack_ptr := lexical_stack_ptr - 1;
    value := lexical_stack[lexical_stack_ptr];
end sub;

sub lexical_peek(out value: uint16)
    value := lexical_stack[lexical_stack_ptr - 1];
end sub;

sub lexical_pop_scope_type(type: uint16)
    if lexical_pop() != type then
        print("mismatched lexical scope terminator");
        halt();
    end if;
end sub;

sub create_function(out subroutine_id: uint16, out namespace_id: uint16)
    subroutine_id := create_thing(THING_SUBROUTINE, SubroutineThing'bytes);
    namespace_id := create_thing(THING_NAMESPACE, NamespaceThing'bytes);
    var namespace: [NamespaceThing] := find_thing(namespace_id) as [NamespaceThing];
    namespace.previous_namespace := current_namespace_id;
    var subroutine: [SubroutineThing] := find_thing(subroutine_id) as [SubroutineThing];
    subroutine.namespace := namespace_id;
end sub;

sub find_symbol_in_namespace(identifier_id: uint16, namespace_id: uint16, out symbol_id: uint16)
    var namespace: [NamespaceThing] := find_thing(namespace_id) as [NamespaceThing];
    symbol_id := namespace.first_symbol;

    while symbol_id != 0 loop
        var symbol: [SymbolThing] := find_thing(symbol_id) as [SymbolThing];
        if symbol.name == identifier_id then
            return;
        end if;
        symbol_id := symbol.next_symbol;
    end loop;

    symbol_id := 0;
end sub;

sub find_symbol(identifier_id: uint16, out symbol_id: uint16)
    var namespace_id: uint16 := current_namespace_id;

    while namespace_id != 0 loop
        symbol_id := find_symbol_in_namespace(identifier_id, namespace_id);
        if symbol_id != 0 then
            return;
        end if;

        var namespace: [NamespaceThing] := find_thing(namespace_id) as [NamespaceThing];
        namespace_id := namespace.previous_namespace;
    end loop;

    print("symbol with identifier 0x");
    print_hex_i16(identifier_id);
    print(" not found in any scope");
    halt();
end sub;

sub name_symbol(identifier_id: uint16, symbol_id: uint16, namespace_id: uint16)
    var symbol: [SymbolThing] := find_thing(symbol_id) as [SymbolThing];
    var namespace: [NamespaceThing] := find_thing(namespace_id) as [NamespaceThing];

    if find_symbol_in_namespace(identifier_id, namespace_id) != 0 then
        print("symbol with identifier 0x");
        print_hex_i16(identifier_id);
        print(" is already defined in this namespace");
        halt();
    end if;

    symbol.next_symbol := namespace.first_symbol;
    namespace.first_symbol := symbol_id;
    symbol.name := identifier_id;
end sub;

sub push_subroutine()
    lexical_push(current_subroutine_id);
    lexical_push(current_namespace_id);
    lexical_push(TOKEN_SUB);
end sub;

sub pop_subroutine()
    lexical_pop_scope_type(TOKEN_SUB);
    current_namespace_id := lexical_pop();
    current_subroutine_id := lexical_pop();
end sub;

sub create_bootstrap_type(name: [int8], out type: [NumericThing])
    var identifier_id: uint16 := find_thing_by_value(THING_IDENTIFIER, string_length(name), name);
    var type_id: uint16 := create_thing(THING_NUMERIC, NumericThing'bytes);
    name_symbol(identifier_id, type_id, current_namespace_id);
    type := find_thing(type_id) as [NumericThing];
end sub;

sub init_parser()
    current_namespace_id := 0;
    lexical_push(LEX_TOP);

    create_function(current_subroutine_id, current_namespace_id);

    var type: [NumericThing];
    type := create_bootstrap_type("int8");
    type.thing_type := THING_SIGNED;
    type.width := 1;

    type := create_bootstrap_type("uint8");
    type.thing_type := THING_UNSIGNED;
    type.width := 1;

    type := create_bootstrap_type("int16");
    type.thing_type := THING_SIGNED;
    type.width := 2;

    type := create_bootstrap_type("uint16");
    type.thing_type := THING_UNSIGNED;
    type.width := 2;

    type := create_bootstrap_type("int32");
    type.thing_type := THING_SIGNED;
    type.width := 4;

    type := create_bootstrap_type("uint32");
    type.thing_type := THING_UNSIGNED;
    type.width := 4;
end sub;

sub expect_token(expected: uint16)
    if current_token != expected then
        print("expected 0x");
        print_hex_i16(expected);
        print(" but got 0x");
        print_hex_i16(current_token);
        halt();
    end if;
    next_token_without_whitespace();
end sub;

sub expect_identifier(out id: uint16)
    if (current_token & TOKEN_TYPE_MASK) != TOKEN_TYPE_IDENTIFIER then
        print("missing identifier");
        halt();
    end if;

    id := current_token & TOKEN_VALUE_MASK;
    next_token_without_whitespace();
end sub;

sub read_type(out type_id: uint16)
    var identifier_id: uint16 := expect_identifier();
    type_id := find_symbol(identifier_id);
    var type: [TypeThing] := find_thing(type_id) as [TypeThing];
    if (type.thing_type & THING_TYPE) != THING_TYPE then
        print("identifier 0x");
        print_hex_i16(identifier_id);
        print(" does not refer to a type");
    end if;
end sub;

sub do_sub()
    var old_namespace_id: uint16 := current_namespace_id;

    push_subroutine();
    expect_token(TOKEN_SUB);
    var id: uint16 := expect_identifier();
    create_function(current_subroutine_id, current_namespace_id);
    name_symbol(id, current_subroutine_id, old_namespace_id);

    expect_token(TOKEN_OPENPAREN);

    while current_token != TOKEN_CLOSEPAREN loop
        var inout: uint16 := TOKEN_IN;
        if (current_token == TOKEN_IN) | (current_token == TOKEN_OUT) | (current_token == TOKEN_INOUT) then
            inout := current_token;
            next_token_without_whitespace();
        end if;

        id := expect_identifier();
        expect_token(TOKEN_COLON);
        var type_id: uint16 := read_type();

        var parameter_id: uint16 := create_thing(THING_PARAMETER, ParameterThing'bytes);
        name_symbol(id, parameter_id, current_namespace_id);
        var parameter: [ParameterThing] := find_thing(parameter_id) as [ParameterThing];
        parameter.inout := inout;
        parameter.type := type_id;

        if current_token != TOKEN_COMMA then
            break;
        end if;
        next_token_without_whitespace();
    end loop;
    expect_token(TOKEN_CLOSEPAREN);
end sub;

sub do_end()
    expect_token(TOKEN_END);
    if current_token != lexical_peek() then
        print("can't close a 0x");
        print_hex_i16(lexical_peek());
        print(" with a 0x");
        print_hex_i16(current_token);
        halt();
    end if;
    if current_token == TOKEN_SUB then
        expect_token(TOKEN_SUB);
        pop_subroutine();
    else
        print("can't close 0x");
        print_hex_i16(current_token);
        print(" yet");
        halt();
    end if;
    expect_token(TOKEN_SEMICOLON);
end sub;

init_parser();
init_tokeniser();

while current_token != 0 loop
    if current_token == TOKEN_SUB then
        do_sub();
    elseif current_token == TOKEN_END then
        do_end();
    else
        print("unknown token 0x");
        print_hex_i16(current_token);
        halt();
    end if;
end loop;

print("thing table size: ");
print_i16(thing_table_top);
print_newline();
save_thing_table("things.dat");
