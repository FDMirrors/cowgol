const REG_A    := 0b0000_0001;
const REG_X    := 0b0000_0010;
const REG_Y    := 0b0000_0100;
const REG_MASK := 0b0111_1111;
const PRECIOUS := 0b1000_0000;

record Insn
    datareg: uint8;
    obj_id: uint16;
    offset: uint16;
    indexreg: uint8;
    mode: uint8;
end record;

const MODE_DIR := 1;
const MODE_IND := 2;
const MODE_IMMLO := 3;
const MODE_IMMHI := 4;

var insn: Insn;

sub save_insn(storage: [Insn])
    copy_memory(&insn as [int8], storage as [int8], Insn@bytes);
end sub;

sub load_insn(storage: [Insn])
    copy_memory(storage as [int8], &insn as [int8], Insn@bytes);
end sub;

sub insn_init()
    zero_memory(&insn as [int8], Insn@bytes);
end sub;

sub bad_register()
    print("bad register");
    halt();
end sub;

sub find_bit_index(value: uint8): (index: uint8)
    var mask: uint8 := 1;
    index := 0;
    loop
        if (value & mask) != 0 then
            return;
        end if;
        if mask == 0x80 then
            break;
        end if;
        mask := mask << 1;
        index := index + 1;
    end loop;
    print("bit not set");
    halt();
end sub;

sub convert_lea_ea_to_addressof(ea: [EffectiveAddress])
    if ea.flags == EA_LEA then
        var ptr_id: uint16 := add_addressof_by_value(ea.obj_id,
            get_value_of_number(ea.numoff_id) as uint16);
        var ptrthing: [AddressOfThing] := find_thing(ptr_id) as [AddressOfThing];
        ptrthing.segment := SEGMENT_CONST;
        ea.obj_id := ptr_id;
        ea.numoff_id := 0;
        ea.flags := EA_VALUE;
    end if;
end sub;

sub insn_long_init_from_ea(ea: [EffectiveAddress])
    convert_lea_ea_to_addressof(ea);
    insn_init();
    insn.obj_id := ea.obj_id;
    insn.offset := get_value_of_number(ea.numoff_id) as uint16;
    if ea.flags == EA_DEREF then
        insn.mode := MODE_IND;
    else
        insn.mode := MODE_DIR;
    end if;
end sub;

# Like insn_long_init_from_ea(), but if the value is a number, turn it into
# a MODE_IMM mode.
sub insn_init_from_ea(ea: [EffectiveAddress])
    insn_init();
    insn.obj_id := ea.obj_id;
    insn.offset := get_value_of_number(ea.numoff_id) as uint16;
    if ea.flags == EA_VALUE then
        if is_number_thing(insn.obj_id) != 0 then
            if insn.offset == 0 then
                insn.mode := MODE_IMMLO;
            elseif insn.offset == 1 then
                insn.mode := MODE_IMMHI;
            else
                print("bad offset to immediate value");
                halt();
            end if;

            insn.offset := get_value_of_number(insn.obj_id) as uint16;
            insn.obj_id := 0;
        else
            insn.mode := MODE_DIR;
        end if;
    elseif ea.flags == EA_DEREF then
        insn.mode := MODE_IND;
    else
        insn.mode := MODE_IMMLO;
    end if;
end sub;

sub print_insn()
    print(" datareg=");
    print_i8(insn.datareg);
    print(" thing=");
    print_thing(insn.obj_id);
    print(" offset=0x");
    print_hex_i16(insn.offset);
    print(" indexreg=");
    print_i8(insn.indexreg);
    print(" mode=");
    print_i8(insn.mode);
    print_newline();
end sub;

sub insn_check_imm()
    if ((insn.mode != MODE_IMMLO) and (insn.mode != MODE_IMMHI)) or (insn.indexreg != 0) then
        print("insn_check_imm fail");
        halt();
    end if;
end sub;

sub insn_check_abs()
    if insn.mode != MODE_DIR then
        print("insn_check_abs fail");
        halt();
    end if;
end sub;

sub insn_check_alu_abs()
    insn_check_abs();
    if insn.datareg != REG_A then
        print("insn_check_alu_abs fail");
        halt();
    end if;
end sub;

sub insn_check_ind()
    if (insn.mode != MODE_IND) or (insn.indexreg == 0) or (insn.offset != 0)
        or (insn.datareg != REG_A) or (insn.indexreg == REG_A)
    then
        print("insn_check_ind fail");
        halt();
    end if;
end sub;

sub insn_check_mutate()
    if (insn.mode != MODE_DIR) or (insn.indexreg == REG_A) or (insn.indexreg == REG_X) then
        print("insn_check_mutate fail");
        halt();
    end if;
end sub;

sub insn_op_imm(value: uint8, opcode: uint8)
	$if DEBUG
		print("@ insn_op_imm 0x");
		print_hex_i8(opcode);
		print(" value=0x");
		print_hex_i8(value);
		print_newline();
	$endif
    insn_check_imm();

    var buf: uint8[2];
    buf[0] := opcode;
    buf[1] := value;
    write_bytes_iop(buf@size, &buf[0]);
end sub;

var ld_imm_opcodes: uint8[3] := {
    0xA9, # LDA imm
    0xA2, # LDX imm
    0xA0 # LDY imm
};

sub insn_ld_imm(value: uint8)
    insn_op_imm(value, ld_imm_opcodes[find_bit_index(insn.datareg)]);
end sub;

sub insn_op_imm_adr(beiop: uint8, opcode: uint8)
	$if DEBUG
		print("@ insn_op_imm_adr 0x");
		print_hex_i8(opcode);
		print(" iop=0x");
		print_hex_i8(beiop);
        print_insn();
	$endif
    insn_check_imm();

    write_byte(opcode);
    write_address_iop(beiop, insn.obj_id, insn.offset);
end sub;

sub insn_ld_imm_adr_lo()
    insn_op_imm_adr(IOP_ADDRESSLO, ld_imm_opcodes[find_bit_index(insn.datareg)]);
end sub;

sub insn_ld_imm_adr_hi()
    insn_op_imm_adr(IOP_ADDRESSHI, ld_imm_opcodes[find_bit_index(insn.datareg)]);
end sub;

sub insn_op_abs(opcode: uint8)
	$if DEBUG
		print("@ insn_op_abs 0x");
		print_hex_i8(opcode);
        print_insn();
	$endif
    insn_check_abs();

    var obj: [DataThing] := find_thing(insn.obj_id) as [DataThing];
    var beiop: uint8;
    if ((opcode & 0x0F) == 0x01) then
        if obj.segment != SEGMENT_ZEROPAGE then
            print("indirect op with non zero-page object");
            halt();
        end if;
        beiop := IOP_ADDRESSLO;
    elseif (obj.segment == SEGMENT_ZEROPAGE) and ((opcode & 0x0C) == 0x0C) then
        opcode := opcode & 0xf7;
        beiop := IOP_ADDRESSLO;
    elseif obj.segment == SEGMENT_UNKNOWN then
        print("segment of ");
        print_thing(insn.obj_id);
        print(" not known");
        halt();
    else
        beiop := IOP_ADDRESS;
    end if;

    write_byte(opcode);
    write_address_iop(beiop, insn.obj_id, insn.offset);
end sub;

var ld_abs_opcodes: uint8[3] := {
    0xAD, # LDA abs
    0xAE, # LDX abs
    0xAC # LDY abs
};

var ld_abs_x_opcodes: uint8[3] := {
    0xBD, # LDA abs, X
    0x00, # invalid
    0xBC # LDY abs, X
};

var ld_abs_y_opcodes: uint8[3] := {
    0xB9, # LDA abs, Y
    0xBE, # LDX abs, Y
    0x00 # invalid
};

sub insn_ldst_abs(opmask: uint8)
    var opcode: uint8 := 0;

    var location: uint8 := find_bit_index(insn.datareg);
    if insn.indexreg == 0 then
        opcode := ld_abs_opcodes[location];
    elseif insn.indexreg == REG_X then
        opcode := ld_abs_x_opcodes[location];
    elseif insn.indexreg == REG_Y then
        opcode := ld_abs_y_opcodes[location];
    end if;

    if opcode == 0 then
        bad_register();
    end if;
    opcode := opcode & opmask;

    insn_op_abs(opcode);
end sub;

sub insn_ld_abs()
    insn_ldst_abs(0b11111111);
end sub;

# opcode must be the abs form of a column D opcode
sub insn_alu_abs(opcode: uint8)
    insn_check_alu_abs();

    if insn.indexreg == REG_X then
        opcode := opcode | 0b00010000;
    elseif insn.indexreg == REG_Y then
        opcode := (opcode | 0b00010000) & 0b11111011;
    end if;

    insn_op_abs(opcode);
end sub;

sub insn_st_abs()
    insn_ldst_abs(0b11011111);
end sub;

sub insn_op_ind(opcode: uint8)
	$if DEBUG
		print("@ insn_op_ind 0x");
		print_hex_i8(opcode);
        print_insn();
	$endif
    insn_check_ind();

    write_byte(opcode);
    write_address_iop(IOP_ADDRESSLO, insn.obj_id, 0);
end sub;

sub insn_ld_ind()
    insn_op_ind(0xB1); # LDA (ind), Y
end sub;

sub insn_st_ind()
    insn_op_ind(0x91); # STA (ind), Y
end sub;

sub insn_load_object()
    if insn.mode == MODE_DIR then
        insn_ld_abs();
    elseif insn.mode == MODE_IND then
        insn_ld_ind();
    elseif insn.mode == MODE_IMMLO then
        if insn.obj_id != 0 then
            insn_ld_imm_adr_lo();
        else
            insn_ld_imm(insn.offset as uint8);
        end if;
    elseif insn.mode == MODE_IMMHI then
        if insn.obj_id != 0 then
            insn_ld_imm_adr_hi();
        else
            insn_ld_imm((insn.offset >> 8) as uint8);
        end if;
    end if;
end sub;

# opcode must be the abs form of a column D opcode.
sub insn_alu_object(opcode: uint8)
    if insn.mode == MODE_DIR then
        insn_alu_abs(opcode);
    elseif insn.mode == MODE_IND then
        opcode := (opcode | 0x10) & 0xF3;
        insn_op_ind(opcode);
    elseif insn.mode == MODE_IMMLO then
        opcode := opcode & 0xfb;
        if insn.obj_id != 0 then
            insn_op_imm_adr(IOP_ADDRESSLO, opcode);
        else
            insn_op_imm(insn.offset as uint8, opcode);
        end if;
    elseif insn.mode == MODE_IMMHI then
        opcode := opcode & 0xfb;
        if insn.obj_id != 0 then
            insn_op_imm_adr(IOP_ADDRESSHI, opcode);
        else
            insn_op_imm((insn.offset >> 8) as uint8, opcode);
        end if;
    end if;
end sub;

# opcode must be the abs form of a column E opcode.
sub insn_mutate_object(opcode: uint8)
    insn_check_mutate();
    insn_op_abs(opcode);
end sub;

sub insn_save_object()
    if insn.mode == MODE_DIR then
        insn_st_abs();
    elseif insn.mode == MODE_IND then
        insn_st_ind();
    else
        print("cannot save ");
        print_insn();
        halt();
    end if;
end sub;

var t_opcodes: uint8[9] := {
    0x00, # TAA
    0x8A, # TXA
    0x98, # TYA
    0xAA, # TAX
    0x00, # TXX
    0x00, # TYX
    0xA8, # TAY
    0x00, # TXY
    0x00, # TYY
};

sub t_reg_reg(src: uint8, dest: uint8)
	$if DEBUG
		print("@ t?? src=0x");
		print_hex_i8(src);
		print(" dest=0x");
		print_hex_i8(dest);
		print_newline();
	$endif

    src := find_bit_index(src);
    dest := find_bit_index(dest);
    if (src|dest) == 0 then
        bad_register();
    end if;

    var opcode: uint8 := t_opcodes[src + dest*3];
    if opcode == 0 then
        print("bad move");
        halt();
    end if;
    write_byte(opcode);
end sub;
