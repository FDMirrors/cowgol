var current_token: uint16;
var peeked_token: uint16;
var filename_id: uint16 := 0;
var line_no: uint16 := 0;

sub emit_token(tokenid: uint16)
    current_token := peeked_token;
    peeked_token := tokenid;
end sub;

sub read_identifier()
    loop
        input_buffer[buffer_index] := current_byte;
        buffer_index := buffer_index + 1;

        var type: int8 := classify_char_type(peeked_byte);
        if (type != ALPHABETIC) & (type != DIGIT) then
            break;
        end if;
        next_byte();
    end loop;

    var string_id: uint16 := lookup_string();
    var token_id: uint16 := find_token_by_string(string_id);
    if token_id == 0 then
        var buf: IdentifierThing[1];
        buf[0].thing_type := THING_IDENTIFIER;
        buf[0].thing_size := IdentifierThing@bytes;
        buf[0].string_id := string_id;
        token_id := add_thing_by_value(&buf[0] as [Thing]);
    end if;
    emit_token(token_id);
end sub;

sub read_number()
    loop
        input_buffer[buffer_index] := current_byte;
        buffer_index := buffer_index + 1;

        var type: int8 := classify_char_type(peeked_byte);
        if (type != ALPHABETIC) & (type != DIGIT) then
            break;
        end if;
        next_byte();
    end loop;

    var base: uint8 := 10;
    var ptr: [int8] := &input_buffer[0];
    if (buffer_index >= 2) & (input_buffer[0] == '0') then
        if input_buffer[1] == 'x' then
            base := 16;
            ptr := &input_buffer[2];
        elseif input_buffer[1] == 'o' then
            base := 8;
            ptr := &input_buffer[2];
        elseif input_buffer[1] == 'b' then
            base := 2;
            ptr := &input_buffer[2];
        end if;
    end if;

    var value: int32 := string_to_number(ptr, base);
    var token_id: uint16 := add_number_by_value(value);
    emit_token(token_id);
end sub;

sub read_comment()
    while current_byte != 10 loop
        next_byte();
    end loop;
end sub;

sub read_symbol()
    if current_byte == '#' then
        read_comment();
        return;
    elseif current_byte == '-' then
        if classify_char_type(peeked_byte) == DIGIT then
            read_number();
            return;
        end if;
    end if;

    input_buffer[0] := current_byte;
    if peeked_byte == '=' then
        input_buffer[1] := peeked_byte;
        buffer_index := 2;
        next_byte();
    else
        buffer_index := 1;
    end if;

    var string_id: uint16 := lookup_string();
    var token_id: uint16 := find_token_by_string(string_id);
    if token_id == 0 then
        print("unrecognised symbol");
        error_with_location();
    end if;
    emit_token(token_id);
end sub;

sub decode_escaped_char()
    if current_byte == 'n' then
        current_byte := '\n';
    elseif current_byte == '0' then
        current_byte := 0;
    elseif (current_byte == '\\') | (current_byte == '"') | (current_byte == '\'') then
    else
        print("unrecognised string escape \\");
        print_char(current_byte);
        error_with_location();
    end if;
end sub;

sub read_string()
    next_byte();
    loop
        if current_byte == '"' then
            break;
        elseif current_byte == '\\' then
            next_byte();
            decode_escaped_char();
        end if;
        input_buffer[buffer_index] := current_byte;
        buffer_index := buffer_index + 1;
        next_byte();
    end loop;

    var string_id: uint16 := lookup_string();
    var buf: StringThing[1];
    buf[0].thing_type := THING_STRING;
    buf[0].thing_size := StringThing@bytes;
    buf[0].string_id := string_id;
    buf[0].string_size := buffer_index;
    var token_id: uint16 := add_thing_by_value(&buf[0] as [Thing]);
    emit_token(token_id);
end sub;

sub read_char_constant()
    next_byte();
    if current_byte == '\\' then
        next_byte();
        decode_escaped_char();
    end if;

    var buf: NumberThing[1];
    buf[0].thing_type := THING_NUMBER;
    buf[0].thing_size := NumberThing@bytes;
    buf[0].value := current_byte;

    var tokenid: uint16 := add_thing_by_value(&buf[0] as [Thing]);
    emit_token(tokenid);

    next_byte();
    if current_byte != '\'' then
        print("invalid character constant");
        error_with_location();
    end if;
end sub;

sub next_token()
    if current_byte == -1 then
        emit_token(0);
        return;
    end if;

    buffer_index := 0;
    var type: int8;
    loop
        type := classify_char_type(current_byte);
        if type == NEWLINE then
            line_number := line_number + 1;
            emit_token(TOKEN_TYPE_LINENO | line_number);
            next_byte();
            return;
        elseif type == WHITESPACE then
        else
            break;
        end if;
        next_byte();
    end loop;

    if current_byte == '"' then
        read_string();
    elseif current_byte == '\'' then
        read_char_constant();
    elseif (type == ALPHABETIC) | (current_byte == '@') then
        read_identifier();
    elseif type == SYMBOL then
        read_symbol();
    elseif type == DIGIT then
        read_number();
    else
        print("unknown char type ");
        print_i8(type);
        error_with_location();
    end if;
    next_byte();
end sub;

sub init_tokeniser()
    next_byte();
    next_byte();
    current_token := TOKEN_TYPE_LINENO;
    peeked_token := TOKEN_TYPE_LINENO;
end sub;

sub install_identifier(name: [int8], id: uint16, thingtype: uint8, token_flags: uint8)
    copy_string(name, &input_buffer[0]);
    buffer_index := string_length(&input_buffer[0]);

    var string_id: uint16 := lookup_string();
    var buf: TokenThing[1];
    buf[0].thing_type := thingtype;
    buf[0].string_id := string_id;
    if thingtype == THING_TOKEN then
        buf[0].thing_size := TokenThing@bytes;
        buf[0].token_flags := token_flags;
    else
        buf[0].thing_size := IdentifierThing@bytes;
    end if;
    var token_id: uint16 := add_thing_by_value(&buf[0] as [Thing]);

    if token_id != id then
        print("token id mismatch (internal error); wanted 0x");
        print_hex_i16(id);
        print(", got 0x");
        print_hex_i16(token_id);
        print_newline();
        exit(1);
    end if;
end sub;
