sub arch_gen_before(ea: [EffectiveAddress])
    if (ea.obj_id != 0) and (ea.flags == EA_DEREF) then
        print("* writing back precious values because of pointer access: ");
        print_ea(ea);
        print_newline();

        write_back_precious_values(REG_MASK);
    end if;
end sub;

sub arch_gen_after(ea: [EffectiveAddress])
    if (ea.obj_id != 0) and (ea.flags == EA_DEREF) then
        print("* flushing cached values because of pointer access: ");
        print_ea(ea);
        print_newline();

        flush_cached_values(REG_MASK);
    end if;
end sub;

sub arch_gen_beginning_of_instruction()
    locked_registers := 0;
end sub;

sub arch_gen_return()
    flush_cached_values(REG_MASK);
    write_byte(0x60); # RTS
end sub;

sub arch_gen_call(iop: [CallIop])
    flush_cached_values(REG_MASK);
    write_byte(0x20); # JSR
    write_address_iop(IOP_ADDRESS, iop.thing_id, 0);
end sub;

sub arch_gen_label(iop: [LabelIop])
    flush_cached_values(REG_MASK);
    write_iop(iop as [Iop]);
end sub;

sub arch_gen_goto(iop: [GotoIop])
    flush_cached_values(REG_MASK);
    write_cg_6502_conditional_iop(0x80, iop.label); # BRA (actually a 65C102 opcode)
end sub;
