include "cowgol.coh";
include "argv.coh";
include "file.coh";
include "strings.coh";

typedef string is [uint8];
typedef Token is uint8;

var inputFilename := 0 as string;
var outputFilename := "output.bin";
var listingFilename := 0 as string;

var inputFile: FCB;
var outputFile: FCB;
var listingFile: FCB;

var eol: uint8;
var lineno: uint16 := 0;
var tokenLength: uint8;
var tokenBuffer: uint8[64];
var tokenNumber: uint16;
var tokenSymbol: [Symbol];

var programCounter: uint16;
var programCounterSet: uint8;
var currentInsn: [Symbol];
var currentLabel: [Symbol];
var labelsChanged: uint8;
var pass: uint8;

const X_LINENO := 0;
const X_LINENO_END := X_LINENO + 5;
const X_PROGRAMCOUNTER := X_LINENO_END + 2;
const X_PROGRAMCOUNTER_END := X_PROGRAMCOUNTER + 4;
const X_BYTES := X_PROGRAMCOUNTER_END + 2;
const X_TEXT := X_BYTES + (8*3);
const X_END := 79;
var listingByteX: uint8;
var listingCharX: uint8;
var doListing: uint8 := 0;
var lastPass: uint8 := 0;

# 0000: 0000: 00 11 22 33 44 55 66 77 <text>
var listingBuffer: uint8[80];

var dbStringConstantHack: uint8 := 0;

const TOKEN_EOF        := 26;
const TOKEN_NL         := '\n';
const TOKEN_IDENTIFIER := 0xff;
const TOKEN_NUMBER     := 0xfe;
const TOKEN_STRING     := 0xfd;
const TOKEN_STRINGHACK := 0xfc;

const OP_ADD := 0;
const OP_AND := 1;
const OP_DIV := 2;
const OP_MOD := 3;
const OP_MUL := 4;
const OP_NEG := 5;
const OP_NOT := 6;
const OP_OR  := 7;
const OP_SHL := 8;
const OP_SHR := 9;
const OP_SUB := 10;
const OP_XOR := 11;
const OP_PAR := 12;

const AM_REG        := 0o000;
const AM_POSTINC    := 0o020;
const AM_PREDEC     := 0o040;
const AM_INDEX      := 0o060;
const AM__DEREF     := 0o010;
const AM__EXTENSION := 0o100;
const AM__RELATIVE  := 0o200;

var addressingMode: uint8;
var extensionWord: uint16;

interface SymbolCallback();

record Symbol is
	name: string;
	value: uint16;
	callback: SymbolCallback;
	next: [Symbol];
end record;

var symbolTable: [Symbol][32];
MemZero(&symbolTable[0] as [uint8], @bytesof symbolTable);

sub StartError() is
	if lineno != 0 then
		print("error at line ");
		print_i16(lineno);
		print(": ");
	else
		print("error: ");
	end if;
end sub;

sub EndError() is
	print_nl();
	ExitWithError();
end sub;

sub SimpleError(s: string) is
	StartError();
	print(s);
	EndError();
end sub;

sub ToUpper(cin: uint8): (cout: uint8) is
	if (cin >= 'a') and (cin <= 'z') then
		cout := cin - ('a' - 'A');
	else
		cout := cin;
	end if;
end sub;

sub UndefinedLabelCb implements SymbolCallback is
	SimpleError("unrecognised instruction");
end sub;

sub OperatorCb implements SymbolCallback is
	SimpleError("operators are not instructions");
end sub;

sub SetLabelCb implements SymbolCallback is
	SimpleError("values are not instructions");
end sub;

sub EquLabelCb implements SymbolCallback is
	SetLabelCb();
end sub;

sub Hex8(b: uint8, buffer: string) is
    var i := b >> 4;
    if i >= 10 then
        i := i + ('a' - '0' - 10);
    end if;
    [buffer] := i + '0';

    i := b & 0x0f;
    if i >= 10 then
        i := i + ('a' - '0' - 10);
    end if;
    [buffer+1] := i + '0';
end sub;

sub Hex16(w: uint16, buffer: string) is
    Hex8((w >> 8) as uint8, buffer);
    Hex8(w as uint8, buffer+2);
end sub;

sub Emit8(b: uint8) is
    if lastPass != 0 then
        FCBPutChar(&outputFile, b);

        if (doListing != 0) and (listingByteX != X_TEXT) then
            Hex8(b, &listingBuffer[listingByteX]);
            listingByteX := listingByteX + 3;
        end if;
    end if;

    programCounter := programCounter + 1;
end sub;

sub Emit16(w: uint16) is
    Emit8(w as uint8);
    Emit8((w>>8) as uint8);
end sub;

sub FindSymbol(name: string): (psymbol: [[Symbol]]) is
    var p := name;
    var hash: uint8 := 0;
    loop
        var c := [p];
        if c == 0 then
            break;
        end if;
        hash := hash + c;
        p := @next p;
    end loop;

	psymbol := &symbolTable[hash & 0x1f];
	loop
		var symbol := [psymbol];
		if symbol == (0 as [Symbol]) then
			break;
		end if;

		if StrCmp(symbol.name, name) == 0 then
			return;
		end if;
		psymbol := &symbol.next;
	end loop;
end sub;

sub HeapifyToken(): (sout: string) is
	sout := LOMEM;
	LOMEM := AlignUp((LOMEM as intptr) + (tokenLength as intptr) + 1) as [uint8];

	CopyString(&tokenBuffer[0], sout);
end sub;

sub AddSymbol(psymbol: [[Symbol]], name: string) is
	tokenSymbol := LOMEM as [Symbol];
	LOMEM := AlignUp((LOMEM as intptr) + @bytesof Symbol) as [uint8];

	tokenSymbol.value := 0;
	tokenSymbol.callback := UndefinedLabelCb;
	tokenSymbol.next := [psymbol];
	tokenSymbol.name := name;
	[psymbol] := tokenSymbol;
end sub;

var pushedtoken: Token := 0;
sub PushToken(token: Token) is
    pushedtoken := token;
end sub;

var pushedc: uint8 := 0;
sub ReadToken(): (token: Token) is
    if pushedtoken != 0 then
        token := pushedtoken;
        pushedtoken := 0;
        return;
    end if;

	sub GetC(): (c: uint8) is
		if pushedc == 0 then
			c := FCBGetChar(&inputFile);
		else
			c := pushedc;
			pushedc := 0;
		end if;
        if c == '\t' then
            c := ' ';
        end if;
        if (doListing != 0) and (listingCharX != X_END) and (c >= 32) then
            listingBuffer[listingCharX] := c;
            listingCharX := listingCharX + 1;
        end if;
	end sub;

	sub UngetC(c: uint8) is
		pushedc := c;
        if (doListing != 0) and (listingCharX != X_TEXT) and (c != '\n') then
            listingCharX := listingCharX - 1;
        end if;
	end sub;

	if eol != 0 then
		lineno := lineno + 1;
		eol := 0;
	end if;

	var c: uint8;
	loop
		c := GetC();
		if (c != ' ') and (c != '\r') then
			break;
		end if;
	end loop;

	if c == ';' then
		loop
			c := GetC();
			if (c == '!') or (c == '\n') or (c == 26) then
				break;
			end if;
		end loop;
	end if;

	sub CheckTokenBufferSize() is
		if tokenLength == @sizeof tokenBuffer then
			SimpleError("token too long");
		end if;
	end sub;

	sub AccumulateTokenByte() is
		CheckTokenBufferSize();
		tokenBuffer[tokenLength] := c;
		tokenLength := tokenLength + 1;

		loop
			c := ToUpper(GetC());
			if c != '$' then
				break;
			end if;
		end loop;
	end sub;

	c := ToUpper(c);
	tokenLength := 0;
	if (c >= '0') and (c <= '9') then
		loop
			AccumulateTokenByte();

			if not (((c >= 'A') and (c <= 'Z')) or ((c >= '0') and (c <= '9'))) then
				break;
			end if;
		end loop;
		UngetC(c);

		var base: uint8;
		tokenLength := tokenLength - 1;
		c := tokenBuffer[tokenLength];
		case c is
			when 'B': base := 2;
			when 'O': base := 8;
			when 'Q': base := 8;
			when 'D': base := 10;
			when 'H': base := 16;
			when else:
				if (c >= '0') and (c <= '9') then
					tokenLength := tokenLength + 1;
					base := 10;
				else
					tokenBuffer[tokenLength+1] := 0;
					print(&tokenBuffer[0]);
					print_nl();
					StartError();
					print("invalid base '");
					print_char(c);
					print("'");
					EndError();
				end if;
		end case;
		tokenBuffer[tokenLength] := 0;

		tokenNumber := 0;
		var p := &tokenBuffer[0];
		loop
			c := [p];
			p := p + 1;
			if c == 0 then
				break;
			end if;

			if c >= 'A' then
				c := c - ('A' + 10);
			else
				c := c - '0';
			end if;
			if c >= base then
				SimpleError("invalid number");
			end if;
			tokenNumber := tokenNumber*(base as uint16) + (c as uint16);
		end loop;
		token := TOKEN_NUMBER;
	elseif (c >= 'A') and (c <= 'Z') then
		loop
			AccumulateTokenByte();

			if not (((c >= 'A') and (c <= 'Z')) or ((c >= '0') and (c <= '9')) or (c == '_')) then
				break;
			end if;
		end loop;
		UngetC(c);

		tokenBuffer[tokenLength] := 0;

		var psymbol := FindSymbol(&tokenBuffer[0]);
		if [psymbol] == (0 as [Symbol]) then
			AddSymbol(psymbol, HeapifyToken());
		else
			tokenSymbol := [psymbol];
		end if;
		token := TOKEN_IDENTIFIER;
	elseif (c == '\'') then
		c := GetC();
		loop
			AccumulateTokenByte();
			if c < 32 then
				SimpleError("unterminated string constant");
			end if;
			if c == '\'' then
				break;
			end if;
		end loop;
		tokenBuffer[tokenLength] := 0;
		token := TOKEN_STRING;
	elseif (c == '\n') then
		eol := 1;
        token := TOKEN_NL;
	elseif (c == '!') then
		token := TOKEN_NL;
	elseif (c == 0) then
		token := TOKEN_EOF;
	else
		# Everything else is a single-character token.
		token := c;
	end if;
end sub;

sub IsLabel(): (result: uint8) is
    if (tokenSymbol.callback == UndefinedLabelCb)
        or (tokenSymbol.callback == EquLabelCb)
        or (tokenSymbol.callback == SetLabelCb)
    then
        result := 1;
    else
        result := 0;
    end if;
end sub;

sub SyntaxError() is
    SimpleError("syntax error");
end sub;

sub Expect(token: Token) is
    if ReadToken() != token then
        SyntaxError();
    end if;
end sub;

sub UnbalancedParentheses() is
    SimpleError("unbalanced parentheses");
end sub;

sub ReadExpression(): (token: Token) is
    interface OperatorCallback(left: uint16, right: uint16): (result: uint16);

    record Operator is
        callback: OperatorCallback;
        precedence: uint8;
        binary: uint8;
    end record;

    sub AddCb implements OperatorCallback is result := left + right; end sub;
    sub AndCb implements OperatorCallback is result := left & right; end sub;
    sub DivCb implements OperatorCallback is result := left / right; end sub;
    sub ModCb implements OperatorCallback is result := left % right; end sub;
    sub MulCb implements OperatorCallback is result := left * right; end sub;
    sub NegCb implements OperatorCallback is result := -left;        end sub;
    sub NotCb implements OperatorCallback is result := ~left;        end sub;
    sub OrCb  implements OperatorCallback is result := left | right; end sub;
    sub ShlCb implements OperatorCallback is result := left << (right as uint8); end sub;
    sub ShrCb implements OperatorCallback is result := left >> (right as uint8); end sub;
    sub SubCb implements OperatorCallback is result := left - right; end sub;
    sub XorCb implements OperatorCallback is result := left ^ right; end sub;
        
    var operatorTable: Operator[] := {
        { AddCb, 2, 1 },
        { AndCb, 4, 1 },
        { DivCb, 1, 1 },
        { ModCb, 1, 1 },
        { MulCb, 1, 1 },
        { NegCb, 0, 0 },
        { NotCb, 3, 0 },
        { OrCb,  5, 1 },
        { ShlCb, 1, 1 },
        { ShrCb, 1, 1 },
        { SubCb, 2, 1 },
        { XorCb, 2, 1 },
        { NotCb, 0xff, 0 }, # actually parenthesis
    };

    const STACK_DEPTH := 32;
    var values: uint16[STACK_DEPTH];
    var operators: [Operator][STACK_DEPTH];
    var valueSp: @indexof values := 0;
    var operatorSp: @indexof operators := 0;
    var seenValue: uint8 := 0;

    sub PushValue(value: uint16) is
        if valueSp == STACK_DEPTH then
            SimpleError("expression stack overflow");
        end if;
        values[valueSp] := value;
        valueSp := valueSp + 1;
    end sub;

    sub PopValue(): (value: uint16) is
        if valueSp == 0 then
            SimpleError("expression stack underflow");
        end if;
        valueSp := valueSp - 1;
        value := values[valueSp];
    end sub;

    sub ApplyOperator(op: [Operator]) is
        var cb := op.callback;

        var rhs := PopValue();
        if op.binary != 0 then
            var lhs := PopValue();
            PushValue(cb(lhs, rhs));
        else
            PushValue(cb(rhs, 0));
        end if;
    end sub;

    sub PushOperator(opid: uint8) is
        if operatorSp == STACK_DEPTH then
            SimpleError("operator stack overflow");
        end if;
        operators[operatorSp] := &operatorTable[opid as @indexof operatorTable];
        operatorSp := operatorSp + 1;
    end sub;

    sub PushAndApplyOperator(opid: uint8) is
        var op := &operatorTable[opid as @indexof operatorTable];
        while operatorSp != 0 loop
            var topop := operators[operatorSp-1];
            if topop.precedence <= op.precedence then
                ApplyOperator(topop);
                operatorSp := operatorSp - 1;
            else
                break;
            end if;
        end loop;

        PushOperator(opid);
    end sub;

    sub WantOperator() is
        if seenValue == 0 then
            SimpleError("expected operator, got value");
        end if;
    end sub;

    sub WantValue() is
        if seenValue != 0 then
            SimpleError("expected value, got operator");
        end if;
    end sub;

    var op: [Operator];
    sub ReadAndStack() is
        loop
            token := ReadToken();
            case token is
                when '$':
                    WantValue();
                    PushValue(programCounter);
                    seenValue := 1;
                
                when TOKEN_NUMBER:
                    WantValue();
                    PushValue(tokenNumber);
                    seenValue := 1;

                when TOKEN_STRING:
                    WantValue();

                    if (dbStringConstantHack != 0) and (valueSp == 0) and (operatorSp == 0) then
                        token := TOKEN_STRINGHACK;
                        return;
                    end if;

                    var v: uint16 := tokenBuffer[0] as uint16;
                    if tokenLength == 2 then
                        v := (v<<8) | (tokenBuffer[1] as uint16);
                    end if;
                    if (tokenLength != 1) and (tokenLength != 2) then
                        SimpleError("invalid character constant");
                    end if;

                    PushValue(v);
                    seenValue := 1;

                when '+':
                    if seenValue != 0 then
                        PushAndApplyOperator(OP_ADD);
                    end if;
                    seenValue := 0;

                when '-':
                    if seenValue != 0 then
                        PushAndApplyOperator(OP_SUB);
                    else
                        PushAndApplyOperator(OP_NEG);
                    end if;
                    seenValue := 0;

                when '*':
                    WantOperator();
                    PushAndApplyOperator(OP_MUL);
                    seenValue := 0;

                when '/':
                    WantOperator();
                    PushAndApplyOperator(OP_DIV);
                    seenValue := 0;

                when '(':
                    if seenValue != 0 then
                        return;
                    end if;
                    PushOperator(OP_PAR);
                    seenValue := 0;

                when ')':
                    WantOperator();

                    loop
                        if operatorSp == 0 then
                            UnbalancedParentheses();
                        end if;
                        operatorSp := operatorSp - 1;
                        op := operators[operatorSp];
                        if op == &operatorTable[OP_PAR] then
                            break;
                        end if;
                        ApplyOperator(op);
                    end loop;

                when TOKEN_IDENTIFIER:
                    if tokenSymbol.callback == OperatorCb then
                        op := &operatorTable[tokenSymbol.value as uint8];
                        if op.binary != seenValue then
                            SyntaxError();
                        end if;
                        PushAndApplyOperator(tokenSymbol.value as uint8);
                        seenValue := 0;
                    elseif IsLabel() != 0 then
                        WantValue();
                        PushValue(tokenSymbol.value);
                        seenValue := 1;
                    else
                        StartError();
                        print_char('\'');
                        print(&tokenBuffer[0]);
                        print("' is not a value");
                        EndError();
                    end if;

                when else:
                    return;
            end case;
        end loop;
    end sub;
    ReadAndStack();

    while operatorSp != 0 loop
        operatorSp := operatorSp - 1;
        op := operators[operatorSp];
        ApplyOperator(op);
    end loop;

    if valueSp != 1 then
        SimpleError("missing expression");
    end if;
    tokenNumber := values[0];
end sub;

sub ExpectExpression() is
    if ReadExpression() != TOKEN_NL then
        SimpleError("expected a single expression");
    end if;
end sub;

sub RegCb implements SymbolCallback is
    SimpleError("registers are not instructions");
end sub;

sub ExpectRegister() is
    var token := ReadToken();
    if (token != TOKEN_IDENTIFIER) or (tokenSymbol.callback != RegCb) then
        SimpleError("expected a register");
    end if;
end sub;

sub ReadOperand(): (token: Token) is
    var deferred: uint8 := 0;
    token := ReadToken();
    if token == '@' then
        deferred := 1;
        token := ReadToken();
    end if;

    var reg: uint8;
    var value: uint16;
    case token is
        when '-':
            Expect('(');
            ExpectRegister();
            addressingMode := AM_PREDEC | (tokenSymbol.value as uint8);
            Expect(')');
            token := ReadToken();

        when '#':
            token := ReadExpression();
            extensionWord := tokenNumber;
            addressingMode := AM__EXTENSION | AM_POSTINC | 7;

        when '(':
            token := ReadToken();
            if (token == TOKEN_IDENTIFIER) and (tokenSymbol.callback == RegCb) then
                reg := tokenSymbol.value as uint8;
                Expect(')');
                token := ReadToken();
                if token == '+' then
                    addressingMode := AM_POSTINC | reg;
                    token := ReadToken();
                else
                    addressingMode := AM__DEREF | AM_REG | reg;
                end if;
            else
                PushToken(token);
                token := ReadExpression();
                value := tokenNumber;
                if token == '(' then
                    ExpectRegister();
                    addressingMode := AM_INDEX | (tokenSymbol.value as uint8);

                    Expect(')');
                    token := ReadToken();
                else
                    addressingMode := AM__RELATIVE | AM__EXTENSION | AM_INDEX | 7;
                    extensionWord := value;
                end if;
            end if;

        when else:
            if (token == TOKEN_IDENTIFIER) and (tokenSymbol.callback == RegCb) then
                addressingMode := AM_REG | (tokenSymbol.value as uint8);
                token := ReadToken();
            else
                PushToken(token);
                token := ReadExpression();
                value := tokenNumber;
                if token == '(' then
                    ExpectRegister();
                    addressingMode := AM__EXTENSION | AM_INDEX | (tokenSymbol.value as uint8);
                    extensionWord := value;
                    Expect(')');
                    token := ReadToken();
                else
                    addressingMode := AM__RELATIVE | AM__EXTENSION | AM_INDEX | 7;
                    extensionWord := value;
                end if;
            end if;
    end case;

    if deferred != 0 then
        addressingMode := addressingMode | AM__DEREF;
    end if;
end sub;

sub ExpectOperand() is
    if ReadOperand() != TOKEN_NL then
        SimpleError("expected a single operand");
    end if;
end sub;
        
sub BadSeparator() is
    SimpleError("bad separator");
end sub;

sub SetImplicitLabel() is
    if currentLabel == 0 as [Symbol] then
        return;
    end if;

    if (pass == 1)
        and (currentLabel.value != programCounter)
        and (currentLabel.callback != UndefinedLabelCb)
    then
        StartError();
        print("label already defined (");
        print_hex_i16(currentLabel.value);
        print("h vs ");
        print_hex_i16(programCounter);
        print("h)");
        EndError();
    elseif currentLabel.value != programCounter then
        labelsChanged := 1;
    end if;

    currentLabel.value := programCounter;
    currentLabel.callback := EquLabelCb;
end sub;
    
sub TitleCb implements SymbolCallback is
    Expect(TOKEN_STRING);
    if pass == 1 then
        print("Title: ");
        print(&tokenBuffer[0]);
        print_nl();
    end if;
    Expect(TOKEN_NL);
end sub;

sub EquCb implements SymbolCallback is
    if currentLabel == (0 as [Symbol]) then
        SimpleError("equ with no label");
    end if;

    ExpectExpression();
    if (pass == 1)
        and (currentLabel.value != tokenNumber)
        and (currentLabel.callback != UndefinedLabelCb)
    then
        SimpleError("label already defined");
    elseif currentLabel.value != tokenNumber then
        labelsChanged := 1;
    end if;

    currentLabel.value := tokenNumber;
    currentLabel.callback := EquLabelCb;
end sub;

sub SetCb implements SymbolCallback is
    if currentLabel == (0 as [Symbol]) then
        SimpleError("set with no label");
    end if;

    ExpectExpression();
    if currentLabel.callback == EquLabelCb then
        SimpleError("label already defined");
    end if;

    currentLabel.value := tokenNumber;
    currentLabel.callback := SetLabelCb;
end sub;

sub EndIfCb implements SymbolCallback is
    Expect(TOKEN_NL);
end sub;

sub ElseCb implements SymbolCallback is
    # If this pseudoop actually gets executed, then we've been executing the
    # true branch of the if...endif. Skip to the end.
    loop
        var t := ReadToken();
        if t == TOKEN_EOF then
            SimpleError("unexpected end of file");
        elseif t == TOKEN_IDENTIFIER then
            if tokenSymbol.callback == EndIfCb then
                break;
            end if;
        end if;
    end loop;
    Expect(TOKEN_NL);
end sub;

sub IfCb implements SymbolCallback is
    ExpectExpression();
    if tokenNumber != 0 then
        # do nothing --- true case
    else
        pass := pass + 10; # Suppress listing file
        loop
            var t := ReadToken();
            if t == TOKEN_EOF then
                SimpleError("unexpected end of file");
            elseif t == TOKEN_IDENTIFIER then
                if (tokenSymbol.callback == EndIfCb) or (tokenSymbol.callback == ElseCb) then
                    break;
                end if;
            end if;
        end loop;
        Expect(TOKEN_NL);
        pass := pass - 10; # Enable listing file again
   end if;
end sub;

sub EndCb implements SymbolCallback is
end sub;

sub DbCb implements SymbolCallback is
    dbStringConstantHack := 1;
    loop
        var t := ReadExpression();
        case t is
            when TOKEN_STRINGHACK:
                var p := &tokenBuffer[0];
                while [p] != 0 loop
                    Emit8([p]);
                    p := p + 1;
                end loop;
                t := ReadToken();

            when else:
                Emit8(tokenNumber as uint8);
        end case;
        if t != ',' then
            break;
        end if;
    end loop;
    if t != TOKEN_NL then
        BadSeparator();
    end if;
    dbStringConstantHack := 0;
end sub;

sub DsCb implements SymbolCallback is
    ExpectExpression();
    while tokenNumber != 0 loop
        Emit8(0);
        tokenNumber := tokenNumber - 1;
    end loop;
end sub;

sub DwCb implements SymbolCallback is
    loop
        var t := ReadExpression();
        Emit16(tokenNumber);
        if t != ',' then
            break;
        end if;
    end loop;
    if t != TOKEN_NL then
        BadSeparator();
    end if;
end sub;

sub OrgCb implements SymbolCallback is
    ExpectExpression();
    programCounter := tokenNumber;
end sub;

sub AlignCb implements SymbolCallback is
    ExpectExpression();
    if (tokenNumber & (tokenNumber-1)) != 0 then
        SimpleError("alignment must be a power of two");
    end if;

    var newpc := (programCounter + tokenNumber) & ~(tokenNumber - 1);
    while programCounter != newpc loop
        Emit8(0);
    end loop;
end sub;

sub EmitExtension(addressingMode: uint8, extensionWord: uint16) is
    if (addressingMode & AM__EXTENSION) == 0 then
        return;
    end if;
    if (addressingMode & AM__RELATIVE) != 0 then
        extensionWord := extensionWord - programCounter - 2;
    end if;
    Emit16(extensionWord);
end sub;

sub Op1Cb implements SymbolCallback is
    ExpectOperand();

    Emit16(currentInsn.value
        | (addressingMode & 0o77) as uint16);

    EmitExtension(addressingMode, extensionWord);
end sub;

sub Op2Cb implements SymbolCallback is
    if ReadOperand() != ',' then
        BadSeparator();
    end if;
    var param1addressingMode := addressingMode;
    var param1extensionWord := extensionWord;
    ExpectOperand();

    Emit16(currentInsn.value
        | ((param1addressingMode & 0o77) as uint16 << 6)
        | (addressingMode & 0o77) as uint16);

    EmitExtension(param1addressingMode, param1extensionWord);
    EmitExtension(addressingMode, extensionWord);
end sub;

sub JsrCb implements SymbolCallback is
    if ReadOperand() != ',' then
        BadSeparator();
    end if;
    if (addressingMode & 0o370) != AM_REG then
        SimpleError("first parameter must be a register");
    end if;
    var param1addressingMode := addressingMode;
    ExpectOperand();

    Emit16(currentInsn.value
        | ((param1addressingMode & 0o07) as uint16 << 6)
        | (addressingMode & 0o77) as uint16);
    EmitExtension(addressingMode, extensionWord);
end sub;

sub CallCb implements SymbolCallback is
    ExpectOperand();

    Emit16(currentInsn.value
        | (addressingMode & 0o77) as uint16);
    EmitExtension(addressingMode, extensionWord);
end sub;

sub RtsCb implements SymbolCallback is
    ExpectOperand();
    if (addressingMode & 0o370) != AM_REG then
        SimpleError("first parameter must be a register");
    end if;

    Emit16(currentInsn.value
        | (addressingMode & 0o77) as uint16);
end sub;

sub CondCb implements SymbolCallback is
    ExpectExpression();
    
    if pass == 1 then
        programCounter := programCounter + 6;
    else
        var delta := (tokenNumber - programCounter - 2) as int16 >> 1;
        if (delta >= -128) and (delta <= 127) then
            Emit16(currentInsn.value | (delta as uint16 & 0xff));
        else
            Emit16((currentInsn.value ^ 0o400) | 2);
            Emit16(0o000167);
            Emit16(tokenNumber - programCounter - 2);
        end if;
    end if;
end sub;

sub BrCb implements SymbolCallback is
    ExpectExpression();
    
    if pass == 1 then
        programCounter := programCounter + 4;
    else
        var delta := (tokenNumber - programCounter - 2) as int16 >> 1;
        if (delta >= -128) and (delta <= 127) then
            Emit16(currentInsn.value | (delta as uint16 & 0xff));
        else
            Emit16(0o000167);
            Emit16(tokenNumber - programCounter - 2);
        end if;
    end if;
end sub;

sub Op2RegCb implements SymbolCallback is
    if ReadOperand() != ',' then
        BadSeparator();
    end if;
    if (addressingMode & 0o370) != AM_REG then
        SimpleError("second parameter must be a register");
    end if;
    var param1addressingMode := addressingMode;
    ExpectOperand();

    Emit16(currentInsn.value
        | (addressingMode & 0o77) as uint16
        | ((param1addressingMode & 0o07) as uint16 << 6));

    EmitExtension(addressingMode, extensionWord);
end sub;

# Reversed operands in the instruction encoding: the source is in
# what's normally the destination field, and vice versa.
sub Op2RegRCb implements SymbolCallback is
    if ReadOperand() != ',' then
        BadSeparator();
    end if;
    var param1addressingMode := addressingMode;
    var param2extensionWord := extensionWord;
    ExpectOperand();
    if (addressingMode & 0o370) != AM_REG then
        SimpleError("second parameter must be a register");
    end if;

    Emit16(currentInsn.value
        | (param1addressingMode & 0o77) as uint16
        | ((addressingMode & 0o07) as uint16 << 6));

    EmitExtension(param1addressingMode, param2extensionWord);
end sub;

sub SobCb implements SymbolCallback is
    if ReadOperand() != ',' then
        BadSeparator();
    end if;
    if (addressingMode & 0o370) != AM_REG then
        SimpleError("first parameter must be a register");
    end if;
    var param1addressingMode := addressingMode;
    ExpectExpression();
    
    if pass == 1 then
        programCounter := programCounter + 8;
    else
        var delta := (tokenNumber - programCounter - 2) as int16;
        if (delta >= -256) and (delta <= 0) then
            Emit16(currentInsn.value | (((-delta as uint16) >> 1) & 0o77));
        elseif (delta >= -128) and (delta <= 126) then
            Emit16(0o000401);
            Emit16(0o000400 | (((delta as uint16) >> 1) & 0o77));
            Emit16((currentInsn.value ^ 0o400) | 2);
        else
            Emit16(0o000402);
            Emit16(0o000167);
            Emit16(tokenNumber - programCounter - 2);
            Emit16((currentInsn.value ^ 0o400) | 3);
        end if;
    end if;
end sub;

sub EmtTrapCb implements SymbolCallback is
    ExpectExpression();
    if tokenNumber > 0o77 then
        SimpleError("EMT/TRAP value out of range");
    end if;

    Emit16(currentInsn.value | tokenNumber);
end sub;

sub JmpCb implements SymbolCallback is
    ExpectOperand();
    Emit16(currentInsn.value | (addressingMode & 0o77) as uint16);
    EmitExtension(addressingMode, extensionWord);
end sub;

sub MarkCb implements SymbolCallback is
    ExpectExpression();
    if tokenNumber > 0o77 then
        SimpleError("MARK value out of range");
    end if;

    Emit16(currentInsn.value | tokenNumber);
end sub;

sub SplCb implements SymbolCallback is
    ExpectExpression();
    if tokenNumber > 0o7 then
        SimpleError("SPL value out of range");
    end if;

    Emit16(currentInsn.value | tokenNumber);
end sub;

sub SimpleCb implements SymbolCallback is
    Emit16(currentInsn.value);
end sub;

sub InitialiseSymbolTable() is
	var s: Symbol;
	var symbols: Symbol[] := {
        { "R0",    0,        RegCb,      &s },
        { "R1",    1,        RegCb,      &s },
        { "R2",    2,        RegCb,      &s },
        { "R3",    3,        RegCb,      &s },
        { "R4",    4,        RegCb,      &s },
        { "R5",    5,        RegCb,      &s },
        { "R6",    6,        RegCb,      &s },
        { "R7",    7,        RegCb,      &s },
        { "SP",    6,        RegCb,      &s },
        { "PC",    7,        RegCb,      &s },

        { "MOV",   0o010000, Op2Cb,      &s },
        { "MOVB",  0o110000, Op2Cb,      &s },
        { "CMP",   0o020000, Op2Cb,      &s },
        { "CMPB",  0o120000, Op2Cb,      &s },
        { "BIT",   0o030000, Op2Cb,      &s },
        { "BITB",  0o130000, Op2Cb,      &s },
        { "BIC",   0o040000, Op2Cb,      &s },
        { "BICB",  0o140000, Op2Cb,      &s },
        { "BIS",   0o050000, Op2Cb,      &s },
        { "BISB",  0o150000, Op2Cb,      &s },
        { "ADD",   0o060000, Op2Cb,      &s },
        { "SUB",   0o160000, Op2Cb,      &s },

        { "SWAB",  0o000300, Op1Cb,      &s },
        { "CLR",   0o005000, Op1Cb,      &s },
        { "CLRB",  0o105000, Op1Cb,      &s },
        { "COM",   0o005100, Op1Cb,      &s },
        { "COMB",  0o105100, Op1Cb,      &s },
        { "INC",   0o005200, Op1Cb,      &s },
        { "INCB",  0o105200, Op1Cb,      &s },
        { "DEC",   0o005300, Op1Cb,      &s },
        { "DECB",  0o105300, Op1Cb,      &s },
        { "NEG",   0o005400, Op1Cb,      &s },
        { "NEGB",  0o105400, Op1Cb,      &s },
        { "ADC",   0o005500, Op1Cb,      &s },
        { "ADCB",  0o105500, Op1Cb,      &s },
        { "SBC",   0o005600, Op1Cb,      &s },
        { "SBCB",  0o105600, Op1Cb,      &s },
        { "TST",   0o005700, Op1Cb,      &s },
        { "TSTB",  0o105700, Op1Cb,      &s },
        { "ROR",   0o006000, Op1Cb,      &s },
        { "RORB",  0o106000, Op1Cb,      &s },
        { "ROL",   0o006100, Op1Cb,      &s },
        { "ROLB",  0o106100, Op1Cb,      &s },
        { "ASR",   0o006200, Op1Cb,      &s },
        { "ASRB",  0o106200, Op1Cb,      &s },
        { "ASL",   0o006300, Op1Cb,      &s },
        { "ASLB",  0o106300, Op1Cb,      &s },
        { "MTPS",  0o106400, Op1Cb,      &s },
        { "MFPI",  0o006500, Op1Cb,      &s },
        { "MFPD",  0o106500, Op1Cb,      &s },
        { "MTPI",  0o006600, Op1Cb,      &s },
        { "MTPD",  0o106600, Op1Cb,      &s },
        { "SXT",   0o006700, Op1Cb,      &s },
        { "MFPS",  0o106700, Op1Cb,      &s },
        { "CSM",   0o007000, Op1Cb,      &s },

        { "JSR",   0o004000, JsrCb,      &s },
        { "CALL",  0o004700, CallCb,     &s },
        { "RTS",   0o000200, RtsCb,      &s },
        { "RET",   0o000207, SimpleCb,   &s },
        { "HALT",  0o000000, SimpleCb,   &s },
        { "WAIT",  0o000001, SimpleCb,   &s },
        { "RTI",   0o000002, SimpleCb,   &s },
        { "BPT",   0o000003, SimpleCb,   &s },
        { "IOT",   0o000004, SimpleCb,   &s },
        { "RESET", 0o000005, SimpleCb,   &s },
        { "RTT",   0o000006, SimpleCb,   &s },
        { "EMT",   0o104000, EmtTrapCb,  &s },
        { "TRAP",  0o104400, EmtTrapCb,  &s },
        { "LDUB",  0o170003, SimpleCb,   &s },
        { "MED",   0o076600, SimpleCb,   &s },
        { "SPL",   0o000230, SplCb,      &s },

        { "SCC",   0o000277, SimpleCb,   &s },
        { "SEC",   0o000261, SimpleCb,   &s },
        { "SEV",   0o000262, SimpleCb,   &s },
        { "SEZ",   0o000264, SimpleCb,   &s },
        { "SEN",   0o000270, SimpleCb,   &s },

        { "CCC",   0o000257, SimpleCb,   &s },
        { "CLC",   0o000241, SimpleCb,   &s },
        { "CLV",   0o000242, SimpleCb,   &s },
        { "CLZ",   0o000244, SimpleCb,   &s },
        { "CLN",   0o000250, SimpleCb,   &s },

        { "BR",    0o000400, BrCb,       &s },
        { "BNE",   0o001000, CondCb,     &s },
        { "BEQ",   0o001400, CondCb,     &s },
        { "BGE",   0o002000, CondCb,     &s },
        { "BLT",   0o002400, CondCb,     &s },
        { "BGT",   0o003000, CondCb,     &s },
        { "BLE",   0o003400, CondCb,     &s },
        { "BPL",   0o100000, CondCb,     &s },
        { "BMI",   0o100400, CondCb,     &s },
        { "BHI",   0o101000, CondCb,     &s },
        { "BLOS",  0o101400, CondCb,     &s },
        { "BVC",   0o102000, CondCb,     &s },
        { "BVS",   0o102400, CondCb,     &s },
        { "BCC",   0o103000, CondCb,     &s },
        { "BCS",   0o103400, CondCb,     &s },
        { "BHIS",  0o103000, CondCb,     &s },
        { "BLO",   0o103400, CondCb,     &s },

        { "MUL",   0o070000, Op2RegRCb,  &s },
        { "DIV",   0o071000, Op2RegRCb,  &s },
        { "ASH",   0o072000, Op2RegRCb,  &s },
        { "ASHC",  0o073000, Op2RegRCb,  &s },
        { "XOR",   0o074000, Op2RegCb,   &s },
        { "SOB",   0o077000, SobCb,      &s },
        { "JMP",   0o000100, JmpCb,      &s },
        { "MARK",  0o006400, MarkCb,     &s },

		{ "ORG",   0,        OrgCb,      &s },
		{ "DB",    0,        DbCb,       &s },
		{ "DS",    0,        DsCb,       &s },
		{ "DW",    0,        DwCb,       &s },
		{ "EQU",   0,        EquCb,      &s },
		{ "ELSE",  0,        ElseCb,     &s },
		{ "ENDIF", 0,        EndIfCb,    &s },
		{ "END",   0,        EndCb,      &s },
		{ "IF",    0,        IfCb,       &s },
		{ "SET",   0,        SetCb,      &s },
		{ "TITLE", 0,        TitleCb,    &s },
        { "ALIGN", 0,        AlignCb,    &s },

		{ "AND",   OP_AND,   OperatorCb, &s },
		{ "MOD",   OP_MOD,   OperatorCb, &s },
		{ "NOT",   OP_NOT,   OperatorCb, &s },
		{ "OR",    OP_OR,    OperatorCb, &s },
		{ "SHL",   OP_SHL,   OperatorCb, &s },
		{ "SHR",   OP_SHR,   OperatorCb, &s },
		{ "EOR",   OP_XOR,   OperatorCb, &s },
	};

	var p := &symbols[0];
    while p != &symbols[@sizeof symbols] loop
		var psymbol := FindSymbol(p.name);
		if [psymbol] != (0 as [Symbol]) then
			StartError();
			print("duplicate symbol during init ");
			print(p.name);
			EndError();
		end if;
		p.next := (0 as [Symbol]);
		[psymbol] := p;

		p := @next p;
	end loop;
end sub;

sub Pass() is
    eol := 1;
    lineno := 0;
    programCounter := 0;
    programCounterSet := 0;
    labelsChanged := 0;
    
    if (listingFilename != 0 as string) and (lastPass != 0) then
        doListing := 1;
    end if;

    print("Pass ");
    print_i8(pass);
    print_nl();
 
    # Each statement consists of:
    # LABEL [:] INSTRUCTION [operands...]
    #
    # foo: mvi a, 1
    # foo mvi a, 1
    # mvi a, 1
    # foo
    #
    # ...are all valid.

    loop
        if (listingFilename != 0 as string) and (lastPass != 0) then
            listingByteX := X_BYTES;
            listingCharX := X_TEXT;

            MemSet(&listingBuffer[0], ' ', X_TEXT);
            listingBuffer[X_TEXT] := 0;
            var p := UIToA(lineno as uint32, 10, &listingBuffer[X_LINENO]);
            [p] := ':';
            Hex16(programCounter, &listingBuffer[X_PROGRAMCOUNTER]);
            listingBuffer[X_PROGRAMCOUNTER_END] := ':';
        end if;

        var t := ReadToken();
        if t == TOKEN_EOF then
            return;
        end if;
        if t == TOKEN_NL then
            continue;
        end if;
        if t != TOKEN_IDENTIFIER then
            SimpleError("expected an identifier");
        end if;
        if tokenSymbol.callback == EndCb then
            return;
        end if;

        currentLabel := 0 as [Symbol];
        currentInsn := 0 as [Symbol];

        if IsLabel() != 0 then
            currentLabel := tokenSymbol;
            t := ReadToken();
            if t == ':' then
                t := ReadToken();
            end if;
        end if;

        if t != TOKEN_NL then
            if t != TOKEN_IDENTIFIER then
                SimpleError("expected an identifier");
            end if;
            currentInsn := tokenSymbol;
        end if;

        if currentInsn != 0 as [Symbol] then
            var cb := currentInsn.callback;
            if (cb != SetCb) and (cb != EquCb) then
                SetImplicitLabel();
            end if;
            cb();
        else
            SetImplicitLabel();
        end if;

        if doListing != 0 then
            listingBuffer[listingCharX] := 0;
            FCBPutString(&listingFile, &listingBuffer[0]);
            FCBPutChar(&listingFile, 10);
        end if;
    end loop;
end sub;

sub CheckForUndefinedSymbols() is
    lineno := 0;
    var error: uint8 := 0;
    var psymbol := &symbolTable[0];
    while psymbol != &symbolTable[@sizeof symbolTable] loop
        var symbol := [psymbol];
        while symbol != (0 as [Symbol]) loop
            if symbol.callback == UndefinedLabelCb then
                print("undefined symbol: ");
                print(symbol.name);
                print_nl();
                error := 1;
            end if;
            symbol := symbol.next;
        end loop;
        psymbol := @next psymbol;
    end loop;

    if error != 0 then
        SimpleError("undefined symbols");
    end if;
end sub;

sub ParseArguments() is
	sub SyntaxError() is
		StartError();
		print("syntax: cowasm <inputfilename> [-o <outputfilename>] [-l <listingfilename>\n");
		EndError();
	end sub;

	ArgvInit();
	loop
		var s := ArgvNext();
		if s == (0 as string) then
			break;
		end if;

		if [s] == '-' then
			case ToUpper([s+1]) is
				when 'O':
					outputFilename := ArgvNext();

				when 'L':
					listingFilename := ArgvNext();

				when else:
					SyntaxError();
			end case;
		else
			if inputFilename != (0 as string) then
				SyntaxError();
			end if;
			inputFilename := s;
		end if;
	end loop;

	if (inputFilename == (0 as string)) or (outputFilename == (0 as string)) then
		SyntaxError();
	end if;

	sub CheckFCBOpen(e: uint8, s: string) is
		if e != 0 then
			StartError();
			print("cannot open ");
			print(s);
			EndError();
		end if;
	end sub;

	CheckFCBOpen(FCBOpenIn(&inputFile, inputFilename), inputFilename);
	CheckFCBOpen(FCBOpenOut(&outputFile, outputFilename), outputFilename);
	if listingFilename != (0 as string) then
		CheckFCBOpen(FCBOpenOut(&listingFile, listingFilename), listingFilename);
	end if;
end sub;

print("PDP-11 Assembler (C) 2020 David Given; ");
print_i32(((HIMEM - LOMEM) / 1024) as uint32);
print("kB free\n");

ParseArguments();
InitialiseSymbolTable();

pass := 1;
loop
    FCBSeek(&inputFile, 0);
    Pass();
    CheckForUndefinedSymbols();
    pass := pass + 1;
    if labelsChanged == 0 then
        break;
    end if;
end loop;
lastPass := 1;
FCBSeek(&inputFile, 0);
Pass();

sub SafeFCBClose(fcb: [FCB], name: string) is
    if FCBClose(fcb) != 0 then
        StartError();
        print("failed to close ");
        print(name);
        print(" file");
        EndError();
    end if;
end sub;
SafeFCBClose(&outputFile, "output");
if listingFilename != 0 as string then
    FCBPutChar(&listingFile, 26);
    SafeFCBClose(&listingFile, "listing");
end if;

print("Finished with ");
print_i32(((HIMEM - LOMEM) / 1024) as uint32);
print("kB free\n");

# vim: sw=4 ts=4 et
