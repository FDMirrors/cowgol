%{
	#include "globals.h"
	#include "emitter.h"
	#include "midcodes.h"

	#define IMPL
	#include "codegen.h"

	#define E emitter_printf

	struct subarch
	{
		int id;
	};

	static int id = 1;

	void arch_init_types(void)
	{
		make_number_type("uint32", 4, false);
		make_number_type("int32", 4, true);
		intptr_type = make_number_type("uint16", 2, false);
		make_number_type("int16", 2, true);
		uint8_type = make_number_type("uint8", 1, false);
		make_number_type("int8", 1, true);

		add_alias(NULL, "intptr", intptr_type);
	}

	void arch_init_subroutine(struct subroutine* sub)
	{
		sub->arch = calloc(1, sizeof(struct subarch));
		sub->arch->id = id++;
	}

	void arch_init_variable(struct symbol* var)
	{
		/* All variables get allocated from workspace 0. */
		current_sub->workspace[0] += var->u.var.type->u.type.width;
	}

	static const char* regref(reg_t reg)
	{
		return "";
	}

	static const char* subref(Subroutine* sub)
	{
		if (sub->externname)
			return sub->externname;
		
		static char buffer[32];
		snprintf(buffer, sizeof(buffer), "f%d", sub->arch->id);
		return buffer;
	}

	static const char* symref(Symbol* sym, int32_t off)
	{
		static char buffer[32];
		snprintf(buffer, sizeof(buffer), "w%d%+d",
			sym->u.var.sub->arch->id,
			sym->u.var.offset + off);
		return buffer;
	}
%}

register a b d h bc de hl stk;

regdata a;
regdata b uses b|bc;
regdata d uses d|de;
regdata h uses h|hl;
regdata bc uses bc|b;
regdata de uses de|d;
regdata hl uses hl|h;
regdata stk stacked;

gen STARTFILE()
{
    emitter_open_chunk();
    E("\textrn add4\n");
    E("\textrn sub4\n");
    E("\textrn neg4\n");
    E("\textrn cpy4\n");
    E("\textrn asl1\n");
    E("\textrn asl2\n");
	E("\textrn lsr1\n");
	E("\textrn lsr2\n");
	E("\textrn lsr4\n");
	E("\textrn asr1\n");
	E("\textrn asr2\n");
	E("\textrn cmpu4\n");
    emitter_close_chunk();
}

gen ENDFILE();

gen STARTSUB():s
{
    emitter_open_chunk();
    E("\n");
    E("; %s\n", $s.sub->name);
    E("\tcseg\n");
    if ($s.sub->externname)
        E("\tpublic %s\n", $s.sub->externname);
    E("%s:\n", subref($s.sub));

    if ($s.sub->inputparameters != 0)
    {
        E("\tpop b\n");
        for (int i=$s.sub->inputparameters-1; i>=0; i--)
        {
			struct symbol* param = $s.sub->namespace.firstsymbol;
			for (int j=0; j<i; j++)
				param = param->next;

			if (param->u.var.type->u.type.width == 1)
			{
				E("\tpop psw\n");
				E("\tsta %s\n", symref(param, 0));
			}
			else
			{
				E("\tpop h\n");
				E("\tshld %s\n", symref(param, 0));
			}
        }
        E("\tpush b\n");
    }
}

gen ENDSUB():s
{
	E("end_%s:\n", subref($s.sub));
	if ($s.sub->outputparameters != 0)
	{
		E("\tpop h\n");
		E("\txchg\n"); /* put return address in DE */

		for (int i=0; i<$s.sub->outputparameters; i++)
		{
			struct symbol* param = $s.sub->namespace.firstsymbol;
			for (int j=0; j<(i + $s.sub->inputparameters); j++)
				param = param->next;

			if (param->u.var.type->u.type.width == 1)
			{
				E("\tlda %s\n", symref(param, 0));
				E("\tpush psw\n");
			}
			else
			{
				E("\tlhld %s\n", symref(param, 0));
				E("\tpush h\n");
			}
		}

		E("\txchg\n");
		E("\tpchl\n");
	}
	else
		E("\tret\n");

    E("\tdseg\n");
	E("w%d: ds %d\n", $s.sub->arch->id, $s.sub->workspace[0]);
    emitter_close_chunk();
}

gen STORE1(bc|de|hl:lhs, a)
{
	switch ($lhs)
	{
		case REG_BC:
			E("\tstax b\n");
			break;

		case REG_DE:
			E("\tstax d\n");
			break;

		case REG_HL:
			E("\tmov m, a\n");
			break;
	}
}

gen STORE2(bc|de|hl:lhs, hl);

gen STORE1(ADDRESS():lhs, a)
	{ E("\tsta %s\n", symref($lhs.sym, $lhs.off)); }

gen STORE2(ADDRESS():lhs, hl)
	{ E("\tshld %s\n", symref($lhs.sym, $lhs.off)); }

gen bc|de|hl := CONSTANT():rhs
	{ E("\tlxi %s, %d\n", regref($$), $rhs.value); }

gen bc|de|hl := ADDRESS():rhs
	{ E("\tlxi, %s, %s\n", regref($$), symref($rhs.sym, $rhs.off)); }

gen stk := ADD4(stk, stk)
	{ E("\tcall add4\n"); }

gen hl := ADD2(hl, bc|de:rhs)
	{ E("dad %s\n", regref($rhs)); }

gen a := ADD1(a, b|d|h:rhs)
	{ E("\tadd %s\n", regref($rhs)); }

gen a := ADD1(a, CONSTANT():rhs)
	{ E("\tadi %d\n", $rhs.value); }

gen a := ADD1(a|b|d|h:lhs, CONSTANT(value==1))
	{ E("\tinc %s\n", regref($lhs)); }

gen a := ADD1(a|b|d|h:lhs, CONSTANT(value==-1))
	{ E("\tdec %s\n", regref($lhs)); }

gen stk := SUB4(stk, stk);
gen hl := SUB2(hl, bc|de);
gen hl := SUB2(hl, CONSTANT());
gen a := SUB1(a, b|d|h);
gen a := SUB1(a, CONSTANT());

gen a := CAST21(RSHIFTU2(ADDRESS(), CONSTANT(value==8)));

