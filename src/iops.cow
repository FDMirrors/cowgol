const SECTION_UNKNOWN := 0;
const SECTION_CODE := 1;
const SECTION_ROMDATA := 2;
const SECTION_RAMDATA := 3;
const SECTION_NONINITDATA := 4;
const SECTION_POINTERS := 5;

record IHeader
    thing_id: uint16;
    section: uint8;
end record;

record Iop
    iop_size: uint8;
    iop_kind: uint8;
    payload: int8[0];
end record;

const IOP_END := 0;

const IOP_TYPE_MASK        := 0b1110_0000;

const IOP_TYPE_CONDITIONAL := 0b0010_0000;
const IOP_BEQ              := 0b0010_0000;
const IOP_BLT              := 0b0010_0001;
const IOP_BGT              := 0b0010_0010;

const IOP_TYPE_SIMPLE2OP   := 0b0100_0000;
const IOP_MULOP            := 0b0100_0010;
const IOP_DIVOP            := 0b0100_0011;
const IOP_MODOP            := 0b0100_0100;
const IOP_ANDOP            := 0b0100_0101;
const IOP_OROP             := 0b0100_0110;
const IOP_EOROP            := 0b0100_0111;
const IOP_LSLOP            := 0b0100_1000;
const IOP_LSROP            := 0b0100_1001;
const IOP_ASROP            := 0b0100_1010;

const IOP_TYPE_UNTYPED     := 0b0110_0000;
const IOP_LABEL            := 0b0110_0000;
const IOP_STRING           := 0b0110_0001;
const IOP_RETURN           := 0b0110_0010;
const IOP_GOTO             := 0b0110_0011;
const IOP_FILENAME         := 0b0110_0100;
const IOP_LINENUMBER       := 0b0110_0101;
const IOP_BYTES            := 0b0110_0110;
const IOP_WORD             := 0b0110_0111;
const IOP_SWAP             := 0b0110_1000; # not understood by type checker

const IOP_TYPE_SIMPLE1OP   := 0b1000_0000;
const IOP_NEGOP            := 0b1000_0001;
const IOP_NOTOP            := 0b1000_0010;
const IOP_MATERIALISE      := 0b1000_0011;
const IOP_ZEXTOP           := 0b1000_0100;
const IOP_SEXTOP           := 0b1000_0101;

# the typechecker rewrites these to THING.
const IOP_INPUTPARAM  := 0x01; # push input parameter of subroutine
const IOP_OUTPUTPARAM := 0x02; # push output parameter of subroutine

# the typechecker rewrites this to ZEXTOP or SEXTOP.
const IOP_CASTOP      := 0x03;

# the typechecker rewrites this to an INDEXOP.
const IOP_MEMBEROP    := 0x04; # takes identifier

# dereference pointer or array with scaled offset; typechecker rewrites to IOP_INDEXOP
const IOP_SINDEXOP     := 0x05; # apply non-constant offset to EA

const IOP_THING       := 0x06;
const IOP_ASSIGN      := 0x07; # ( dest src -- )
const IOP_ASSIGNTO    := 0x08; # ( src dest -- )
const IOP_CALL        := 0x09;
const IOP_ADDOP       := 0x0a;
const IOP_SUBOP       := 0x0b;
const IOP_ADDRESSOP   := 0x0c;
const IOP_BYTESOP     := 0x0d;
const IOP_SIZEOP      := 0x0e;
const IOP_OFFSETOP    := 0x0f; # apply constant byte offset to EA
const IOP_INDEXOP     := 0x10; # apply variable byte offset to EA
const IOP_LOAD        := 0x11; # turn EA to pointer into EA to thing being pointed at

record FilenameIop: Iop
    thing_id: uint16;
end record;

record LinenumberIop: Iop
    line_number: uint16;
end record;

record LabelIop: Iop
    label_id: uint16;
end record;

record SectionIop: Iop
    section: uint8;
end record;

record StringIop: Iop
    string_id: uint16;
end record;

record CallIop: Iop
    thing_id: uint16;
    input_parameter_count: uint8;
    output_parameter_count: uint8;
end record;

record ParameterIop: Iop
    subroutine_id: uint16;
    parameter: uint8;
end record;

record GotoIop: Iop
    label_id: uint16;
end record;

record TypedIop: Iop
    type_id: uint16;
end record;

record ConditionalIop: TypedIop
    iftrue_label_id: uint16;
    iffalse_label_id: uint16;
end record;

record ThingIop: TypedIop
    thing_id: uint16;
end record;

record OffsetIop: TypedIop
    offset: int16;
end record;

record MemberIop: Iop
    thing_id: uint16;
end record;

record BytesIop: Iop
    byte_count: uint8;
    bytes: uint8[8];
end record;

record WordIop: Iop
    thing_id: uint16;
    offset_id: uint16;
end record;

record BiggestIop: BytesIop
end record;
