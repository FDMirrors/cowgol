# In order from left to right: has sizes, number of inputs, number of outputs,
# instruction definition.
- 0 0 END()
- 0 0 STARTFILE()
- 0 0 ENDFILE()
- 0 0 STARTSUB(struct subroutine* sub) = ("%s", $$.sub->name)
- 0 0 ENDSUB(struct subroutine* sub) = ("%s", $$.sub->name)

- 0 0 STARTINIT(struct symbol* sym) = ("%s", $$.sym->name)
y 0 0 INIT(int32_t value) = ("%d", $$.value)
- 0 0 INITS(const char* text) = ("...")
- 0 0 ENDINIT()

- 0 0 ASMSTART()
- 0 0 ASMTEXT(const char* text) = ("%s", $$.text)
- 0 0 ASMSYMBOL(struct symbol* sym) = ("%s", $$.sym->name)
- 0 0 ASMVALUE(int32_t value) = ("%d", $$.value)
- 0 0 ASMEND()

# This one is used internally for bookkeeping and the backend should never see it.
- 2 1 PAIR()

- 0 0 LABEL(int label) = ("%d", $$.label)
- 0 0 JUMP(int label) = ("%d", $$.label)
- 1 0 CALLS()
y 1 1 CALL(struct subroutine* sub) = ("%s", $$.sub->name)
- 0 0 RETURN()

- 0 1 CONSTANT(int32_t value) = ("%d", $$.value)
- 0 1 STRING(const char* text) = ("...")
- 0 1 ADDRESS(struct symbol* sym, int32_t off) = ("%s%+d", $$.sym->name, $$.off)

y 1 1 LOAD()
y 2 0 STORE() # left is value, right is address

y 2 0 BEQS(int truelabel, int falselabel, int fallthrough, int negated) = ("true=%d false=%d fallthrough=%d negated=%d", $$.truelabel, $$.falselabel, $$.fallthrough, $$.negated)
y 2 0 BLTS(int truelabel, int falselabel, int fallthrough, int negated) = ("true=%d false=%d fallthrough=%d negated=%d", $$.truelabel, $$.falselabel, $$.fallthrough, $$.negated)
y 2 0 BEQU(int truelabel, int falselabel, int fallthrough, int negated) = ("true=%d false=%d fallthrough=%d negated=%d", $$.truelabel, $$.falselabel, $$.fallthrough, $$.negated)
y 2 0 BLTU(int truelabel, int falselabel, int fallthrough, int negated) = ("true=%d false=%d fallthrough=%d negated=%d", $$.truelabel, $$.falselabel, $$.fallthrough, $$.negated)

y 2 0 CASE() # left is value, right is when chain
- 1 0 WHEN(bool isdefault, int32_t value, int label) = ("%s %d => %d", $$.isdefault ? "default" : "", $$.value, $$.label) # left is chain

# These produce all combinations of source and destination widths.
y 1 1 CAST1(bool sext) = ("sext=%d", $$.sext)
y 1 1 CAST2(bool sext) = ("sext=%d", $$.sext)
y 1 1 CAST4(bool sext) = ("sext=%d", $$.sext)
y 1 1 CAST8(bool sext) = ("sext=%d", $$.sext)

y 2 1 PUSHPARAM() # left is chain, right is value
y 2 1 POPPARAM() # left is chain, right is lvalue

y 2 1 ADD()
y 2 1 SUB()
y 2 1 MUL()
y 2 1 DIVU()
y 2 1 DIVS()
y 2 1 REMU()
y 2 1 REMS()
y 2 1 AND()
y 2 1 OR()
y 2 1 EOR()
y 1 1 NOT()
y 1 1 NEG()
y 2 1 LSHIFT()
y 2 1 RSHIFTU()
y 2 1 RSHIFTS()

