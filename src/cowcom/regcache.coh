const CACHE_SIZE := REGISTER_COUNT;

const CACHE_SLOT_EMPTY    := 0;
const CACHE_SLOT_CONSTANT := 1;
const CACHE_SLOT_ADDRESS  := 2;

record CacheSlot
	symbol: [Symbol];
	number: Arith;
	reg: RegId;
	state: uint8;
end record;

var register_cache: CacheSlot[CACHE_SIZE];

sub RegCacheReset()
	MemZero(&register_cache[0] as [uint8], @bytesof register_cache);
end sub;

sub RegCacheFlush(reg: RegId)
	var p := &register_cache[0];
	while p != &register_cache[@sizeof register_cache] loop
		if (p.state != CACHE_SLOT_EMPTY) and ((reg & p.reg) != 0) then
			p.state := CACHE_SLOT_EMPTY;
		end if;
		p := @next p;
	end loop;
end sub;

sub RegCacheLeavesConstant(reg: RegId, value: Arith)
	var p := &register_cache[0];
	while p != &register_cache[@sizeof register_cache] loop
		if (p.state == CACHE_SLOT_CONSTANT) and (p.number == value) then
			p.reg := p.reg | reg;
			return;
		end if;
		p := @next p;
	end loop;

	p := &register_cache[0];
	while p != &register_cache[@sizeof register_cache] loop
		if (p.state == CACHE_SLOT_EMPTY) then
			p.state := CACHE_SLOT_CONSTANT;
			p.number := value;
			p.reg := reg;
			return;
		end if;
		p := @next p;
	end loop;

	# The cache is full, so just drop this value on the floor.
end sub;

sub RegCacheLeavesAddress(reg: RegId, sym: [Symbol], off: Size)
	var p := &register_cache[0];
	while p != &register_cache[@sizeof register_cache] loop
		if (p.state == CACHE_SLOT_ADDRESS) and (p.symbol == sym) and (p.number == (off as Arith)) then
			p.reg := p.reg | reg;
			return;
		end if;
		p := @next p;
	end loop;

	p := &register_cache[0];
	while p != &register_cache[@sizeof register_cache] loop
		if (p.state == CACHE_SLOT_EMPTY) then
			p.state := CACHE_SLOT_ADDRESS;
			p.symbol := sym;
			p.number := off as Arith;
			p.reg := reg;
			return;
		end if;
		p := @next p;
	end loop;

	# The cache is full, so just drop this value on the floor.
end sub;

sub RegCacheFindConstant(value: Arith): (reg: RegId)
	reg := 0;
	var p := &register_cache[0];
	while p != &register_cache[@sizeof register_cache] loop
		if (p.state == CACHE_SLOT_CONSTANT) and (p.number == value) then
			reg := p.reg;
			return;
		end if;
		p := @next p;
	end loop;
end sub;

sub RegCacheFindAddress(sym: [Symbol], off: Size): (reg: RegId)
	reg := 0;
	var p := &register_cache[0];
	while p != &register_cache[@sizeof register_cache] loop
		if (p.state == CACHE_SLOT_ADDRESS) and (p.symbol == sym) and (p.number == (off as Arith)) then
			reg := p.reg;
			return;
		end if;
		p := @next p;
	end loop;
end sub;

