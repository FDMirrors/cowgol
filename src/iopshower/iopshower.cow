load_thing_table("things.dat");

sub print_identifier(identifier_id: uint16)
    var identifier: [IdentifierThing] := find_thing(identifier_id) as [IdentifierThing];
    show_string(identifier.string_id);
end sub;

sub print_label(label_id: uint16)
    loop
        print_hex_i16(label_id);

        var label: [LabelThing] := find_thing(label_id) as [LabelThing];
        if label.thing_type == THING_LABEL then
            break;
        end if;

        label_id := label.target;
        print(" -> 0x");
    end loop;
end sub;

sub do_label(iop: [LabelIop])
    print("LABEL 0x");
    print_label(iop.label_id);
end sub;

sub do_thing(iop: [ThingIop])
    print("THING id=0x");
    print_hex_i16(iop.thing_id);
    print(" type=0x");
    print_hex_i16(iop.type_id);
end sub;

sub do_call(kind: [int8], iop: [CallIop])
    print(kind);
    print(" id=0x");
    print_hex_i16(iop.thing_id);
    print(" parameter_count=");
    print_i8(iop.parameter_count);
    print(")");
end sub;

sub do_branching(kind: [int8], iop: [BranchingIop])
    print(kind);
    print(" label=0x");
    print_label(iop.label_id);
end sub;

sub do_pushing(kind: [int8], iop: [PushingIop])
    print(kind);
    print(" type=0x");
    print_hex_i16(iop.type_id);
end sub;

loop
    var header: [IHeader] := read_iop_header();
    if header.thing_id == 0 then
        break;
    end if;

    var subroutine: [SubroutineThing] := find_thing(header.thing_id) as [SubroutineThing];
    var symbol_id: uint16 := find_symbol_by_value(header.thing_id);
    print("SUBROUTINE: 0x");
    print_hex_i16(header.thing_id);
    print(": ");
    if symbol_id != 0 then
        var symbol: [SymbolThing] := find_thing(symbol_id) as [SymbolThing];
        print_identifier(symbol.name_id);
    else
        print("(main subroutine)");
    end if;
    print_newline();

    var offset: uint16 := IHeader@bytes;
    loop
        var iop: [Iop] := read_iop();
        var kind: uint8 := iop.iop_kind;
        print_hex_i16(offset);
        print(": ");
        if kind == IOP_END then
            print("END");
        elseif kind == IOP_LABEL then
            do_label(iop as [LabelIop]);
        elseif kind == IOP_ASSIGN then
            print("ASSIGN");
        elseif kind == IOP_SCALL then
            do_call("SCALL", iop as [CallIop]);
        elseif kind == IOP_GOTO then
            do_branching("GOTO", iop as [BranchingIop]);
        elseif kind == IOP_BEQ then
            do_branching("BEQ", iop as [BranchingIop]);
        elseif kind == IOP_BNE then
            do_branching("BNE", iop as [BranchingIop]);
        elseif kind == IOP_BLT then
            do_branching("BLT", iop as [BranchingIop]);
        elseif kind == IOP_BGE then
            do_branching("BGE", iop as [BranchingIop]);
        elseif kind == IOP_BGT then
            do_branching("BGT", iop as [BranchingIop]);
        elseif kind == IOP_BLE then
            do_branching("BLE", iop as [BranchingIop]);
        elseif kind == IOP_THING then
            do_thing(iop as [ThingIop]);
        elseif kind == IOP_ADDOP then
            do_pushing("ADDOP", iop as [PushingIop]);
        elseif kind == IOP_SUBOP then
            do_pushing("SUBOP", iop as [PushingIop]);
        elseif kind == IOP_MULOP then
            do_pushing("MULOP", iop as [PushingIop]);
        elseif kind == IOP_DIVOP then
            do_pushing("DIVOP", iop as [PushingIop]);
        elseif kind == IOP_MODOP then
            do_pushing("MODOP", iop as [PushingIop]);
        elseif kind == IOP_NEGOP then
            do_pushing("NEGOP", iop as [PushingIop]);
        elseif kind == IOP_NOTOP then
            do_pushing("NOTOP", iop as [PushingIop]);
        else
            print("Unknown iop 0x");
            print_hex_i8(kind);
        end if;
        print_newline();
        offset := offset + iop.iop_size;
        if kind == IOP_END then
            break;
        end if;
    end loop;
    print_newline();
end loop;
