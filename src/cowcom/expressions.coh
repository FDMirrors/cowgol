sub IsTypeOfKind(type: [Symbol], kind: uint8): (result: uint8)
	result := 0;
	if (type != (0 as [Symbol])) and (type.kind == TYPE) and (type.typedata.kind == kind) then
		result := 1;
	end if;
end sub;

sub IsArray(type: [Symbol]): (result: uint8)
	result := IsTypeOfKind(type, TYPE_ARRAY);
end sub;

sub IsPtr(type: [Symbol]): (result: uint8)
	result := IsTypeOfKind(type, TYPE_POINTER);
end sub;

sub IsNum(type: [Symbol]): (result: uint8)
	if type == (0 as [Symbol]) then
		result := 1;
	else
		result := IsTypeOfKind(type, TYPE_NUMBER);
	end if;
end sub;

sub IsSNum(type: [Symbol]): (result: uint8)
	if type == (0 as [Symbol]) then
		result := 1;
	elseif (IsTypeOfKind(type, TYPE_NUMBER) != 0) and (type.typedata.numbertype.is_signed != 0) then
		result := 1;
	else
		result := 0;
	end if;
end sub;

sub IsScalar(type: [Symbol]): (result: uint8)
	if (IsPtr(type) != 0) or (IsNum(type) != 0) then
		result := 1;
	else
		result := 0;
	end if;
end sub;

sub IsRecord(type: [Symbol]): (result: uint8)
	result := IsTypeOfKind(type, TYPE_RECORD);
end sub;

sub MakeLValue(address: [Node]): (lvalue: [Node])
	var w: uint8 := 0;
	var elementtype := address.type.typedata.pointertype.element;
	if IsScalar(elementtype) != 0 then
		w := elementtype.typedata.width as uint8;
	end if;
	lvalue := MidLoad(w, address);
	lvalue.type := elementtype;

	#print("make ");
	#print_hex_i32(lvalue as intptr as uint32);
	#print_nl();
end sub;

sub UndoLValue(lvalue: [Node]): (address: [Node])
	#print("undo ");
	#print_hex_i32(lvalue as intptr as uint32);
	#print_nl();

	var k := lvalue.op;
	if (k < MIDCODE_LOAD0) or (k > MIDCODE_LOAD8) then
		SimpleError("lvalue required");
	end if;

	address := lvalue.left;
	lvalue.left := (0 as [Node]);
	Discard(lvalue);
end sub;

sub CheckExpressionType(node: [Node], type: [Symbol])
	if node.type == (0 as [Symbol]) then
		node.type := type;
	end if;

	if node.type != type then
		StartError();
		print("type mismatch: expression was a ");
		print(node.type.name);
		print(", used when a ");
		print(type.name);
		print(" was expected");
		EndError();
	end if;

	if (IsPtr(type) == 0) and (IsNum(type) == 0) then
		StartError();
		print(type.name);
		print(" cannot be used here");
		EndError();
	end if;
end sub;

sub ResolveUntypedConstantsForAddOrSub(lhs: [Node], rhs: [Node])
	if (lhs.type != (0 as [Symbol])) and (rhs.type == (0 as [Symbol])) then
		if IsNum(lhs.type) != 0 then
			rhs.type := lhs.type;
		elseif IsPtr(lhs.type) != 0 then
			rhs.type := intptr_type;
		else
			SimpleError("cannot use an untyped constant in this context");
		end if;
	end if;
	if (lhs.type == (0 as [Symbol])) and (rhs.type != (0 as [Symbol])) then
		if IsNum(rhs.type) != 0 then
			lhs.type := rhs.type;
		elseif IsPtr(rhs.type) != 0 then
			SimpleError("pointers may only appear on the LHS of an addition or subtraction");
		end if;
	end if;
end sub;

sub ResolveUntypedConstantsSimply(lhs: [Node], rhs: [Node])
	if (lhs.type != (0 as [Symbol])) and (rhs.type == (0 as [Symbol])) then
		rhs.type := lhs.type;
	elseif (lhs.type == (0 as [Symbol])) and (rhs.type != (0 as [Symbol])) then
		rhs.type := lhs.type;
	elseif lhs.type != rhs.type then
		StartError();
		print("type mismatch between ");
		print(lhs.type.name);
		print(" and ");
		print(rhs.type.name);
		EndError();
	end if;
end sub;

sub CheckNumber(node: [Node])
	if IsNum(node.type) == 0 then
		SimpleError("number required");
	end if;
end sub;

sub ResolveUntypedConstantsNeedingNumbers(lhs: [Node], rhs: [Node])
	ResolveUntypedConstantsSimply(lhs, rhs);
	CheckNumber(lhs);
	CheckNumber(rhs);
end sub;

sub CondSimple(lhs: [Node], rhs: [Node])
	ResolveUntypedConstantsSimply(lhs, rhs);
	if lhs.type != rhs.type then
		StartError();
		print("you tried to compare a ");
		print(lhs.type.name);
		print(" and a ");
		print(rhs.type.name);
		EndError();
	end if;
end sub;


sub ExprNeg(lhs: [Node]): (result: [Node])
	result := MidCNeg(NodeWidth(lhs), lhs);
	result.type := lhs.type;
end sub;

sub ExprNot(lhs: [Node]): (result: [Node])
	result := MidCNot(NodeWidth(lhs), lhs);
	result.type := lhs.type;
end sub;

sub ExprAdd(lhs: [Node], rhs: [Node]): (result: [Node])
	ResolveUntypedConstantsForAddOrSub(lhs, rhs);

	sub cant_add_that()
		StartError();
		print("you can't add a ");
		print(lhs.type.name);
		print(" to a ");
		print(rhs.type.name);
		EndError();
	end sub;

	if (IsPtr(lhs.type) != 0) then
		if (IsPtr(rhs.type) != 0) or (rhs.type != intptr_type) then
			cant_add_that();
		end if;
	elseif IsPtr(rhs.type) != 0 then
		SimpleError("add numbers to pointers, not vice versa");
	elseif (IsPtr(lhs.type) == 0) and (lhs.type != rhs.type) then
		cant_add_that();
	end if;
	
	result := MidCAdd(NodeWidth(lhs), lhs, rhs);
	result.type := lhs.type;
end sub;

sub ExprSub(lhs: [Node], rhs: [Node]): (result: [Node])
	ResolveUntypedConstantsForAddOrSub(lhs, rhs);

	sub cant_sub_that()
		StartError();
		print("you can't subtract a ");
		print(lhs.type.name);
		print(" from a ");
		print(rhs.type.name);
		EndError();
	end sub;

	if (IsPtr(lhs.type) != 0) and (IsPtr(rhs.type) == 0) and (rhs.type != intptr_type) then
		cant_sub_that();
	elseif (IsNum(lhs.type) != 0) and (IsPtr(rhs.type) != 0) then
		cant_sub_that();
	elseif (IsNum(lhs.type) != 0) and (IsNum(rhs.type) != 0) and (lhs.type != rhs.type) then
		cant_sub_that();
	end if;

	result := MidCSub(NodeWidth(lhs), lhs, rhs);
	if (IsPtr(lhs.type) != 0) and (lhs.type == rhs.type) then
		result.type := intptr_type;
	else
		result.type := lhs.type;
	end if;
end sub;

sub ExprMul(lhs: [Node], rhs: [Node]): (result: [Node])
	ResolveUntypedConstantsNeedingNumbers(lhs, rhs);
	result := MidCMul(NodeWidth(lhs), lhs, rhs);
	result.type := lhs.type;
end sub;

sub ExprDiv(lhs: [Node], rhs: [Node]): (result: [Node])
	ResolveUntypedConstantsNeedingNumbers(lhs, rhs);
	if lhs.type.typedata.numbertype.is_signed != 0 then
		result := MidCDivs(NodeWidth(lhs), lhs, rhs);
	else
		result := MidCDivu(NodeWidth(lhs), lhs, rhs);
	end if;
	result.type := lhs.type;
end sub;

sub ExprRem(lhs: [Node], rhs: [Node]): (result: [Node])
	ResolveUntypedConstantsNeedingNumbers(lhs, rhs);
	if lhs.type.typedata.numbertype.is_signed != 0 then
		result := MidCRems(NodeWidth(lhs), lhs, rhs);
	else
		result := MidCRemu(NodeWidth(lhs), lhs, rhs);
	end if;
	result.type := lhs.type;
end sub;

sub ExprAnd(lhs: [Node], rhs: [Node]): (result: [Node])
	ResolveUntypedConstantsNeedingNumbers(lhs, rhs);
	result := MidCAnd(NodeWidth(lhs), lhs, rhs);
	result.type := lhs.type;
end sub;

sub ExprOr(lhs: [Node], rhs: [Node]): (result: [Node])
	ResolveUntypedConstantsNeedingNumbers(lhs, rhs);
	result := MidCOr(NodeWidth(lhs), lhs, rhs);
	result.type := lhs.type;
end sub;

sub ExprEor(lhs: [Node], rhs: [Node]): (result: [Node])
	ResolveUntypedConstantsNeedingNumbers(lhs, rhs);
	result := MidCEor(NodeWidth(lhs), lhs, rhs);
	result.type := lhs.type;
end sub;

sub expr_i_checkrhsconst(rhs: [Node])
	if rhs.op != MIDCODE_CONSTANT then
		SimpleError("LHS of shift can only be constant if the RHS is also constant");
	end if;
end sub;

sub expr_i_checkshift(lhs: [Node], rhs: [Node])
	if IsNum(lhs.type) == 0 then
		SimpleError("number required on LHS of shift");
	end if;
	CheckExpressionType(rhs, uint8_type);
end sub;

sub ExprRShift(lhs: [Node], rhs: [Node]): (result: [Node])
	if lhs.op == MIDCODE_CONSTANT then
		expr_i_checkrhsconst(rhs);
		lhs.constant.value := lhs.constant.value >> (rhs.constant.value as uint8);
		result := lhs;
		Discard(rhs);
		return;
	end if;

	expr_i_checkshift(lhs, rhs);

	result := MidRshiftu(NodeWidth(lhs), lhs, rhs);
	result.type := lhs.type;

	if IsSNum(lhs.type) != 0 then
		result.op := result.op + (MIDCODE_RSHIFTS0-MIDCODE_RSHIFTU0);
	end if;
end sub;

sub ExprLShift(lhs: [Node], rhs: [Node]): (result: [Node])
	if lhs.op == MIDCODE_CONSTANT then
		expr_i_checkrhsconst(rhs);
		lhs.constant.value := lhs.constant.value << (rhs.constant.value as uint8);
		result := lhs;
		Discard(rhs);
		return;
	end if;

	expr_i_checkshift(lhs, rhs);

	result := MidLshift(NodeWidth(lhs), lhs, rhs);
	result.type := lhs.type;
end sub;


