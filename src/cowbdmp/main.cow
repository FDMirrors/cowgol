include "cowgol.coh";
include "strings.coh";
include "malloc.coh";
include "file.coh";
include "argv.coh";

print("COWBDMP: ");
print_i16((GetFreeMemory() >> 10) as uint16);
print("kB free\n");

include "src/cowbdmp/types.coh";
include "src/cowbe/utils.coh";
include "midcodesbe.coh";
include "src/cowbe/treewalker.coh";

@impl sub AllocateNewNode is
	node := Alloc(@bytesof Node) as [Node];
	#print("alloc ");
	#print_hex_i32(node as intptr as uint32);
	#print_nl();
	node.op := op;
end sub;

@impl sub FreeNode is
	#print("free ");
	#print_hex_i32(node as intptr as uint32);
	#print_nl();
	Free(node as [uint8]);
end sub;

include "src/cowbe/inputter.coh";
include "cobin.coh";

sub SyntaxError() is
	SimpleError("syntax: cowbdmp <cobfile>");
end sub;

sub ParseArguments() is
	ArgvInit();
	var inputfilename := ArgvNext();
	if inputfilename == (0 as string) then
		SyntaxError();
	end if;
	if ArgvNext() != (0 as string) then
		SyntaxError();
	end if;

	InputterOpenfile(inputfilename);
end sub;

sub I_node(): (rootnode: [Node]) is
	var count: uint8 := 1;
	rootnode := 0 as [Node];
	while count != 0 loop
		var op := I_b8();
		var node: [Node] := AllocateNewNode(op);
		node.next := rootnode;
		rootnode := node;
		var sig := signatures[op-1];
		(midcode_readers[sig])(node);
		count := count + midcode_ins[op-1] - 1;
	end loop;

	# We should now have a chain of nodes in right-to-left order starting at
	# rootnode, hooked together via their next links. We need to convert this
	# to a tree. We do this by popping nodes on at a time and queueing them.
	# Each time we pop a node which takes children, we remove that many from
	# the queue and add them to the node before queuing it. Eventually we will
	# end up with a single node on the queue which is the root of the tree.

	var queue: [Node] := (0 as [Node]);
	while rootnode != 0 as [Node] loop
		# Remove one item from the list.

		node := rootnode;
		rootnode := node.next;

		# Does it take children?

		var children := midcode_ins[node.op-1];
		if children >= 1 then
			# At least one child; pop item and place it on the left branch.

			node.left := queue;
			queue := node.left.next;
		end if;
		if children == 2 then
			# Two children; pop another item. Note that as we're reading
			# nodes backwards, this is actually the *left* branch, and we
			# need to move the node read previously into the right branch.

			node.right := node.left;
			node.left := queue;
			queue := node.left.next;
		end if;

		# Add this node to the queue.

		node.next := queue;
		queue := node;
	end loop;

	rootnode := queue;
end sub;

sub ReadN() is
	var subrid := I_b16();
	var name := I_countedstring();
	print("N: ");
	print_hex_i16(subrid);
	print(" ");
	print(name);
	print_nl();
	Free(name);
end sub;

sub ReadX() is
	var subrid := I_b16();
	var name := I_countedstring();
	print("X: ");
	print_hex_i16(subrid);
	print(" ");
	print(name);
	print_nl();
	Free(name);
end sub;

sub ReadM() is
	print("M:");
	var rootnode := I_node();

	var old_next_node := next_node;
	PushNode(rootnode);
	while next_node != old_next_node loop
		var node := NextNode();
		if node == (0 as [Node]) then
			break;
		end if;

		print_char(' ');
		print(MidcodeName(node.op));
	end loop;
	print_nl();
	Discard(rootnode);
end sub;

sub ReadR() is
	var userid := I_b16();
	var usedid := I_b16();
	print("R: ");
	print_hex_i16(userid);
	print(" ");
	print_hex_i16(usedid);
	print_nl();
end sub;

sub ReadW() is
	var subrid := I_b16();
	var wsid := I_b8();
	var size := I_bsize();
	print("W: ");
	print_hex_i16(subrid);
	print_char(' ');
	print_hex_i8(wsid);
	print_char(' ');
	print_hex_i16(size);
	print_nl();
end sub;

sub ReadP(type: uint8) is
	var subrid := I_b16();

	print_char(type);
	print(": ");
	print_hex_i16(subrid);
	print(" ");
	var count := I_b8();
	print_i8(count);
	print(":");

	while count != 0 loop
		var psubrid := I_b16();
		var wsid := I_b8();
		var off := I_bsize();
		var name := I_countedstring();
		var width := I_b8();
		print(" [");
		print_hex_i16(psubrid);
		print(" ");
		print_hex_i8(wsid);
		print(" ");
		print_hex_i16(off);
		print(" ");
		print(name);
		print(" ");
		print_hex_i8(width);
		print("]");
		Free(name);

		count := count - 1;
	end loop;
	print_nl();
end sub;

sub DumpRecords() is
	loop
		print_hex_i32(FCBPos(&infcb));
		print_char(' ');
		var r := I_b8();
		case r is
			when 'E': print("E\n"); return;
			when 'N': ReadN();
			when 'X': ReadX();
			when 'M': ReadM();
			when 'R': ReadR();
			when 'W': ReadW();
			when 'I': ReadP('I');
			when 'O': ReadP('O');

			when else:
				StartError();
				print("unsupported record 0x");
				print_hex_i8(r);
				print(" at 0x");
				print_hex_i32(FCBPos(&infcb));
				EndError();
		end case;
	end loop;
end sub;

ParseArguments();
DumpRecords();
InputterClosefile();
	
