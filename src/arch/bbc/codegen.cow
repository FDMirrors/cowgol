const REG_A    := 0b0000_0001;
const REG_X    := 0b0000_0010;
const REG_Y    := 0b0000_0100;
const REG_MASK := 0b0111_1111;
const PRECIOUS := 0b1000_0000;

record CachedValue
    ea: EffectiveAddress;
    locations: uint8;
end record;

var values: CachedValue[8];

sub print_cache()
    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        if value.locations != 0 then
            print("cache slot ");
            print_i8(i);
            print(": ");
            print_ea(&value.ea);
            if (value.locations & PRECIOUS) != 0 then
                print(" precious");
            end if;
            print(" in 0x");
            print_hex_i8(value.locations & REG_MASK);
            print_newline();
        end if;
        i := i + 1;
    end loop;
end sub;

sub bad_register()
    print("bad register");
    halt();
end sub;

sub arch_init_codegen()
    zero_memory(&values[0] as [int8], values@bytes);
end sub;

sub find_unused_regs(candidates: uint8): (mask: uint8)
    var i: uint8 := 0;
    while i < values@size loop
        candidates := candidates & (values[i].locations ^ 0xff);
        i := i + 1;
    end loop;
    mask := candidates & REG_MASK;
end sub;

sub find_first_bit(value: uint8): (mask: uint8)
    mask := 1;
    loop
        if (value & mask) != 0 then
            return;
        end if;
        if mask == 0x80 then
            break;
        end if;
        mask := mask << 1;
    end loop;
    mask := 0;
end sub;

sub allocate_reg(candidates: uint8): (mask: uint8)
    mask := find_unused_regs(candidates);
    if mask == 0 then
        print("no unused registers");
        halt();
    end if;
    mask := find_first_bit(mask);
    print("* allocating 0x");
    print_hex_i8(mask);
    print_newline();
end sub;

sub find_regs_with_value(ea: [EffectiveAddress], candidates: uint8): (locations: uint8)
    var index: uint8 := 0;
    while index < values@size loop
        var value: [CachedValue] := &values[index];
        locations := value.locations & REG_MASK;
        if (locations != 0) and (is_same_ea(&value.ea, ea) != 0) then
            locations := value.locations & REG_MASK;
            print("* found in 0x");
            print_hex_i8(locations);
            print(" value ");
            print_ea(ea);
            print_newline();
            return;
        end if;
        index := index + 1;
    end loop;
    locations := 0;
    print("* did not find value ");
    print_ea(ea);
    print(" in any register\n");
end sub;

sub find_reg_with_value(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := find_regs_with_value(ea, candidates);
    if location != 0 then
        location := find_first_bit(location);
    end if;
end sub;

sub value_is_cached_in_reg(ea: [EffectiveAddress], locations: uint8)
    var i: uint8;
    var value: [CachedValue];

    sub msg()
        print("* remembering that ");
        print_ea(ea);
        print(" is also in 0x");
        print_i8(locations);
        print_newline();
    end sub;

    # Look for a cache slot already containing this value.
    i := 0;
    while i < values@size loop
        value := &values[i];

        if is_same_ea(&value.ea, ea) != 0 then
            value.locations := value.locations | locations;
            msg();
            return;
        end if;
        i := i + 1;
    end loop;

    # Not found --- find an empty cache slot and use that.
    i := 0;
    while i < values@size loop
        value := &values[i];

        if value.locations == 0 then
            value.locations := locations;
            copy_ea(ea, &value.ea);
            msg();
            return;
        end if;
        i := i + 1;
    end loop;

    print("can't cache, value cache is full");
    halt();
end sub;

sub move_value_to_reg(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := find_reg_with_value(ea, candidates);
    if location != 0 then
        return;
    end if;

    location := find_reg_with_value(ea, REG_A|REG_X|REG_Y);
    if location == 0 then
        return;
    end if;

    var oldlocation: uint8 := location;
    location := allocate_reg(candidates);

    var opcode: uint8 := 0;
    if location == REG_A then
        if oldlocation == REG_X then
            opcode := 0x8A; # TXA
        elseif oldlocation == REG_Y then
            opcode := 0x98; # TYA
        end if;
    elseif location == REG_X then
        if oldlocation == REG_A then
            opcode := 0xAA; # TAX
        end if;
    elseif location == REG_Y then
        if oldlocation == REG_A then
            opcode := 0xA8; # TAY
        end if;
    end if;
    if opcode == 0 then
        print("bad move");
        halt();
    end if;

    write_byte(opcode);
    value_is_cached_in_reg(ea, location);
end sub;

sub value_is_precious(ea: [EffectiveAddress])
    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        if value.locations != 0 then
            if is_same_ea(ea, &value.ea) != 0 then
                if (value.locations & PRECIOUS) == 0 then
                    print("* remembering that value ");
                    print_ea(ea);
                    print(" is precious in 0x");
                    print_i8(value.locations);
                    print_newline();
                    value.locations := value.locations | PRECIOUS;
                    return;
                end if;
            end if;
        end if;
        i := i + 1;
    end loop;
    print("can't make precious, value cache is full");
    halt();
end sub;

# opcode needs to be the *abs* form of the instruction.
sub write_6502_regular_op(opcode: uint8, ea: [EffectiveAddress])
    print("* write opcode 0x");
    print_hex_i8(opcode);
    print(": ");
    print_ea(ea);
    print_newline();

    var obj: [DataThing] := find_thing(ea.obj_id) as [DataThing];
    if obj.thing_type == THING_NUMBER then
        write_byte(opcode & 0xfb);
        write_byte(get_value_of_number(ea.obj_id));
        return;
    elseif (obj.thing_type & THING_DATA) == 0 then
        print("bad ea: wrong thing type ");
        print_ea(ea);
        halt();
    end if;

    if ea.varoff_id != 0 then
        print("bad ea: has varoff ");
        print_ea(ea);
        halt();
    end if;

    if (obj.segment == SEGMENT_ZEROPAGE) and (ea.numoff_id == 0) then
        # Zero page indexing behaves funny (it wraps at 0x0100), so don't use it if there's
        # an index. (We can probably optimise this for objects which we know live only in
        # zero page.)
        write_byte(opcode & 0xf7);
        write_cg_6502_zeropage_iop(ea.obj_id, 0);
    else
        write_byte(opcode);
        write_address_iop(ea.obj_id, ea.numoff_id);
    end if;
end sub;

sub save_objval(location: uint8, ea: [EffectiveAddress])
    var opcode: uint8;
    if location == REG_A then
        opcode := 0x8D; # STA abs
    elseif location == REG_X then
        opcode := 0x8E; # STX abs
    elseif location == REG_Y then
        opcode := 0x8C; # STY abs
    else
        bad_register();
    end if;
    write_6502_regular_op(opcode, ea);
end sub;

sub write_back_precious_value(location: uint8, ea: [EffectiveAddress])
    location := find_first_bit(location);
    print("* writing back 0x");
    print_hex_i8(location);
    print(" to precious value ");
    print_ea(ea);
    print_newline();

    if ea.type == EA_OBJVAL then
        save_objval(location, ea);
    else
        print("can't write precious value ");
        print_ea(ea);
        print(" yet");
        halt();
    end if;
end sub;

sub write_back_precious_values(mask: uint8)
    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        var locations: uint8 := value.locations;
        if (locations & mask) != 0 then
            if (locations & PRECIOUS) != 0 then
                locations := locations - PRECIOUS;
                write_back_precious_value(locations, &value.ea);
                value.locations := locations;
            end if;
        end if;
        i := i + 1;
    end loop;
end sub;

# The contents of location are about to be replaced with a new value. If any values there
# are precious, they get written back --- except for the new value, if it's there.
# Any cached values in that location get flushed. This allows mutation of values without
# triggering writeback.
sub value_in_location_will_be_replaced_with(location: uint8, newvalue: [EffectiveAddress])
    print("* replacing value in 0x");
    print_hex_i8(location);
    print(" with ");
    print_ea(newvalue);
    print_newline();

    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        if (value.locations & location) != 0 then
            if ((value.locations & PRECIOUS) != 0) and (is_same_ea(&value.ea, newvalue) == 0) then
                write_back_precious_value(location, &value.ea);
            end if;
            value.locations := value.locations & (REG_MASK ^ location);
        end if;
        i := i + 1;
    end loop;
end sub;

sub flush_cached_values(mask: uint8)
    write_back_precious_values(mask);
    var i: uint8 := 0;
    while i < values@size loop
        var value: [CachedValue] := &values[i];
        if (value.locations & mask) != 0 then
            print("* flushing cache slot ");
            print_i8(i);
            print_newline();
            value.locations := 0;
        end if;
        i := i + 1;
    end loop;
end sub;

sub allocate_reg_for_value(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := allocate_reg(candidates);
    flush_cached_values(location);
    value_is_cached_in_reg(ea, location);
end sub;

sub find_or_load_objval(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := move_value_to_reg(ea, candidates);
    if location != 0 then
        return;
    end if;
    location := allocate_reg_for_value(ea, candidates);

    var opcode: uint8;
    if location == REG_A then
        opcode := 0xAD; # LDA abs
    elseif location == REG_X then
        opcode := 0xAE; # LDX abs
    elseif location == REG_Y then
        opcode := 0xAC; # LDY abs
    else
        bad_register();
    end if;

    write_6502_regular_op(opcode, ea);
end sub;

# Loads *just the index part* of the EA into either X or Y.
sub find_or_load_index(ea: [EffectiveAddress]): (location: uint8)
    var indexea: EffectiveAddress;
    indexea.type := EA_OBJVAL;
    indexea.varoff_id := 0;
    indexea.numoff_id := 0;
    var indexcandidates: uint8 := REG_Y;
    if ea.varoff_id != 0 then
        indexea.obj_id := ea.varoff_id;
    else
        indexea.obj_id := ea.numoff_id;
        if indexea.obj_id == 0 then
            indexea.obj_id := add_number_by_value(0);
        end if;
        if get_value_of_number(indexea.obj_id) == 0 then
            indexcandidates := REG_X|REG_Y;
        end if;
    end if;

    location := find_or_load_objval(&indexea, indexcandidates);
end sub;

sub find_or_load_ptrval(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    location := move_value_to_reg(ea, candidates);
    if location != 0 then
        return;
    end if;

    var indexlocation: uint8 := find_or_load_index(ea);
    location := allocate_reg_for_value(ea, REG_A);

    var opcode: uint8;
    if indexlocation == REG_Y then
        opcode := 0xB1; # LDA (zp), Y
    else
        opcode := 0xA1; # LDA (zp, X)
    end if;
    write_byte(opcode);
    write_cg_6502_zeropage_iop(ea.obj_id, 0);
end sub;

sub save_ptrval(location: uint8, ea: [EffectiveAddress])
    var indexlocation: uint8 := find_or_load_index(ea);

    var opcode: uint8;
    if indexlocation == REG_Y then
        opcode := 0x91; # STA (zp), Y
    else
        opcode := 0x81; # STA (zp, X)
    end if;
    write_byte(opcode);
    write_cg_6502_zeropage_iop(ea.obj_id, 0);
end sub;

sub find_or_load_value(ea: [EffectiveAddress], candidates: uint8): (location: uint8)
    if ea.type == EA_OBJVAL then
        location := find_or_load_objval(ea, candidates);
    elseif ea.type == EA_PTRVAL then
        location := find_or_load_ptrval(ea, candidates);
    else
        print("can't load ");
        print_ea(ea);
        print(" yet");
        halt();
    end if;
end sub;

sub save_value(location: uint8, ea: [EffectiveAddress])
    if ea.type == EA_OBJVAL then
        save_objval(location, ea);
    elseif ea.type == EA_PTRVAL then
        save_ptrval(location, ea);
    else
        print("can't save ");
        print_ea(ea);
        print(" yet");
        halt();
    end if;
end sub;

sub arch_gen_return()
    flush_cached_values(REG_MASK);
    write_byte(0x60); # RTS
end sub;

sub arch_gen_call(thing_id: uint16)
    flush_cached_values(REG_MASK);
    write_byte(0x20); # JSR
    write_address_iop(thing_id, 0);
end sub;

sub arch_gen_label()
    flush_cached_values(REG_MASK);
end sub;

sub arch_gen_goto(thing_id: uint16)
    flush_cached_values(REG_MASK);
    write_byte(0x4C); # JMP abs
    write_address_iop(thing_id, 0);
end sub;

sub make_value_precious_or_save_now(location: uint8, ea: [EffectiveAddress])
    value_is_cached_in_reg(ea, location);
    if (ea.type & EA_DEREF_BEFORE) != 0 then
        save_value(location, ea);
    else
        value_is_precious(ea);
    end if;
end sub;

sub arch_gen_copy_byte(iop: [BEIop])
    var location: uint8 := find_or_load_value(&iop.left, REG_A|REG_X|REG_Y);
    make_value_precious_or_save_now(location, &iop.dest);
end sub;

sub arch_gen_add_byte(iop: [BEIop])
    var location: uint8;
    var opcode: uint8;

    if is_number_thing(iop.right.obj_id) != 0 then
        var value: int32 := get_value_of_number(iop.right.obj_id);
        if (value == 1) or (value == -1) then
            location := find_or_load_value(&iop.left, REG_X|REG_Y);
            print_cache();
            value_in_location_will_be_replaced_with(location, &iop.dest);
            print_cache();

            if value == 1 then
                opcode := 0xE8; # INX
            else
                opcode := 0xC8; # INY
            end if;
            write_byte(opcode);

            make_value_precious_or_save_now(location, &iop.dest);
            return;
        end if;
    end if;

    location := find_or_load_value(&iop.left, REG_A);
    value_in_location_will_be_replaced_with(location, &iop.dest);

    if iop.right.type == EA_OBJVAL then
        opcode := 0x6D; # ADC abs
    else
        print("can't add ");
        print_ea(&iop.right);
        print(" yet");
        print_newline();
    end if;

    write_byte(0x18); # CLC
    write_6502_regular_op(opcode, &iop.right);

    make_value_precious_or_save_now(location, &iop.dest);
end sub;

sub arch_gen_copy_word_to_word(src: [EffectiveAddress], dest: [EffectiveAddress])
    write_byte(0x40); # JSR abs
    print("unsupported");
    halt();
#    write_address_iop(IOP_CG_COPY2, 0);
#    write_address_iop(src.thing_id, src.constant);
#    write_address_iop(dest.thing_id, dest.constant);
end sub;

#sub arch_gen_load_ptr_offset_bytevar_to_byte(ptr_id: uint16, offsetvar_id: uint16,
#        dest: [EffectiveAddress])
#    var ptr: [VariableThing] := find_thing(ptr_id) as [VariableThing];
#    #ptr.section := SECTION_POINTER;
#
#    var ea: EffectiveAddress[1];
#    ea[0].type := EA_VAR_PLUS_CONST;
#    ea[0].width := 2;
#    ea[0].thing_id := offsetvar_id;
#    ea[0].constant := 0;
#    var xreg: uint8 := find_or_load_value(&ea[0], REG_X);
#    write_byte(0xA1); # LDA ind,X
#    write_cg_6502_zeropage_iop(ptr_id, 0);
#    value_is_precious_in_reg(dest, REG_A);
#end sub;

#sub arch_gen_alu2op(iop: uint8,
#        left: [EffectiveAddress], right: [EffectiveAddress], dest: [EffectiveAddress]):
#        (matched: uint8)
#    matched := 1;
#
#    sub major_8bit(opcodebase: uint8)
#        var accumulator: uint8 := find_or_load_value(left, REG_A);
#        var buf: uint8[2];
#        if right.type == EA_VAR_PLUS_CONST then
#            # OPCODE abs
#            write_cg_6502_mem_iop(opcodebase | 0x0D, right.thing_id, right.constant);
#            value_is_precious_in_reg(dest, REG_A);
#        else
#            print("can't add this EA yet");
#            halt();
#        end if;
#    end sub;
#
#    if iop == IOP_ADDOP then
#        if left.width <= 1 then
#            write_byte(0x18); # CLC
#            major_8bit(0x60); # base ADC
#            return;
#        end if;
#    end if;
#
#    matched := 0;
#end sub;

#sub arch_gen_alu1op(iop: uint8, left: [EffectiveAddress], dest: [EffectiveAddress]): (matched: uint8)
#    matched := 1;
#
#    sub do_not()
#        var accumulator: uint8 := find_or_load_value(left, REG_A);
#        write_byte(0x4D); # EOR imm
#        write_byte(0xFF);
#        value_is_precious_in_reg(dest, REG_A);
#    end sub;
#
#    if iop == IOP_NOTOP then
#        if left.width == 1 then
#            do_not();
#            return;
#        end if;
#    end if;
#
#    matched := 0;
#end sub;

#sub arch_gen_conditional_fallthrough(iop: uint8,
#        left: [EffectiveAddress], right: [EffectiveAddress], inverted: uint8, label_id: uint16):
#        (matched: uint8)
#    matched := 1;
#
#    var opcode: uint8;
#    if (left.width <= 1) and (right.width <= 1) then
#        var reg: uint8 := find_or_load_value(left, REG_A|REG_X|REG_Y);
#        write_back_precious_values(REG_MASK);
#
#        if right.type == EA_NUMBER then
#            if reg == REG_A then
#                opcode := 0xC9; # CMP imm
#            elseif reg == REG_X then
#                opcode := 0xE0; # CPX imm
#            elseif reg == REG_Y then
#                opcode := 0xC0; # CPY imm
#            else
#                bad_register();
#            end if;
#            write_byte(opcode);
#            write_byte(right.constant);
#        else
#            print("can't compare these types yet");
#            halt();
#        end if;
#    else
#        matched := 0;
#        return;
#    end if;
#
#    if iop == IOP_BEQ then
#        opcode := 0xF0; # BNE
#    else
#        print("can't do this comparison yet");
#    end if;
#    if inverted == 1 then
#        opcode := opcode ^ 0x20;
#    end if;
#
#    flush_cached_values(REG_MASK);
#    write_cg_6502_conditional_iop(opcode, label_id);
#end sub;
