sub get_width_of_ea(ea: [EffectiveAddress]): (width: uint8)
    if (ea.type & EA_DEREF_AFTER) == 0 then
        width := 2;
    else
        var type: [WithElementsThing] := find_thing(get_type_of_thing(ea.obj_id)) as [WithElementsThing];
        if (type.thing_type == THING_ARRAYT) or (ea.type == EA_PTRVAL) then
            width := get_width_of_type(type.element_id);
        else
            width := get_width_of_thing(ea.obj_id);
        end if;
    end if;
end sub;

sub get_2op_widths(iop: [BEIop]): (srcw: uint8, destw: uint8)
    srcw := get_width_of_ea(&iop.left);
    destw := get_width_of_ea(&iop.dest);
    if srcw == 0 then
        srcw := destw;
    end if;
end sub;

sub get_3op_widths(iop: [BEIop]): (leftw: uint8, rightw: uint8, destw: uint8)
    leftw := get_width_of_ea(&iop.left);
    rightw := get_width_of_ea(&iop.right);
    destw := get_width_of_ea(&iop.dest);

    if leftw == 0 then
        leftw := destw;
    end if;
    if rightw == 0 then
        rightw := destw;
    end if;
end sub;

sub cant_do_2op(iop: [BEIop], op: [int8])
    print("can't do ");
    print_ea(&iop.left);
    print_char('(');
    print_i8(get_width_of_ea(&iop.left));
    print(") ");
    print(op);
    print(" -> ");
    print_ea(&iop.dest);
    print_char('(');
    print_i8(get_width_of_ea(&iop.dest));
    print(") width ");
    print_i8(iop.width);
    halt();
end sub;

sub insn_before(iop: [BEIop])
    arch_gen_before(&iop.left);
    arch_gen_before(&iop.right);
    arch_gen_before(&iop.dest);
end sub;

sub insn_after(iop: [BEIop])
    arch_gen_after(&iop.dest);
end sub;

sub try_copy(iop: [BEIop])
    insn_before(iop);

    var srcw: uint8;
    var destw: uint8;
    (srcw, destw) := get_2op_widths(iop);

    if destw == 1 then
        arch_gen_copy_byte(iop);
        insn_after(iop);
        return;
    end if;

    if destw == 2 then
        arch_gen_copy_word(iop);
        insn_after(iop);
        return;
    end if;

    cant_do_2op(iop, "");
end sub;

sub cant_do_3op(iop: [BEIop], op: [int8])
    print("can't do ");
    print_ea(&iop.left);
    print_char('(');
    print_i8(get_width_of_ea(&iop.left));
    print(") ");
    print(op);
    print(" ");
    print_ea(&iop.right);
    print_char('(');
    print_i8(get_width_of_ea(&iop.right));
    print(") -> ");
    print_ea(&iop.dest);
    print_char('(');
    print_i8(get_width_of_ea(&iop.dest));
    print(") width ");
    print_i8(iop.width);
    halt();
end sub;

sub try_add(iop: [BEIop])
    insn_before(iop);

    var leftw: uint8;
    var rightw: uint8;
    var destw: uint8;
    (leftw, rightw, destw) := get_3op_widths(iop);

    if iop.width == 1 then
        arch_gen_add_byte(iop);
        insn_after(iop);
        return;
    end if;

    if iop.width == 2 then
        arch_gen_add_word(iop);
        insn_after(iop);
        return;
    end if;

    cant_do_3op(iop, "+");
end sub;

sub try_sub(iop: [BEIop])
    insn_before(iop);

    if iop.width == 1 then
        arch_gen_sub_byte(iop);
        insn_after(iop);
        return;
    end if;

    cant_do_3op(iop, "-");
end sub;

sub try_sext(iop: [BEIop])
    insn_before(iop);

    if iop.width == 2 then
        arch_gen_sext_word(iop);
        insn_after(iop);
        return;
    end if;

    cant_do_2op(iop, "sext");
end sub;

sub try_zext(iop: [BEIop])
    insn_before(iop);

    if iop.width == 2 then
        arch_gen_zext_word(iop);
        insn_after(iop);
        return;
    end if;

    cant_do_2op(iop, "zext");
end sub;

sub try_conditional(ciop: [BEConditionalIop], liop: [LabelIop])
    arch_gen_before(&ciop.left);
    arch_gen_before(&ciop.right);

    if ciop.width == 1 then
        arch_gen_cmp_byte(ciop, liop);
        return;
    end if;

    if ciop.width == 2 then
        arch_gen_cmp_word(ciop, liop);
        return;
    end if;

    print("can't compare ");
    print_ea(&ciop.left);
    print_char('(');
    print_i8(get_width_of_ea(&ciop.left));
    print(") with (");
    print_ea(&ciop.right);
    print_char('(');
    print_i8(get_width_of_ea(&ciop.right));
    print(")");
    halt();
end sub;

sub global_rules(): (matched: uint8)
    matched := 1;
    arch_gen_beginning_of_instruction();

    if queue0.iop_kind == IOP_BE_COPY then
        try_copy(queue0 as [BEIop]);
        consume_iops(1);
        return;
    end if;

    if queue0.iop_kind == IOP_BE_ADD then
        try_add(queue0 as [BEIop]);
        consume_iops(1);
        return;
    end if;

    if queue0.iop_kind == IOP_BE_SUB then
        try_sub(queue0 as [BEIop]);
        consume_iops(1);
        return;
    end if;

    if queue0.iop_kind == IOP_BE_SEXT then
        try_sext(queue0 as [BEIop]);
        consume_iops(1);
        return;
    end if;

    if queue0.iop_kind == IOP_BE_ZEXT then
        try_zext(queue0 as [BEIop]);
        consume_iops(1);
        return;
    end if;

    if (queue0.iop_kind & IOP_TYPE_MASK) == IOP_TYPE_BACKEND_SPECIAL then
        if queue1.iop_kind != IOP_LABEL then
            print("conditionals must be followed by labels");
            halt();
        end if;

        try_conditional(queue0 as [BEConditionalIop], queue1 as [LabelIop]);

        # *Don't* consume the label; we want to generate it.
        consume_iops(1);
        return;
    end if;

    if queue0.iop_kind == IOP_RETURN then
        arch_gen_return();
        consume_iops(1);
        return;
    end if;

    if queue0.iop_kind == IOP_LABEL then
        arch_gen_label(queue0 as [LabelIop]);
        consume_iops(1);
        return;
    end if;

    if queue0.iop_kind == IOP_GOTO then
        arch_gen_goto(queue0 as [GotoIop]);
        consume_iops(1);
        return;
    end if;

    if queue0.iop_kind == IOP_CALL then
        arch_gen_call(queue0 as [CallIop]);
        consume_iops(1);
        return;
    end if;

    if (queue0.iop_kind == IOP_BYTES) or (queue0.iop_kind == IOP_ADDRESS) then
        write_iop(queue0);
        consume_iops(1);
        return;
    end if;

    matched := 0;
end sub;
