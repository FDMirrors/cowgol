sub print_raw_type_name(type_id: uint16)
    var brackets: uint8 := 0;
    loop
        var ptr_type: [PointerThing] := find_thing(type_id) as [PointerThing];
        if ptr_type.thing_type != THING_POINTERT then
            break;
        end if;
        brackets := brackets + 1;
        print_char('[');
        type_id := ptr_type.element_id;
    end loop;

    var id: uint16 := find_name_of_value(type_id);
    if id != 0 then
        show_identifier(id);
    else
        print("<anonymous>");
    end if;

    while brackets > 0 loop
        print_char(']');
        brackets := brackets - 1;
    end loop;
end sub;

sub print_type_name(type_id: uint16)
    var array_type: [ArrayThing] := find_thing(type_id) as [ArrayThing];
    if array_type.thing_type == THING_ARRAYT then
        print_raw_type_name(array_type.element_id);
        print_char('[');
        print_i16(array_type.element_count);
        print_char(']');
    else
        print_raw_type_name(type_id);
    end if;
end sub;

sub check_type_assignability(src_type_id: uint16, dest_type_id: uint16)
    # It's legal to assign any number to any other number.
    if (is_number_type_thing(src_type_id) != 0) and (is_number_type_thing(dest_type_id) != 0) then
        return;
    end if;

    # Otherwise, the type must match exactly.
    if src_type_id != dest_type_id then
        print_type_name(src_type_id);
        print(" cannot be assigned to ");
        print_type_name(dest_type_id);
        halt();
    end if;
end sub;

sub check_type_compatibility(left_type_id: uint16, right_type_id: uint16): (result_type_id: uint16)
    if left_type_id == right_type_id then
        result_type_id := left_type_id;
    elseif (is_number_type_thing(left_type_id) != 0)
        and (is_number_type_thing(right_type_id) != 0)
    then
        if get_width_of_type(left_type_id) < get_width_of_type(right_type_id) then
            result_type_id := right_type_id;
        else
            result_type_id := left_type_id;
        end if;
        return;
    else
        print_type_name(left_type_id);
        print(" and ");
        print_type_name(right_type_id);
        print(" are not compatible in this context");
        halt();
    end if;
end sub;

sub must_be_simplified(node: [Node])
    if node.iop != IOP_FEX_PUSH then
        print("operation on non-simplified node");
        halt();
    end if;
end sub;

sub alloc_ea_node(ea: [EffectiveAddress]): (node: [Node])
    node := alloc_node();
    node.iop := IOP_FEX_PUSH;
    node.flags := FLAG_RVALUE;
    node.type_id := uint16_type;
    copy_ea_ref(ea, &node.left);
end sub;

sub alloc_const_node(number_id: uint16): (node: [Node])
    node := alloc_node();
    node.iop := IOP_FEX_PUSH;
    node.flags := FLAG_RVALUE;
    node.type_id := uint16_type;
    node.left.obj_id := number_id;
    node.left.deref := 1;
end sub;

sub alloc_smallint_node(value: int16): (node: [Node])
    node := alloc_const_node(add_number_by_value(value));
end sub;

sub alloc_thing_node(thing_id: uint16): (node: [Node])
    node := alloc_node();
    node.iop := IOP_FEX_PUSH;
    node.type_id := get_type_of_thing(thing_id);
    node.left.obj_id := thing_id;
    node.left.deref := 1;
    ref_temporary(thing_id);
end sub;

sub gen_operator(beiop: uint8, left: [Node], right: [Node]): (dest: [Node])
    must_be_simplified(left);
    must_be_simplified(right);

    var node: [Node] := alloc_node();
    node.iop := beiop;
    node.type_id := uint16_type;
    node.flags := FLAG_RVALUE;
    copy_ea_ref(&left.left, &node.left);
    copy_ea_ref(&right.left, &node.right);

    dest := simplify_node_to_ea_and_deref(node);
end sub;

sub add_constant_to_ea(ea: [EffectiveAddress], num_id: uint16)
    var offsetnode: [Node];
    if ea.obj_id == 0 then
        offsetnode := alloc_smallint_node(0);
    else
        offsetnode := alloc_ea_node(ea);
    end if;

    var resultnode: [Node];
    if get_value_of_number(num_id) != 0 then
        var constnode: [Node] := alloc_const_node(num_id);
        resultnode := gen_operator(IOP_BE_ADD, offsetnode, constnode);
        deref_node(constnode);
    else
        resultnode := offsetnode;
        ref_node(resultnode);
    end if;

    must_be_simplified(resultnode);
    copy_ea_ref(&resultnode.left, ea);
    deref_node(offsetnode);
    deref_node(resultnode);
end sub;

sub process_subroutine(thing_id: uint16)
    var subroutine: [SubroutineThing] := find_thing(thing_id) as [SubroutineThing];
    init_tree();
    init_temporaries();
    current_namespace_id := subroutine.namespace_id;

    sub special_address(iop: [AddressIop])
        var thing: [Thing] := find_thing(iop.thing_id);
        if thing.thing_type == THING_IDENTIFIER then
            iop.thing_id := deref_symbol_or_fail(iop.thing_id);
            thing := find_thing(iop.thing_id);
        end if;

        if (thing.thing_type & THING_DATA) == 0 then
            print("not a data symbol");
            halt();
        end if;

        write_iop(iop as [Iop]);
    end sub;

    sub fex_push(iop: [FEPushIop])
        var thing: [Thing] := find_thing(iop.thing_id);
        if thing.thing_type == THING_IDENTIFIER then
            iop.thing_id := deref_symbol_or_fail(iop.thing_id);
            thing := find_thing(iop.thing_id);
        end if;

        var node: [Node] := push_empty_node();

        node.iop := IOP_FEX_PUSH;
        node.left.obj_id := iop.thing_id;
        node.left.deref := 1;
        if thing.thing_type == THING_NUMBER then
            node.type_id := constant_type;
            node.flags := FLAG_RVALUE;
        elseif thing.thing_type == THING_STRING then
            node.type_id := pointer_of(int8_type);
            # This is typed like a pointer, but generates code like an array.
            node.left.deref := 0;
            node.flags := FLAG_RVALUE;
        elseif (thing.thing_type & THING_TYPED) != 0 then
            var typed_thing: [TypedThing] := thing as [TypedThing];
            if typed_thing.type_id == 0 then
                print("forward reference to type inferred value");
                halt();
            end if;
            node.type_id := typed_thing.type_id;

            var type: [Thing] := find_thing(typed_thing.type_id);
            if (type.thing_type == THING_ARRAYT) or (type.thing_type == THING_RECORDT) then
                node.left.deref := 0;
            end if;
        else
            print("can't push things of type 0x");
            print_hex_i8(thing.thing_type);
            halt();
        end if;
        node.left.type_id := node.type_id;
    end sub;

    sub fe_swap()
        var n1: [Node] := pop();
        var n2: [Node] := pop();
        push_node(n1);
        push_node(n2);
    end sub;

    sub fe_assign()
        var src: [Node] := pop();
        var dest: [Node] := pop();

        if (dest.flags & FLAG_RVALUE) != 0 then
            print("cannot assign to rvalue");
            halt();
        end if;

        check_type_assignability(src.type_id, dest.type_id);
        src := simplify_constants_and_deref(src);
        src := arch_promote_to_new_node_and_deref(src, dest.type_id);

        if dest.iop == IOP_BE_DEREF then
            var iop: BESavePtrIop;
            iop.iop_kind := IOP_BE_SAVEPTR;
            iop.iop_size := iop@bytes;
            iop.width := get_width_of_type(dest.type_id);
            copy_ea(&dest.left, &iop.left);
            copy_ea(&dest.right, &iop.right);
            src := simplify_node_to_ea_and_deref(src);
            copy_ea(&src.left, &iop.value);
            write_iop(&iop as [Iop]);
        else
            dest := simplify_node_to_ea_and_deref(dest);
            arch_simplify_node_to(src, dest);
        end if;
        deref_node(src);
        deref_node(dest);
    end sub;

    sub fe_simple_alu2op(beiop: uint8)
        var right: [Node] := pop();
        var left: [Node] := pop();

        # if you change this, change the non-pointer case in addsub as well
        var dest_type_id: uint16 := check_type_compatibility(left.type_id, right.type_id);

        (left, right) := arch_promote_to_new_ea_nodes_and_deref(beiop, left, right, dest_type_id);
        right := simplify_node_to_ea_and_deref(right);
        left := simplify_node_to_ea_and_deref(left);

        var node: [Node] := push_empty_node();
        node.type_id := dest_type_id;
        node.iop := beiop;
        node.flags := FLAG_RVALUE;
        copy_ea_ref(&left.left, &node.left);
        copy_ea_ref(&right.left, &node.right);

        deref_node(right);
        deref_node(left);
    end sub;

    sub fe_simple_alu1op(beiop: uint8)
        var left: [Node] := simplify_node_to_ea_and_deref(pop());

        if (is_number_type_thing(left.type_id) == 0) then
            print("can't do this to non-numeric type ");
            print_type_name(left.type_id);
            halt();
        end if;

        left.iop := beiop;
        left.flags := FLAG_RVALUE;
        push_node(left);
    end sub;

    sub maybe_signed_biop(signed_beiop: uint8, unsigned_beiop: uint8): (beiop: uint8)
        var right: [Node] := peek(1);
        var left: [Node] := peek(2);

        if (is_signed_type_thing(left.type_id) != 0) or (is_signed_type_thing(right.type_id) != 0) then
            beiop := signed_beiop;
        else
            beiop := unsigned_beiop;
        end if;
    end sub;

    sub fe_addsub(beiop: uint8)
        var right: [Node] := pop();
        var left: [Node] := pop();

        var left_type: [PointerThing] := find_thing(left.type_id) as [PointerThing];
        var right_type: [PointerThing] := find_thing(right.type_id) as [PointerThing];
        var dest_type_id: uint16;
        if left_type.thing_type != THING_POINTERT then
            # this is the same as simple_alu2op above
            dest_type_id := check_type_compatibility(left.type_id, right.type_id);
        elseif (beiop == IOP_BE_SUB)
                and (left_type.thing_type == THING_POINTERT)
                and (right_type.thing_type == THING_POINTERT) then
            # Pointer difference.
            dest_type_id := uint16_type;
        elseif (beiop == IOP_BE_ADD)
                and (left_type.thing_type == THING_POINTERT)
                and (is_number_type_thing(right_type.thing_type) != 0) then
            # Pointer offsetting.
            dest_type_id := left.type_id;
        else
            halt();
        end if;

        (left, right) := arch_promote_to_new_ea_nodes_and_deref(beiop, left, right, dest_type_id);

        var node: [Node] := push_empty_node();
        node.iop := beiop;
        node.flags := FLAG_RVALUE;
        node.type_id := dest_type_id;
        copy_ea_ref(&left.left, &node.left);
        copy_ea_ref(&right.left, &node.right);

        deref_node(right);
        deref_node(left);
    end sub;

    sub fe_index()
        var right: [Node] := simplify_node_to_ea_and_deref(pop());
        var left: [Node] := simplify_node_to_ea_and_deref(pop());

        var left_type: [WithElementsThing] := find_thing(left.type_id) as [WithElementsThing];
        if (left_type.thing_type != THING_POINTERT) and (left_type.thing_type != THING_ARRAYT) then
            print_type_name(left.type_id);
            print(" is not indexable");
            halt();
        end if;
        var right_type: [TypeThing] := find_thing(right.type_id) as [TypeThing];
        var element_type: [TypeThing] := find_thing(left_type.element_id) as [TypeThing];

        if is_number_type_thing(right.type_id) == 0 then
            print("index must be numeric");
            halt();
        end if;

        var node: [Node] := push_empty_node();
        node.type_id := left_type.element_id;
        copy_ea_ref(&left.left, &node.left);

        print("* index type ");
        print_type_name(left_type.thing_type);
        print(" with ");
        print_ea(&right.left);
        print_newline();

        if (left_type.thing_type == THING_POINTERT) then
            node.iop := IOP_BE_DEREF;
            copy_ea_ref(&right.left, &node.right);
        elseif (left_type.thing_type == THING_ARRAYT) then
            node.iop := IOP_FEX_PUSH;
            if (right_type.thing_type == THING_CONSTANTT) then
                node.left.numoff_id := add_number_by_value(
                    get_value_of_number(left.left.numoff_id) +
                        get_value_of_number(right.left.obj_id) * element_type.width);
            else
                var new_delta_node: [Node];
                var delta_node: [Node] := alloc_ea_node(&right.left);
                if element_type.width != 1 then
                    var num_node: [Node] := alloc_const_node(add_number_by_value(element_type.width));
                    new_delta_node := gen_operator(IOP_BE_MUL, delta_node, num_node);
                    deref_node(num_node);
                    deref_node(delta_node);
                    delta_node := new_delta_node;
                end if;

                if left.left.varoff_id != 0 then
                    var old_delta_node: [Node] := alloc_thing_node(left.left.varoff_id);

                    print("* calculating new delta from ");
                    print_ea(&old_delta_node.left);
                    print(" and ");
                    print_ea(&delta_node.left);
                    print_newline();

                    new_delta_node := gen_operator(IOP_BE_ADD, old_delta_node, delta_node);
                    deref_node(old_delta_node);
                    deref_node(delta_node);
                    delta_node := new_delta_node;
                end if;

                delta_node := simplify_node_to_var_and_deref(delta_node);
                node.left.varoff_id := delta_node.left.obj_id;
                ref_temporary(node.left.varoff_id);
                deref_node(delta_node);
            end if;
        else
            print("only pointers or arrays can be indexed");
            halt();
        end if;
    end sub;

    sub fe_addressof()
        var node: [Node] := simplify_node_to_ea_and_deref(pop());

        if (node.flags & FLAG_RVALUE) != 0 then
            print("cannot take the address of an rvalue");
            halt();
        end if;

        node.type_id := pointer_of(node.type_id);
        node.left.deref := 0;

        push_node(node);
    end sub;

    sub fex_memberof(iop: [FEMemberIop])
        var node: [Node] := pop();

        var type_id: uint16 := node.type_id;
        var type: [WithElementsThing] := find_thing(type_id) as [WithElementsThing];

        while type.thing_type == THING_POINTERT loop
            print("* resolving pointer: ");
            print_type_name(type_id);
            print_newline();
            type_id := type.element_id;

            node := simplify_node_to_ea_and_deref(node);
            node.iop := IOP_BE_DEREF;
            node.right.deref := 1;
            node.right.type_id := type_id;
            node.right.obj_id := get_value_of_number(0);
            type := find_thing(type_id) as [WithElementsThing];
        end loop;

        var recordtype: [RecordThing] := type as [RecordThing];
        if recordtype.thing_type != THING_RECORDT then
            print_type_name(type_id);
            print(" is not a record type or a pointer to a record type");
            halt();
        end if;
        print("* found record: ");
        print_type_name(type_id);
        print_newline();

        var symbol_id: uint16 := find_symbol_recursively(iop.thing_id, recordtype.namespace_id);
        if symbol_id == 0 then
            show_identifier(iop.thing_id);
            print(" is not a member of ");
            print_type_name(type_id);
            halt();
        end if;
        var symbol: [SymbolThing] := find_thing(symbol_id) as [SymbolThing];
        var member: [MemberThing] := find_thing(symbol.value_id) as [MemberThing];
        var member_type_thing: [Thing] := find_thing(member.type_id);

        if node.iop == IOP_BE_DEREF then
            add_constant_to_ea(&node.right, add_number_by_value(member.offset));
        else
            node.left.numoff_id := add_number_by_value(
                get_value_of_number(node.left.numoff_id) + member.offset);
        end if;

        node.type_id := member.type_id;
        push_node(node);
    end sub;

    sub fex_parameter(direction: uint8, iop: [FEParameterIop])
        var thing_id: uint16 := iop.subroutine_id;
        var thing: [Thing] := find_thing(thing_id);
        if thing.thing_type == THING_IDENTIFIER then
            thing_id := deref_symbol_or_fail(thing_id);
            thing := find_thing(thing_id);
        end if;
        if thing.thing_type != THING_SUBROUTINE then
            print("subroutine_id not a subroutine");
            halt();
        end if;

        var parameter_id: uint16 := find_nth_parameter(
            thing_id, direction, iop.parameter);
        if parameter_id == 0 then
            print("invalid parameter id");
            halt();
        end if;
        var parameter: [ParameterThing] := find_thing(parameter_id) as [ParameterThing];

        var node: [Node] := push_empty_node();
        print("found subroutine 0x");
        print_hex_i16(thing_id);
        print(" direction ");
        print_i8(direction);
        print_newline();
        node.iop := IOP_FEX_PUSH;
        node.type_id := parameter.type_id;
        node.left.type_id := node.type_id;
        node.left.obj_id := parameter_id;
        node.left.deref := 1;
    end sub;

    sub fe_materialise()
        var src: [Node] := pop();

        var dest: [Node] := push_empty_node();
        dest.iop := IOP_FEX_PUSH;
        dest.flags := FLAG_RVALUE;
        dest.type_id := src.type_id;
        dest.left.obj_id := alloc_temporary(src.type_id);
        dest.left.deref := 1;

        arch_simplify_node_to(src, dest);
        deref_node(src);
    end sub;

    sub fe_conditional(iopkind: uint8, iop: [FEConditionalIop])
        var right: [Node] := simplify_node_to_ea_and_deref(pop());
        var left: [Node] := simplify_node_to_ea_and_deref(pop());

        var type_id: uint16 := check_type_compatibility(left.type_id, right.type_id);

        var beiop: BEConditionalIop;
        zero_memory(&beiop as [int8], BEConditionalIop@bytes);
        beiop.iop_size := BEConditionalIop@bytes;
        beiop.iop_kind := iopkind;
        beiop.width := get_width_of_type(type_id);
        beiop.iftrue_label := iop.iftrue_label;
        beiop.iffalse_label := iop.iffalse_label;
        copy_ea_ref(&left.left, &beiop.left);
        copy_ea_ref(&right.left, &beiop.right);

        arch_simplify_conditional_iop(&beiop);

        deref_temporary(beiop.left.obj_id);
        deref_temporary(beiop.left.varoff_id);
        deref_temporary(beiop.right.obj_id);
        deref_temporary(beiop.right.varoff_id);
        deref_node(left);
        deref_node(right);
    end sub;

    sub fe_cast(iop: [FECastIop])
        var node: [Node] := pop();

        var input_type: [TypeThing] := find_thing(node.type_id) as [TypeThing];
        var output_type: [TypeThing] := find_thing(iop.type_id) as [TypeThing];
        node.type_id := iop.type_id;
        node.flags := FLAG_RVALUE;
        push_node(node);
    end sub;

    sub fe_shift(signed_beiop: uint8, unsigned_beiop: uint8)
        var right: [Node] := simplify_node_to_ea_and_deref(pop());
        var left: [Node] := simplify_node_to_ea_and_deref(pop());

        var left_type: [TypeThing] := find_thing(left.type_id) as [TypeThing];
        if is_number_type_thing(left_type.thing_type) == 0 then
            print("can't shift non-numeric type ");
            print_type_name(left.type_id);
            halt();
        end if;

        var right_type: [TypeThing] := find_thing(right.type_id) as [TypeThing];
        if is_number_type_thing(right_type.thing_type) == 0 then
            print("can't shift by non-numeric type ");
            print_type_name(left.type_id);
            halt();
        end if;

        var node: [Node] := push_empty_node();
        if is_signed_type_thing(left_type.thing_type) != 0 then
            node.iop := signed_beiop;
        else
            node.iop := unsigned_beiop;
        end if;
        node.flags := FLAG_RVALUE;
        copy_ea_ref(&left.left, &node.left);
        copy_ea_ref(&right.left, &node.right);
        node.type_id := left.type_id;

        deref_node(left);
        deref_node(right);
    end sub;

    sub fe_call(iop: [CallIop])
        var thing: [SubroutineThing] := find_thing(iop.thing_id) as [SubroutineThing];
        if thing.thing_type == THING_IDENTIFIER then
            iop.thing_id := deref_symbol_or_fail(iop.thing_id);
            thing := find_thing(iop.thing_id) as [SubroutineThing];
        end if;
        if thing.thing_type != THING_SUBROUTINE then
            print("subroutine_id not pointing at subroutine");
            halt();
        end if;

        if (thing.input_parameter_count != iop.input_parameter_count)
                or (thing.output_parameter_count != iop.output_parameter_count) then
            show_name_of(iop.thing_id);
            print(" has ");
            print_i8(thing.input_parameter_count);
            print(" inputs and ");
            print_i8(thing.output_parameter_count);
            print(" outputs, but was called with ");
            print_i8(iop.input_parameter_count);
            print(" and ");
            print_i8(iop.output_parameter_count);
            halt();
        end if;

        write_iop(iop as [Iop]);
    end sub;

    sub fe_bytesof()
        var left: [Node] := pop();
        var width: uint16 := get_width_of_type(left.type_id);

        var node: [Node] := push_empty_node();
        node.iop := IOP_FEX_PUSH;
        node.left.obj_id := add_number_by_value(width);
        node.left.deref := 1;
        node.type_id := constant_type;
        node.flags := FLAG_RVALUE;

        deref_node(left);
    end sub;

    sub fe_sizeof()
        var left: [Node] := pop();

        var left_type: [ArrayThing] := find_thing(left.type_id) as [ArrayThing];
        if (left_type.thing_type != THING_ARRAYT) then
            print("@size only works on arrays");
            halt();
        end if;

        var node: [Node] := push_empty_node();
        node.iop := IOP_FEX_PUSH;
        node.left.obj_id := add_number_by_value(left_type.element_count);
        node.left.deref := 1;
        node.type_id := constant_type;
        node.flags := FLAG_RVALUE;

        deref_node(left);
    end sub;

    loop
        var iop: [Iop] := read_iop();
        var ioptype: uint8 := iop.iop_kind & IOP_TYPE_MASK;
        print_newline();
        print_stack();
        print("* read iop 0x");
        print_hex_i8(iop.iop_kind);
        print_newline();

        if iop.iop_kind == IOP_END then
            break;
        elseif iop.iop_kind == IOP_CALL then
            fe_call(iop as [CallIop]);
        elseif iop.iop_kind == IOP_ADDRESS then
            special_address(iop as [AddressIop]);
        elseif ioptype == IOP_TYPE_UNTYPED then
            write_iop(iop);
        elseif iop.iop_kind == IOP_FE_SWAP then
            fe_swap();
        elseif iop.iop_kind == IOP_FEX_PUSH then
            fex_push(iop as [FEPushIop]);
        elseif iop.iop_kind == IOP_FE_ASSIGN then
            fe_assign();
        elseif iop.iop_kind == IOP_FE_ADD then
            fe_addsub(IOP_BE_ADD);
        elseif iop.iop_kind == IOP_FE_SUB then
            fe_addsub(IOP_BE_SUB);
        elseif iop.iop_kind == IOP_FE_MUL then
            fe_simple_alu2op(IOP_BE_MUL);
        elseif iop.iop_kind == IOP_FE_AND then
            fe_simple_alu2op(IOP_BE_AND);
        elseif iop.iop_kind == IOP_FE_OR then
            fe_simple_alu2op(IOP_BE_OR);
        elseif iop.iop_kind == IOP_FE_EOR then
            fe_simple_alu2op(IOP_BE_EOR);
        elseif iop.iop_kind == IOP_FE_DIV then
            fe_simple_alu2op(maybe_signed_biop(IOP_BE_DIVS, IOP_BE_DIVU));
        elseif iop.iop_kind == IOP_FE_MOD then
            fe_simple_alu2op(maybe_signed_biop(IOP_BE_MODS, IOP_BE_MODU));
        elseif iop.iop_kind == IOP_FE_NEG then
            fe_simple_alu1op(IOP_BE_NEG);
        elseif iop.iop_kind == IOP_FE_NOT then
            fe_simple_alu1op(IOP_BE_NOT);
        elseif (iop.iop_kind == IOP_FE_LSHIFT) then
            fe_shift(IOP_BE_LSL, IOP_BE_LSL);
        elseif (iop.iop_kind == IOP_FE_RSHIFT) then
            fe_shift(IOP_BE_ASR, IOP_BE_LSR);
        elseif iop.iop_kind == IOP_FE_INDEX then
            fe_index();
        elseif iop.iop_kind == IOP_FEX_INPUTPARAM then
            fex_parameter(DIRECTION_IN, iop as [FEParameterIop]);
        elseif iop.iop_kind == IOP_FEX_OUTPUTPARAM then
            fex_parameter(DIRECTION_OUT, iop as [FEParameterIop]);
        elseif iop.iop_kind == IOP_FE_MATERIALISE then
            fe_materialise();
        elseif iop.iop_kind == IOP_FE_ADDRESSOF then
            fe_addressof();
        elseif iop.iop_kind == IOP_FEX_MEMBEROF then
            fex_memberof(iop as [FEMemberIop]);
        elseif iop.iop_kind == IOP_FE_BYTESOF then
            fe_bytesof();
        elseif iop.iop_kind == IOP_FE_SIZEOF then
            fe_sizeof();
        elseif iop.iop_kind == IOP_FEX_BEQ then
            fe_conditional(IOP_BE_BEQ, iop as [FEConditionalIop]);
        elseif iop.iop_kind == IOP_FEX_BGT then
            fe_conditional(maybe_signed_biop(IOP_BE_BGTS, IOP_BE_BGTU),
                iop as [FEConditionalIop]);
        elseif iop.iop_kind == IOP_FEX_BLT then
            fe_conditional(maybe_signed_biop(IOP_BE_BLTS, IOP_BE_BLTU),
                iop as [FEConditionalIop]);
        elseif iop.iop_kind == IOP_FEX_CAST then
            fe_cast(iop as [FECastIop]);
        else
            print("unsupported iop 0x");
            print_hex_i8(iop.iop_kind);
            halt();
        end if;
    end loop;
    write_untyped_iop(IOP_END);
end sub;

sub process()
    loop
        var iheader: [IHeader] := read_iop_header();
        if iheader.thing_id == 0 then
            break;
        end if;

        write_iop_header(iheader);
        process_subroutine(iheader.thing_id);
    end loop;
    write_terminating_iop_header();
end sub;

process();
save_thing_table("things.dat");
