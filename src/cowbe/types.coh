typedef LabelRef is uint16;
typedef Arith is int32;
typedef Size is uint16;

record VarSymbol is
	type: [Type];
	subr: [Subroutine]; # null for a member
	next_parameter: [Symbol]; # for lists of parameters
	externname: string;
	offset: Size;
end record;

record Symbol is
	typedata @at(0): [Type];
	vardata @at(0): [VarSymbol];
	constant @at(0): Arith;
	alias @at(0): [Symbol];

	name: string;
	namespace: [Namespace];
	next: [Symbol];
	kind: uint8;
	wsid: uint8;
end record;

const SUB_HAS_IMPL          := 0b001;
const SUB_IS_INTERFACE      := 0b010;
const SUB_IS_IMPLEMENTATION := 0b100;

record Subroutine is
	symbol: [Symbol];
	parent: [Subroutine];
	intfsubr: [Subroutine];
	id: uint16;
	workspace: Size[4];
	arch: [ArchSubroutine];
	num_input_parameters: uint8;
	num_output_parameters: uint8;
	flags: uint8;
end record;


var current_subr: [Subroutine];
var next_label_id: uint16 := 0;
var next_subr_id: uint16 := 0;

const REG_SAME_AS_INSTRUCTION_RESULT := -1;

# Forward references

@decl sub PushNode(node: [Node]);
@decl sub PopNode(): (node: [Node]);
@decl sub NextNode(): (node: [Node]);
var nodes: [Node][16];
var next_node := &nodes[0];

@decl sub Discard(node: [Node]);

@decl sub AllocNewSymbol(): (symbol: [Symbol]);
@decl sub FreeSymbol(symbol: [Symbol]);

@decl sub AllocNewType(): (type: [Type]);
@decl sub FreeType(type: [Type]);

