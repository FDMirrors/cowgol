record IHeader
    thing_id: uint16;
    section: uint8;
end record;

record Iop
    iop_size: uint8;
    iop_kind: uint8;
    payload: int8[0];
end record;


# Important note with regard to the stack machine: there is no DUP instruction.
# The code generator relies on every value on the stack being pushed exactly
# once and popped exactly once (so as to make it easy to determine the lifespan
# of nodes in the operator tree).

const IOP_TYPE_MASK        := 0b1110_0000;

# These are valid for all stages.
const IOP_TYPE_UNTYPED     := 0b0000_0000;
const IOP_END              := 0b0000_0000;
const IOP_LABEL            := 0b0000_0001;
const IOP_STRING           := 0b0000_0010;
const IOP_RETURN           := 0b0000_0011;
const IOP_GOTO             := 0b0000_0100;
const IOP_FILENAME         := 0b0000_0101;
const IOP_LINENUMBER       := 0b0000_0110;
const IOP_BYTES            := 0b0000_0111;
const IOP_ADDRESS          := 0b0000_1000;
const IOP_CALL             := 0b0000_1001;

# Front-end opcodes: this is the pure stack machine architecture emitted by the
# compiler. These are all Iops, with no payload.
const IOP_TYPE_FE          := 0b0010_0000;
const IOP_FE_SWAP          := 0b0010_0001; # ( a b -- b a )
const IOP_FE_ASSIGN        := 0b0010_0010; # ( dest src -- )
const IOP_FE_MATERIALISE   := 0b0010_0011; # ( value -- result )
const IOP_FE_ADDRESSOF     := 0b0010_0100; # ( ea -- ptr-to-ea )
const IOP_FE_BYTESOF       := 0b0010_0101; # ( ea -- byte-size )
const IOP_FE_SIZEOF        := 0b0010_0110; # ( ea -- member-count )
const IOP_FE_OFFSET        := 0b0010_1001; # ( ea byte-offset -- ea )
const IOP_FE_INDEX         := 0b0010_1010; # ( ea scale-offset -- ea )
const IOP_FE_ADD           := 0b0010_1110; # ( left right -- result )
const IOP_FE_SUB           := 0b0010_1111; # ( left right -- result )
const IOP_FE_MUL           := 0b0011_0000; # ( left right -- result )
const IOP_FE_DIV           := 0b0011_0001; # ( left right -- result )
const IOP_FE_MOD           := 0b0011_0010; # ( left right -- result )
const IOP_FE_AND           := 0b0011_0011; # ( left right -- result )
const IOP_FE_OR            := 0b0011_0100; # ( left right -- result )
const IOP_FE_EOR           := 0b0011_0101; # ( left right -- result )
const IOP_FE_NEG           := 0b0011_0110; # ( value -- result )
const IOP_FE_NOT           := 0b0011_0111; # ( value -- result )
const IOP_FE_ZEXT          := 0b0011_1001; # ( value -- result )
const IOP_FE_SEXT          := 0b0011_1010; # ( value -- result )
const IOP_FE_LSHIFT        := 0b0011_1110; # ( value count -- result )
const IOP_FE_RSHIFT        := 0b0011_1111; # ( value count -- result )

# Additional, special front end iops. These all have payload.
const IOP_TYPE_FEX         := 0b0100_0000;
const IOP_FEX_PUSH         := 0b0100_0000; # ( -- ea ): FEPushIop
const IOP_FEX_INPUTPARAM   := 0b0100_0001; # ( -- ea ): FEParameterIop
const IOP_FEX_OUTPUTPARAM  := 0b0100_0010; # ( -- ea ): FEParameterIop
const IOP_FEX_CAST         := 0b0100_0011; # ( value -- result ): FECastIop
const IOP_FEX_MEMBER       := 0b0100_0100; # ( ea -- ea ): FEMemberIop
const IOP_FEX_BEQ          := 0b0100_0101; # ( left right -- ): FEConditionalIop
const IOP_FEX_BLT          := 0b0100_0110; # ( left right -- ): FEConditionalIop
const IOP_FEX_BGT          := 0b0100_0111; # ( left right -- ): FEConditionalIop

# Backend opcodes, after type checking and conversion out of front end format.
# This is the memory-memory architecture which the real code generator converts
# into machine code.
const IOP_TYPE_BACKEND     := 0b0110_0000;
const IOP_BE_COPY          := 0b0110_0000;

const IOP_TYPE_CODEGEN     := 0b1110_0000;
const IOP_CG_6502_ZEROPAGE := 0b1110_0011;
const IOP_CG_6502_COND     := 0b1110_0100;
const IOP_CG_6502_MEM      := 0b1110_0101;

record FilenameIop: Iop
    thing_id: uint16;
end record;

record LinenumberIop: Iop
    line_number: uint16;
end record;

record LabelIop: Iop
    label_id: uint16;
end record;

record StringIop: Iop
    string_id: uint16;
end record;

record CallIop: Iop
    thing_id: uint16;
    input_parameter_count: uint8;
    output_parameter_count: uint8;
end record;

record GotoIop: Iop
    label_id: uint16;
end record;

record BytesIop: Iop
    byte_count: uint8;
    bytes: uint8[8];
end record;

record AddressIop: Iop
    thing_id: uint16;
    offset: uint16;
end record;

record FEPushIop: Iop
    thing_id: uint16;
end record;

record FEParameterIop: Iop
    subroutine_id: uint16;
    parameter: uint8;
end record;

record FEMemberIop: Iop
    thing_id: uint16;
end record;

record FECastIop: Iop
    type_id: uint16;
end record;

record FEConditionalIop: Iop
    iftrue_label_id: uint16;
    iffalse_label_id: uint16;
end record;

const EA_DEREF := 0b0000_0001; # treat value as pointer, deref after computing EA

record EffectiveAddress
    flags: uint8;
    vara_id: uint16;
    varb_id: uint16;
    const: int16;
end record;

record BEIop: Iop
    width: uint8;
    src: EffectiveAddress;
    dest: EffectiveAddress;
end record;

record CG6502MemIop: Iop
    opcode: uint8;
    thing_id: uint16;
    offset: uint16;
end record;

record CG6502ZeroPageIop: Iop
    thing_id: uint16;
    offset: uint16;
end record;

record CG6502ConditionalIop: Iop
    opcode: uint8;
    label_id: uint16;
end record;

sub copy_ea(src: [EffectiveAddress], dest: [EffectiveAddress])
    copy_memory(src as [int8], dest as [int8], EffectiveAddress@bytes);
end sub;

sub zero_ea(ea: [EffectiveAddress])
    zero_memory(ea as [int8], EffectiveAddress@bytes);
end sub;

sub print_ea(ea: [EffectiveAddress])
    if (ea.flags & EA_DEREF) != 0 then
        print_char('[');
    end if;
    print("(0x");
    print_hex_i16(ea.vara_id);
    if ea.varb_id != 0 then
        print("+0x");
        print_hex_i16(ea.varb_id);
    end if;
    if ea.const != 0 then
        print("+#0x");
        print_hex_i16(ea.const);
    end if;
    print_char(')');
    if (ea.flags & EA_DEREF) != 0 then
        print_char(']');
    end if;
end sub;

sub resolve_label_id(ref_id: uint16): (label_id: uint16)
    label_id := ref_id;
    loop
        var label: [LabelThing] := find_thing(label_id) as [LabelThing];
        if label.thing_type == THING_LABEL then
            break;
        end if;

        label_id := label.target;
    end loop;
end sub;

