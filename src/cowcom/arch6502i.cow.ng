%{
    var uint32_type: [Symbol];
    var int32_type: [Symbol];
    var uint16_type: [Symbol];
    var int16_type: [Symbol];
    var uint8_type: [Symbol];
    var int8_type: [Symbol];
    var intptr_type: [Symbol];

    record ArchSubroutine is
        end_label: LabelRef;
    end record;

    record Extern is
        name: string;
        id: uint16;
        next: [Extern];
    end record;

    var externs: [Extern] := (0 as [Extern]);

    sub ArchAlignUp(value: Size, alignment: uint8): (newvalue: Size) is
        newvalue := value;
    end sub;

    sub ArchInitTypes() is
        uint32_type := MakeNumberType(4, 1, 0, "uint32");
        int32_type := MakeNumberType(4, 1, 1, "int32");
        uint16_type := MakeNumberType(2, 1, 0, "uint16");
        int16_type := MakeNumberType(2, 1, 1, "int16");
        uint8_type := MakeNumberType(1, 1, 0, "uint8");
        int8_type := MakeNumberType(1, 1, 1, "int8");

        intptr_type := uint16_type;
        AddAliasString("intptr", intptr_type);
    end sub;

    sub ArchGuessIntType(min: Arith, max: Arith): (symbol: [Symbol]) is
        if (min >= 0) and (max <= 255) then
            symbol := uint8_type;
        elseif (min >= -128) and (max <= 127) then
            symbol := int8_type;
        elseif (min >= 0) and (max <= 65535) then
            symbol := uint16_type;
        elseif (min >= -32768) and (max <= 32767) then
            symbol := int16_type;
        elseif (min >= 0) then
            symbol := uint32_type;
        else
            symbol := int32_type;
        end if;
    end sub;

    sub ArchInitVariable(symbol: [Symbol]) is
        var subr := symbol.vardata.subr;
        var offset := subr.workspace[0];
        symbol.vardata.offset := offset;
        subr.workspace[0] := offset + symbol.vardata.type.typedata.width;
    end sub;

    sub ArchInitMember(containing: [Symbol], member: [Symbol], position: Size) is
        member.vardata.offset := position;
        position := position + member.vardata.type.typedata.width;
        if position > containing.typedata.width then
            containing.typedata.width := position;
        end if;
    end sub;

	sub ArchEndInstruction() is
	end sub;

	sub ArchEndGroup() is
	end sub;

	sub ArchEmitMove(src: RegId, dest: RegId) is
		SimpleError("can't move");
	end sub;

    sub GetHelper(name: string): (e: [Extern]) is
        e := externs;
        while e != (0 as [Extern]) loop
            if StrCmp(e.name, name) == 0 then
                break;
            end if;
            e := e.next;
        end loop;

        if e == (0 as [Extern]) then
            e := Alloc(@bytesof Extern) as [Extern];
            e.name := name;
            e.id := AllocSubrId();
            e.next := externs;
            externs := e;

            EmitterDeclareExternalSubroutine(e.id, name);
        end if;
    end sub;

	sub E_dw() is
		E("\t.word ");
	end sub;

    sub E_label(label: LabelRef) is
        E_labelref(label);
        E(":\n");
    end sub;

    sub E_new_label(): (lid: uint16) is
        lid := AllocLabel();
        E_label(lid);
    end sub;

	sub E_wsrefi(sym: [Symbol], off: Size) is
		E_dw();
		E_wsref(sym.vardata.subr.id, 0, sym.vardata.offset + off);
		E_nl();
	end sub;

	sub E_callid(id: uint16) is
		E_dw();
		E_b8(COO_ESCAPE_SUBREF);
		E_b16(id);
		E_nl();
	end sub;

    # Does not persist the name; only call this with constant strings.
    sub E_callhelper(name: string) is
        var e := GetHelper(name);

        EmitterPushChunk();
        E_b16(current_subr.id);
        E_b16(e.id);
        EmitterPopChunk('R');

		E_callid(e.id);
    end sub;

	sub E_store8(sym: [Symbol], off: Size) is
		E_callhelper("_store8");
		E_wsrefi(sym, off);
	end sub;

	sub E_store16(sym: [Symbol], off: Size) is
		E_callhelper("_store16");
		E_wsrefi(sym, off);
	end sub;

	sub E_store32(sym: [Symbol], off: Size) is
		E_callhelper("_store32");
		E_wsrefi(sym, off);
	end sub;

	sub E_load8(sym: [Symbol], off: Size) is
		E_callhelper("_load8");
		E_wsrefi(sym, off);
	end sub;

	sub E_load16(sym: [Symbol], off: Size) is
		E_callhelper("_load16");
		E_wsrefi(sym, off);
	end sub;

	sub E_load32(sym: [Symbol], off: Size) is
		E_callhelper("_load32");
		E_wsrefi(sym, off);
	end sub;
%}

wordsize uint8;

register s8;
register s16;
register s32;

regdata s8  stacked;
regdata s16 stacked;
regdata s16 stacked;

// --- Core stuff -----------------------------------------------------------

gen STARTFILE();
gen ENDFILE();

// --- Subroutines ----------------------------------------------------------

gen STARTSUB()
{
    current_subr.arch := Alloc(@bytesof ArchSubroutine) as [ArchSubroutine];
    current_subr.arch.end_label := AllocLabel();

    EmitterPushChunk();
    E_b16(current_subr.id);

    E("\n\n\t; ");
    E(current_subr.name);
    E_nl();

    E_b8(COO_ESCAPE_THISSUB);
    E(":\n");

    var count := current_subr.num_input_parameters;
    while count != 0 loop
        count := count - 1;
        var param := GetInputParameter(current_subr, count);

        case param.vardata.type.typedata.width is
            when 1: E_store8(param, 0);
			when 2: E_store16(param, 0);
			when 4: E_store32(param, 0);
        end case;
    end loop;
}

gen ENDSUB()
{
	E_label(current_subr.arch.end_label);

    var i: uint8 := 0;
    var count := current_subr.num_output_parameters;
    while i != count loop
        var param := GetOutputParameter(current_subr, i);

        var cache: RegId;
        case param.vardata.type.typedata.width is
            when 1: E_load8(param, 0);
            when 2: E_load16(param, 0);
            when 4: E_load32(param, 0);
		end case;

        i := i + 1;
    end loop;

    EmitterPopChunk('S');

    i := 0;
    while i != 4 loop
        EmitterDeclareWorkspace(current_subr, i, current_subr.workspace[i]);
        i := i + 1;
    end loop;
}

gen RETURN() { E_callhelper("_return"); }

