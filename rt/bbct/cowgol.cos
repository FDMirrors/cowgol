&X _mul4
&X _divu4
&X _remu4
&X _cmp4
&X _cmps4

&X _lshift1
; Shifts A left Y bits.
``:
	dey
	bmi ``_exit
	asl
	jmp ``
``_exit:
	rts

&X _rshiftu1
; Logical shift A right Y bits.
``:
	dey
	bmi ``_exit
	lsr
	jmp ``
``_exit:
	rts

&X _rshifts1
; Arithmetic shift A right Y bits.
``:
	dey
	bmi ``_exit
	cmp #$80
	ror
	jmp ``
``_exit:
	rts

&X _lshift2
&W _lshift2 1 2
; Shifts AX left Y bits.
``:
	sta `$_lshift2.1.0
	stx `$_lshift2.1.1
``_loop:
	dey
	bmi ``_exit
	asl `$_lshift2.1.0
	rol `$_lshift2.1.1
	jmp ``_loop
``_exit:
	lda `$_lshift2.1.0
	ldx `$_lshift2.1.1
	rts

&X _rshiftu2
&W _rshiftu2 1 2
; Logical shifts AX right Y bits.
``:
	sta `$_lshift2.1.0
	stx `$_lshift2.1.1
``_loop:
	dey
	bmi ``_exit
	lsr `$_lshift2.1.1
	ror `$_lshift2.1.0
	jmp ``_loop
``_exit:
	lda `$_lshift2.1.0
	ldx `$_lshift2.1.1
	rts

&X _rshifts2
&W _rshifts2 1 2
; Arithmetic shifts AX right Y bits.
``:
	sta `$_lshift2.1.0
	stx `$_lshift2.1.1
``_loop:
	dey
	bmi ``_exit
	lda `$_lshift2.1.1
	cmp #$80
	ror `$_lshift2.1.1
	ror `$_lshift2.1.0
	jmp ``_loop
``_exit:
	lda `$_lshift2.1.0
	ldx `$_lshift2.1.1
	rts

&S shiftsmem
&W shiftsmem 1 6

&S startshift
``:
	sta `$shiftsmem.1.0
	stx `$shiftsmem.1.1
	tya
	tax
	ldy #3
-
	lda (`$shiftsmem.1.0), y
	sta `$shiftsmem.1.2, y
	dey
	bpl -
	rts

&S endshift
``:
	ldy #3
-
	lda `$.1.2, y
	sta (`$.1.0), y
	dey
	bpl -
	rts

&X _lshift4
; Shifts [AX] left Y bits.
``:
	jsr `startshift
``_loop:
	dex
	bmi `endshift
	asl `$shiftsmem.1.2
	rol `$shiftsmem.1.3
	rol `$shiftsmem.1.4
	rol `$shiftsmem.1.5
	jmp ``_loop

&X _rshiftu4
; Logical shifts [AX] right Y bits.
``:
	jsr `startshift
``_loop:
	dex
	bmi `endshift
	lsr `$shiftsmem.1.5
	ror `$shiftsmem.1.4
	ror `$shiftsmem.1.3
	ror `$shiftsmem.1.2
	jmp ``_loop

&X _rshifts4
; Arithmetic shifts [AX] right Y bits.
``:
	jsr `startshift
``_loop:
	dex
	bmi `endshift
	lda `$shiftsmem.1.5
	cmp #$80
	ror `$shiftsmem.1.5
	ror `$shiftsmem.1.4
	ror `$shiftsmem.1.3
	ror `$shiftsmem.1.2
	jmp ``_loop

&X _mul1
&W _mul1 1 2
; Multiplies A = A * X.
``:
	sta `$.1.0
	stx `$.1.1
	lda #0
	ldx #8
	lsr `$.1.0
``_loop:
	bcc ``_noadd
	clc
	adc `$.1.1
``_noadd:
	ror
	ror `$.1.0
	dex
	bne ``_loop
	lda `$.1.0
	rts

&X _divu1
&W _divu1 1 2
; Unsigned divide of A = A / X, remainder in X.
``:
	sta `$.1.0
	stx `$.1.1
	lda #0
	ldx #8
	asl `$.1.0
``_1:
	rol
	cmp `$.1.1
	bcc ``_2
	sbc `$.1.1
``_2:
	rol `$.1.0
	dex
	bne ``_1
	tax
	lda `$.1.0
	rts

&X _mul2
&W _mul2 1 5
; Multiplies `$.1.0to1 * XA. Returns XA.
``:
	sta `$.1.2+0
	stx `$.1.2+1
	lda #0
	sta `$.1.4
	ldy #$11
	clc
``_loop:
	ror `$.1.4
	ror
	ror `$.1.0+1
	ror `$.1.0+0
	bcc ``_2
	clc
	adc `$.1.2+0
	pha
	lda `$.1.2+1
	adc `$.1.4
	sta `$.1.4
	pla
``_2:
	dey
	bne ``_loop
	lda `$.1.0+0
	ldx `$.1.0+1
	rts

&X _divu2
&W _divu2 1 6
; Unsigned division of `$.1.0to1 / XA. Result is in XA, remainder in `$.1.4to5.
``:
	sta `$.1.2 ; RHS
	stx `$.1.3
	lda #0
	sta `$.1.4 ; remainder
	sta `$.1.5
	ldx #16
``_loop
	asl `$.1.0 ; LHS
	rol `$.1.1
	rol `$.1.4 ; remainder
	rol `$.1.5
	lda `$.1.4
	sec
	sbc `$.1.2 ; RHS
	tay
	lda `$.1.5
	sbc `$.1.3
	bcc +
	sty `$.1.4
	sta `$.1.5
	inc `$.1.0
+
	dex
	bne ``_loop
	lda `$.1.0
	ldx `$.1.1
	rts

