%[
	record MemOp is
		sym: [Symbol];
		off: Size;
	end record;
		
	record ImmOp is
		value: Arith;
	end record;

	record Operand is
		mem @at(0): MemOp;
		imm @at(0): ImmOp;
	end record;
%]

%{
	sub ArchAlignUp(value: Size, alignment: uint8): (newvalue: Size) is
		newvalue := value;
	end sub;

	sub E_symref(sym: [Symbol], off: Size) is
		if sym.wsid == WSID_STATIC then
			E_wsref(sym.subr.id, sym.wsid, sym.off);
			if off != 0 then
				E_i16(off as int16);
			end if;
		else
			E_wsref(sym.subr.id, sym.wsid, sym.off + off);
		end if;
	end sub;

	sub R_flushall() is
		RegCacheFlush(ALL_REGS);
	end sub;

	sub R_flush(reg: RegId) is
		RegCacheFlush(FindConflictingRegisters(reg));
	end sub;

	sub E_label(label: LabelRef) is
		R_flushall();
		E_labelref(label);
		E(":\n");
	end sub;

	sub loreg(reg: RegId): (loreg: RegId) is
		case reg is
			when REG_DXAX: loreg := REG_AL;
			when REG_BXCX: loreg := REG_CL;
			when REG_AL: loreg := REG_AL;
			when REG_BL: loreg := REG_BL;
			when REG_CL: loreg := REG_CL;
			when REG_DL: loreg := REG_DL;
			when REG_AX: loreg := REG_AL;
			when REG_BX: loreg := REG_BL;
			when REG_CX: loreg := REG_CL;
			when REG_DX: loreg := REG_DL;
			when else:
				SimpleError("bad loreg");
		end case;
	end sub;

	sub lowordreg(reg: RegId): (lowordreg: RegId) is
		case reg is
			when REG_DXAX: lowordreg := REG_AX;
			when REG_BXCX: lowordreg := REG_CX;
			when REG_AL: lowordreg := REG_AX;
			when REG_BL: lowordreg := REG_BX;
			when REG_CL: lowordreg := REG_CX;
			when REG_DL: lowordreg := REG_DX;
			when REG_AX: lowordreg := REG_AX;
			when REG_BX: lowordreg := REG_BX;
			when REG_CX: lowordreg := REG_CX;
			when REG_DX: lowordreg := REG_DX;
			when else:
				SimpleError("bad lowordreg");
		end case;
	end sub;

	sub hiwordreg(reg: RegId): (hiwordreg: RegId) is
		case reg is
			when REG_DXAX: hiwordreg := REG_DX;
			when REG_BXCX: hiwordreg := REG_BX;
			when REG_AL: hiwordreg := REG_AX;
			when REG_BL: hiwordreg := REG_BX;
			when REG_CL: hiwordreg := REG_CX;
			when REG_DL: hiwordreg := REG_DX;
			when REG_AX: hiwordreg := REG_AX;
			when REG_BX: hiwordreg := REG_BX;
			when REG_CX: hiwordreg := REG_CX;
			when REG_DX: hiwordreg := REG_DX;
			when else:
				SimpleError("bad lowordreg");
		end case;
	end sub;

	sub E_reg(reg: RegId) is
		case reg is
			when REG_AL: E("al");
			when REG_BL: E("bl");
			when REG_CL: E("cl");
			when REG_DL: E("dl");
			when REG_AX: E("ax");
			when REG_BX: E("bx");
			when REG_CX: E("cx");
			when REG_DX: E("dx");
			when else:
				SimpleError("bad reg");
		end case;
	end sub;

	sub E_op(reg: RegId, op: [Operand]) is
		if (reg & (REGCLASS_R8|REGCLASS_R16)) != 0 then
			E_reg(reg);
			return;
		end if;

		sub memop(kind: string) is
			E(kind);
			E(" [");
			E_symref(op.mem.sym, op.mem.off);
			E_b8(']');
		end sub;

		case reg is
			when REG_IMM:
				E_i16(op.imm.value as int16);

			when REG_MEM1: memop("byte");
			when REG_MEM2: memop("word");

			when else:
				E("bad op ");
				E_h32(reg);
		end case;
	end sub;

	sub E_push(reg: RegId) is
		if (reg & REGCLASS_R8) != 0 then
			reg := lowordreg(reg);
		end if;
		if (reg & REGCLASS_R16) != 0 then
			E("\tpushw ");
			E_reg(reg);
		else
			E("\tpushw ");
			E_reg(hiwordreg(reg));
			E("\tpushw ");
			E_reg(lowordreg(reg));
		end if;
		E_nl();
	end sub;

	sub E_pop(reg: RegId) is
		R_flush(reg);
		if (reg & REGCLASS_R8) != 0 then
			reg := lowordreg(reg);
		end if;
		if (reg & REGCLASS_R16) != 0 then
			E("\tpopw ");
			E_reg(reg);
		else
			E("\tpopw ");
			E_reg(lowordreg(reg));
			E("\tpopw ");
			E_reg(hiwordreg(reg));
		end if;
		E_nl();
	end sub;

	sub E_insn(insn: string) is
		E_tab();
		E(insn);
		E_space();
	end sub;

	sub E_jump(insn: string, label: LabelRef) is
		R_flushall();
		E_insn(insn);
		E_labelref(label);
		E_nl();
	end sub;

	sub E_jmp(label: LabelRef) is
		E_jump("jmp", label);
	end sub;

	sub E_jne(label: LabelRef) is
		E_jump("jne", label);
	end sub;

	var stringid: uint16 := 0;
	sub E_string(data: string) is
		var sid := stringid;
		stringid := stringid + 1;

		EmitterOpenStream(current_subr);

		E("\tsection .text\n");
		E_b8(COO_ESCAPE_THISCOO);
		E_b8('c');
		E_u16(sid);
		E(":\n\t.byte ");

		loop
			var c := [data];
			if c == 0 then
				break;
			end if;
			data := data + 1;
			
			E_u8(c);
			E_comma();
		end loop;
		E("0\n");
		EmitterCloseStream();

		E_b8(COO_ESCAPE_THISCOO);
		E_b8('c');
		E_u16(sid);
	end sub;

	sub ArchEmitMove(src: RegId, dest: RegId) is
		if src == 0 then
			E_pop(dest);
		elseif dest == 0 then
			E_push(src);
		else
			SimpleError("bad move");
		end if;
	end sub;

	sub ArchEndInstruction() is
	end sub;

	sub ArchEndGroup() is
	end sub;
%}

wordsize uint16;

operand imm;
operand mem1 mem2 mem4;
operand bxind1 bxind2 bxind4;
register dxax bxcx;
register ax bx cx dx si di;
register al ah bl bh cl ch dl dh;
register stk4 param;

regclass r8 := al|bl|cl|dl;
regclass rh8 := r8|ah|bh|ch|dh;
regclass r16 := ax|bx|cx|dx|si|di;
regclass r32 := dxax|bxcx;

regclass op1 := imm|mem1|bxind1;
regclass op2 := imm|mem2|bxind2;
regclass op4 := imm|mem4|bxind4;

regdata bxind1 uses bx;
regdata bxind2 uses bx;
regdata bxind4 uses bx;

regdata ax compatible r16  uses ax|ah|al;
regdata bx compatible r16  uses bx|bh|bl;
regdata cx compatible r16  uses cx|ch|cl;
regdata dx compatible r16  uses dx|dh|dl;
regdata si compatible r16  uses si;
regdata di compatible r16  uses di;
regdata al compatible r8   uses ax|ah|al;
regdata bl compatible r8   uses bx|bh|bl;
regdata cl compatible r8   uses cx|ch|cl;
regdata dl compatible r8   uses dx|dh|dl;
regdata stk4 stacked;
regdata param stacked;

// --- Core things ----------------------------------------------------------

gen STARTFILE();
gen ENDFILE();

gen LABEL():b
{
	E_label($b.label);
}

gen JUMP():j
{
	E_jmp($j.label);
}

// --- Subroutines ----------------------------------------------------------

gen STARTSUB()
{
	RegCacheReset();

	EmitterOpenStream(current_subr);

	E("\n\n\t; ");
	E(current_subr.name);
	E(" workspace at ");
	E_b8(COO_ESCAPE_WSREF);
	E_b16(current_subr.id);
	E_b8(0);
	E_b16(0);
	E(" length ");
	E_b8(COO_ESCAPE_WSSIZE);
	E_b16(current_subr.id);
	E_b8(0);
	E_nl();

	E("\tsection .text\n");
	E_b8(COO_ESCAPE_THISSUB);
	E(":\n");

}

gen ENDSUB()
{
	R_flushall();

	E("end_");
	E_subref(current_subr);
	E(":\n");

	E("\tret\n");

	EmitterCloseStream();
}

gen RETURN()
{
	E("\tjmp end_");
	E_subref(current_subr);
	E_nl();
}

// --- Operands -------------------------------------------------------------

gen imm := CONSTANT():c { $@$.operand.imm.value := $c.value; }

gen mem1 := DEREF1(ADDRESS():a) { $@$.operand.mem.sym := &$a.sym; $@$.operand.mem.off := $a.off; }
gen mem2 := DEREF2(ADDRESS():a) { $@$.operand.mem.sym := &$a.sym; $@$.operand.mem.off := $a.off; }
gen mem4 := DEREF4(ADDRESS():a) { $@$.operand.mem.sym := &$a.sym; $@$.operand.mem.off := $a.off; }

gen bxind2 := DEREF2(bx);

// --- Loads and stores -----------------------------------------------------

gen r8 := FALLBACK(op1:lhs)  { E_insn("mov"); E_reg($$); E_comma(); E_op($lhs, &$@lhs.operand); E_nl(); }
gen r16 := FALLBACK(op2:lhs) { E_insn("mov"); E_reg($$); E_comma(); E_op($lhs, &$@lhs.operand); E_nl(); }

//gen r32 := FALLBACK(op4:lhs);

gen STORE(r8:lhs, op1:rhs) { E_insn("mov"); E_op($rhs, &$@rhs.operand); E_comma(); E_op($lhs, &$@lhs.operand); E_nl(); }
gen STORE(r16:lhs, op2:rhs) { E_insn("mov"); E_op($rhs, &$@rhs.operand); E_comma(); E_op($lhs, &$@lhs.operand); E_nl(); }

//gen STORE(r32, op4);

// --- 8- and 16-bit arithmetic ---------------------------------------------

//gen r8  := NEG1($$) { E_insn("neg"); E_reg($$); E_nl(); }
//gen r16 := NEG2($$) { E_insn("neg"); E_reg($$); E_nl(); }
//
//gen r8  := NOT1($$) { E_insn("not"); E_reg($$); E_nl(); }
//gen r16 := NOT2($$) { E_insn("not"); E_reg($$); E_nl(); }
//
//gen r8  := ADD1($$, op1|r8:rhs) { E_insn("add"); E_reg($$); E_comma(); E_op($rhs, &$@rhs.operand); E_nl(); }
//gen r16 := ADD2($$, op2|r16:rhs) { E_insn("add"); E_reg($$); E_comma(); E_op($rhs, &$@rhs.operand); E_nl(); }
//
//gen r8  := SUB1($$, op1|r8:rhs) { E_insn("add"); E_reg($$); E_comma(); E_op($rhs, &$@rhs.operand); E_nl(); }
//gen r16 := SUB2($$, op2|r16:rhs) { E_insn("add"); E_reg($$); E_comma(); E_op($rhs, &$@rhs.operand); E_nl(); }

// --- Initialisers ---------------------------------------------------------

gen STARTINIT():s
{
	EmitterOpenStream(current_subr);
	E("\t.data 2\n");
	E_symref(&$s.sym, 0);
	E(":\n");
}

gen ENDINIT()
{
	EmitterCloseStream();
}

gen INIT1():c
{
	E("\t.byte ");
	E_u8($c.value as uint8);
	E_nl();
}

gen INIT2():c
{
	E("\t.short ");
	E_u16($c.value as uint16);
	E_nl();
}

gen INIT4():c
{
	E("\t.long ");
	E_u32($c.value as uint32);
	E_nl();
}

gen INITADDRESS():a
{
	E("\t.long ");
    E_symref(&$a.sym, $a.off);
    E_nl();
}

gen INITSUBREF():a
{
	E("\t.long ");
    E_subref($a.subr);
    E_nl();
}

gen INITSTRING():s
{
	E("\t.long ");
    E_string($s.text);
    E_nl();
}


// --- Inline assembly ------------------------------------------------------

gen ASMGROUPSTART();
gen ASMGROUPEND();

gen ASMSTART()
{
	R_flushall();
	E_tab();
}

gen ASMTEXT():t
{
	E($t.text);
	E_space();
}

gen ASMSYMBOL():s
{
	E_symref(&$s.sym, 0);
    E_space();
}

gen ASMSUBREF():s
{
	E_subref($s.subr);
    E_space();
}

gen ASMVALUE():c
{
	E_b8('(');
	E_i32($c.value);
	E_b8(')');
}

gen ASMEND()
{
    E_nl();
}



