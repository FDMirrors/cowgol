var current_token: uint16;
var filename_id: uint16 := 0;

sub read_identifier()
    loop
        input_buffer[buffer_index] := current_byte;
        buffer_index := buffer_index + 1;

        var type: int8 := classify_char_type(peeked_byte);
        if (type != ALPHABETIC) and (type != DIGIT) then
            break;
        end if;
        next_byte();
    end loop;

    var string_id: uint16 := lookup_string(&input_buffer[0], buffer_index);
    current_token := find_token_by_string(string_id);
    if current_token == 0 then
        var buf: IdentifierThing[1];
        buf[0].thing_type := THING_IDENTIFIER;
        buf[0].thing_size := IdentifierThing@bytes;
        buf[0].string_id := string_id;
        current_token := add_thing_by_value(&buf[0] as [Thing]);
    end if;
end sub;

sub read_number()
    loop
        input_buffer[buffer_index] := current_byte;
        buffer_index := buffer_index + 1;

        var type: int8 := classify_char_type(peeked_byte);
        if (type != ALPHABETIC) and (type != DIGIT) then
            break;
        end if;
        next_byte();
    end loop;

    var base: uint8 := 10;
    var ptr: [int8] := &input_buffer[0];
    if (buffer_index >= 2) and (input_buffer[0] == '0') then
        if input_buffer[1] == 'x' then
            base := 16;
            ptr := &input_buffer[2];
        elseif input_buffer[1] == 'o' then
            base := 8;
            ptr := &input_buffer[2];
        elseif input_buffer[1] == 'b' then
            base := 2;
            ptr := &input_buffer[2];
        end if;
    end if;

    input_buffer[buffer_index] := 0;
    var value: int32 := string_to_number(ptr, base);
    current_token := add_number_by_value(value);
end sub;

sub read_comment()
    while current_byte != 10 loop
        next_byte();
    end loop;
end sub;

sub read_symbol()
    input_buffer[0] := current_byte;
    if peeked_byte == '=' then
        input_buffer[1] := peeked_byte;
        buffer_index := 2;
        next_byte();
    else
        buffer_index := 1;
    end if;

    var string_id: uint16 := lookup_string(&input_buffer[0], buffer_index);
    current_token := find_token_by_string(string_id);
    if current_token == 0 then
        print("unrecognised symbol");
        error_with_location();
    end if;
end sub;

sub decode_escaped_char()
    if current_byte == 'n' then
        current_byte := '\n';
    elseif current_byte == '0' then
        current_byte := 0;
    elseif (current_byte == '\\') or (current_byte == '"') or (current_byte == '\'') then
    else
        print("unrecognised string escape \\");
        print_char(current_byte);
        error_with_location();
    end if;
end sub;

sub add_string_thing(string_id: uint16, out token_id: uint16)
    var buf: StringThing[1];
    buf[0].thing_type := THING_STRING;
    buf[0].thing_size := StringThing@bytes;
    buf[0].string_id := string_id;
    buf[0].string_size := buffer_index;
    token_id := add_thing_by_value(&buf[0] as [Thing]);
end sub;

sub read_string()
    next_byte();
    loop
        if current_byte == '"' then
            break;
        elseif current_byte == '\\' then
            next_byte();
            decode_escaped_char();
        end if;
        input_buffer[buffer_index] := current_byte;
        buffer_index := buffer_index + 1;
        next_byte();
    end loop;

    var string_id: uint16 := lookup_string(&input_buffer[0], buffer_index);
    current_token := add_string_thing(string_id);
end sub;

sub read_char_constant()
    next_byte();
    if current_byte == '\\' then
        next_byte();
        decode_escaped_char();
    end if;

    var buf: NumberThing[1];
    buf[0].thing_type := THING_NUMBER;
    buf[0].thing_size := NumberThing@bytes;
    buf[0].value := current_byte;

    current_token := add_thing_by_value(&buf[0] as [Thing]);

    next_byte();
    if current_byte != '\'' then
        print("invalid character constant");
        error_with_location();
    end if;
end sub;

sub next_token()
    if current_byte == -1 then
        current_token := 0;
        return;
    end if;
    if current_byte == '#' then
        while (current_byte != -1) and (current_byte != '\n') loop
            next_byte();
        end loop;
    end if;

    buffer_index := 0;
    var type: int8;
    loop
        type := classify_char_type(current_byte);
        if (type != NEWLINE) and (type != WHITESPACE) then
            break;
        end if;
        next_byte();
        if current_byte == -1 then
            current_token := 0;
            return;
        end if;
    end loop;

    if current_byte == '"' then
        read_string();
    elseif current_byte == '\'' then
        read_char_constant();
    elseif (type == ALPHABETIC) or (current_byte == '@') then
        read_identifier();
    elseif type == SYMBOL then
        read_symbol();
    elseif type == DIGIT then
        read_number();
    else
        print("unknown char '");
        print_char(current_byte);
        print("'");
        error_with_location();
    end if;
    next_byte();
end sub;

sub init_tokeniser()
    next_byte();
    next_byte();
    next_token();
end sub;

sub install_identifier(name: [int8], id: uint16, thingtype: uint8, token_flags: uint8)
    copy_string(name, &input_buffer[0]);
    buffer_index := string_length(&input_buffer[0]);

    var string_id: uint16 := lookup_string(&input_buffer[0], buffer_index);
    var buf: TokenThing[1];
    buf[0].thing_type := thingtype;
    buf[0].string_id := string_id;
    if thingtype == THING_TOKEN then
        buf[0].thing_size := TokenThing@bytes;
        buf[0].token_flags := token_flags;
    else
        buf[0].thing_size := IdentifierThing@bytes;
    end if;
    var token_id: uint16 := add_thing(&buf[0] as [Thing]);

    if token_id != id then
        print("token id mismatch (internal error); wanted 0x");
        print_hex_i16(id);
        print(", got 0x");
        print_hex_i16(token_id);
        print_newline();
        exit(1);
    end if;
end sub;
