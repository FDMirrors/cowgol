sub get_width_of(node: [Node]): (width: uint8)
    var type: [TypeThing] := find_thing(node.type_id) as [TypeThing];
    width := type.width;
end sub;

sub write_be_iop(iop: [BEIop])
    print("* BE iop 0x");
    print_hex_i8(iop.iop_kind);
    print(" width=");
    print_i8(iop.width);
    print(" left=");
    print_ea(&iop.left);
    print(" right=");
    print_ea(&iop.right);
    print(" dest=");
    print_ea(&iop.dest);
    print_newline();
    write_iop(iop as [Iop]);
end sub;

sub reset_be_iop(iop: [BEIop])
    zero_memory(iop as [int8], BEIop@bytes);
    iop.iop_size := BEIop@bytes;
end sub;

sub simplify_ea(beiop: uint8, width: uint8, ea: [EffectiveAddress])
    var iop: BEIop;
    var tmpvar_id: uint16;

    if (width > 1) and (ea.flags == EA_DEREF) and (beiop != IOP_BE_COPY) then
        # Derefs in wide instructions are only allowed in copy instructions.
        print("* splitting wide input deref\n");
        tmpvar_id := alloc_temporary(width);

        reset_be_iop(&iop);
        iop.left.obj_id := ea.obj_id;
        iop.left.flags := EA_DEREF;
        iop.dest.obj_id := tmpvar_id;
        iop.width := width;
        iop.iop_kind := IOP_BE_COPY;
        write_be_iop(&iop);

        ea.obj_id := tmpvar_id;
        ea.flags := EA_NORMAL;
    end if;

    sub offset_into_add()
        tmpvar_id := alloc_temporary(2);

        if ea.flags == EA_LEA then
            reset_be_iop(&iop);
            iop.left.obj_id := ea.obj_id;
            iop.left.flags := EA_LEA;
            iop.dest.obj_id := tmpvar_id;
            iop.width := 2;
            iop.iop_kind := IOP_BE_COPY;
            write_be_iop(&iop);
        end if;

        reset_be_iop(&iop);
        if ea.flags == EA_LEA then
            iop.left.obj_id := tmpvar_id;
        else
            iop.left.obj_id := ea.obj_id;
        end if;
        iop.right.obj_id := ea.off_id;
        iop.dest.obj_id := tmpvar_id;
        iop.width := 2;
        iop.iop_kind := IOP_BE_ADD;
        write_be_iop(&iop);

        ea.obj_id := tmpvar_id;
        ea.off_id := 0;
    end sub;

    var offset_type: uint8 := get_thing_type(ea.off_id);
    if (offset_type & THING_TYPED) != 0 then
        var type_id: uint16 := get_type_of_thing(ea.off_id);
        var type: [TypeThing] := find_thing(type_id) as [TypeThing];

        if ea.flags == EA_LEA then
            print("* turning lea obj+var into add\n");
            offset_into_add();
        end if;

        if (width > 1) or (type.thing_type != THING_UNSIGNED) or (type.width != 1) then
            print("* turning var offset into add\n");
            offset_into_add();
        end if;
    elseif offset_type == THING_NUMBER then
        sub is_number_a_byte(number_id: uint16): (is_valid: uint8)
            var value: int32 := get_value_of_number(number_id);
            if (value >= 0) and (value <= 255) then
                is_valid := 1;
            else
                is_valid := 0;
            end if;
        end sub;

        if ea.flags == EA_DEREF then
            if (width > 1) or (is_number_a_byte(ea.off_id) == 0) then
                print("* turning too-large constant offset of deref into add\n");
                offset_into_add();
            end if;
        end if;
    end if;
end sub;

sub arch_simplify_node_to(src: [Node], dest: [Node])
    if dest.iop != IOP_FEX_PUSH then
        print("simplify_node_to() where dest is not simplified");
        halt();
    end if;

    var destwidth: uint8 := get_width_of(dest);

    var iop: BEIop;
    reset_be_iop(&iop);
    iop.width := destwidth;
    copy_ea(&dest.left, &iop.dest);

    if src.iop == IOP_FEX_PUSH then
        iop.iop_kind := IOP_BE_COPY;
    else
        iop.iop_kind := src.iop;
    end if;

    copy_ea(&src.left, &iop.left);
    copy_ea(&src.right, &iop.right);

    simplify_ea(iop.iop_kind, destwidth, &iop.left);
    if (iop.iop_kind & IOP_TYPE_MASK) == IOP_TYPE_BACKEND_3OP then
        simplify_ea(iop.iop_kind, destwidth, &iop.right);
    end if;
    simplify_ea(iop.iop_kind, destwidth, &iop.dest);

    write_be_iop(&iop);
end sub;
