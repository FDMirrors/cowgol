%{
	sub ArchAlignUp(value: Size, alignment: uint8): (newvalue: Size) is
		newvalue := value;
	end sub;

	sub E_symref(sym: [Symbol], off: Size) is
		if sym.wsid == WSID_STATIC then
			E_wsref(sym.subr.id, sym.wsid, sym.off);
			if off != 0 then
				E_i16(off as int16);
			end if;
		else
			E_wsref(sym.subr.id, sym.wsid, sym.off + off);
		end if;
	end sub;

	sub R_flushall() is
		RegCacheFlush(ALL_REGS);
	end sub;

	sub R_flush(reg: RegId) is
		RegCacheFlush(FindConflictingRegisters(reg));
	end sub;

	sub E_label(label: LabelRef) is
		R_flushall();
		E_labelref(label);
		E(":\n");
	end sub;

	sub getreg(reg: RegId, regtable: [RegId], name: string): (result: RegId) is
		result := 0;
		while reg != 0 loop
			if (reg & 1) != 0 then
				result := [regtable];
				return;
			end if;
			reg := reg >> 1;
			regtable := @next regtable;
		end loop;

		if result == 0 then
			StartError();
			print("bad ");
			print(name);
			print_char(' ');
			print_hex_i32(reg);
			EndError();
		end if;
	end sub;

	sub loreg(reg: RegId): (loreg: RegId) is
		var regs: RegId[] := {
			REG_DL, REG_CL,
			REG_AL, REG_BL, REG_CL, REG_DL, 0, 0,
			REG_AL, REG_AL,
			REG_BL, REG_BL,
			REG_CL, REG_CL,
			REG_DL, REG_DL
		};

		loreg := getreg(reg, &regs[0], "loreg");
	end sub;

	sub lowordreg(reg: RegId): (wordreg: RegId) is
		var regs: RegId[] := {
			REG_AX, REG_CX,
			REG_AX, REG_BX, REG_CX, REG_DX, REG_SI, REG_DI,
			REG_AX, REG_AX,
			REG_BX, REG_BX,
			REG_CX, REG_CX,
			REG_DX, REG_DX
		};

		wordreg := getreg(reg, &regs[0], "lowordreg");
	end sub;

	sub hiwordreg(reg: RegId): (wordreg: RegId) is
		var regs: RegId[] := {
			REG_DX, REG_BX,
			REG_AX, REG_BX, REG_CX, REG_DX, REG_SI, REG_DI,
			REG_AX, REG_AX,
			REG_BX, REG_BX,
			REG_CX, REG_CX,
			REG_DX, REG_DX
		};

		wordreg := getreg(reg, &regs[0], "hilowordreg");
	end sub;

	sub E_reg(reg: RegId) is
		var names: string[] := {
			"ax",  "bx",  "cx",  "dx",  "si",  "di",
			"al", "ah", "bl", "bh", "cl", "ch", "dl", "dh"
		};

		E_b8('%');
		var p := &names[0];
		while reg != 0 loop
			if (reg & 1) != 0 then
				E([p]);
				return;
			end if;
			reg := reg >> 1;
			p := @next p;
		end loop;

		StartError();
		print("bad reg ");
		print_hex_i32(reg);
		EndError();
	end sub;

	sub E_push(reg: RegId) is
		if (reg & REGCLASS_R8) != 0 then
			reg := lowordreg(reg);
		end if;
		if (reg & REGCLASS_R16) != 0 then
			E("\tpushw ");
			E_reg(reg);
		else
			E("\tpushw ");
			E_reg(hiwordreg(reg));
			E("\tpushw ");
			E_reg(lowordreg(reg));
		end if;
		E_nl();
	end sub;

	sub E_pop(reg: RegId) is
		R_flush(reg);
		if (reg & REGCLASS_R8) != 0 then
			reg := lowordreg(reg);
		end if;
		if (reg & REGCLASS_R16) != 0 then
			E("\tpopw ");
			E_reg(reg);
		else
			E("\tpopw ");
			E_reg(lowordreg(reg));
			E("\tpopw ");
			E_reg(hiwordreg(reg));
		end if;
		E_nl();
	end sub;

	sub E_jump(insn: string, label: LabelRef) is
		R_flushall();
		E_tab();
		E(insn);
		E_space();
		E_labelref(label);
		E_nl();
	end sub;

	sub E_jmp(label: LabelRef) is
		E_jump("jmp", label);
	end sub;

	sub E_jne(label: LabelRef) is
		E_jump("jne", label);
	end sub;

	var stringid: uint16 := 0;
	sub E_string(data: string) is
		var sid := stringid;
		stringid := stringid + 1;

		EmitterOpenStream(current_subr);

		E("\t.text 1\n");
		E_b8(COO_ESCAPE_THISCOO);
		E_b8('c');
		E_u16(sid);
		E(":\n\t.byte ");

		loop
			var c := [data];
			if c == 0 then
				break;
			end if;
			data := data + 1;
			
			E_u8(c);
			E_comma();
		end loop;
		E("0\n");
		EmitterCloseStream();

		E_b8(COO_ESCAPE_THISCOO);
		E_b8('c');
		E_u16(sid);
	end sub;

	sub ArchEmitMove(src: RegId, dest: RegId) is
		if src == 0 then
			E_pop(dest);
		elseif dest == 0 then
			E_push(src);
		else
			SimpleError("bad move");
		end if;
	end sub;

	sub ArchEndInstruction() is
	end sub;

	sub ArchEndGroup() is
	end sub;
%}

wordsize uint16;

register dxax bxcx;
register ax bx cx dx si di;
register al ah bl bh cl ch dl dh;
register stk4 param;

regclass r8 := al|bl|cl|dl;
regclass rh8 := r8|ah|bh|ch|dh;
regclass r16 := ax|bx|cx|dx|si|di;
regclass r32 := dxax|bxcx;

regdata ax compatible r16  uses ax|ah|al;
regdata bx compatible r16  uses bx|bh|bl;
regdata cx compatible r16  uses cx|ch|cl;
regdata dx compatible r16  uses dx|dh|dl;
regdata si compatible r16  uses si;
regdata di compatible r16  uses di;
regdata al compatible r8   uses ax|ah|al;
regdata bl compatible r8   uses bx|bh|bl;
regdata cl compatible r8   uses cx|ch|cl;
regdata dl compatible r8   uses dx|dh|dl;
regdata stk4 stacked;
regdata param stacked;

// --- Core things ----------------------------------------------------------

gen STARTFILE();
gen ENDFILE();

gen LABEL():b
{
	E_label($b.label);
}

gen JUMP():j
{
	E_jmp($j.label);
}

// --- Subroutines ----------------------------------------------------------

gen STARTSUB()
{
	RegCacheReset();

	EmitterOpenStream(current_subr);

	E("\n\n\t# ");
	E(current_subr.name);
	E(" workspace at ");
	E_b8(COO_ESCAPE_WSREF);
	E_b16(current_subr.id);
	E_b8(0);
	E_b16(0);
	E(" length ");
	E_b8(COO_ESCAPE_WSSIZE);
	E_b16(current_subr.id);
	E_b8(0);
	E_nl();

	E("\t.text\n");
	E_b8(COO_ESCAPE_THISSUB);
	E(":\n");

}

gen ENDSUB()
{
	R_flushall();

	E("end_");
	E_subref(current_subr);
	E(":\n");

	EmitterCloseStream();
}

gen RETURN()
{
	E("\tjmp end_");
	E_subref(current_subr);
	E_nl();
}

// --- Initialisers ---------------------------------------------------------

gen STARTINIT():s
{
	EmitterOpenStream(current_subr);
	E("\t.data 2\n");
	E_symref(&$s.sym, 0);
	E(":\n");
}

gen ENDINIT()
{
	EmitterCloseStream();
}

gen INIT1():c
{
	E("\t.byte ");
	E_u8($c.value as uint8);
	E_nl();
}

gen INIT2():c
{
	E("\t.short ");
	E_u16($c.value as uint16);
	E_nl();
}

gen INIT4():c
{
	E("\t.long ");
	E_u32($c.value as uint32);
	E_nl();
}

gen INITADDRESS():a
{
	E("\t.long ");
    E_symref(&$a.sym, $a.off);
    E_nl();
}

gen INITSUBREF():a
{
	E("\t.long ");
    E_subref($a.subr);
    E_nl();
}

gen INITSTRING():s
{
	E("\t.long ");
    E_string($s.text);
    E_nl();
}


// --- Inline assembly ------------------------------------------------------

gen ASMGROUPSTART();
gen ASMGROUPEND();

gen ASMSTART()
{
	R_flushall();
	E_tab();
}

gen ASMTEXT():t
{
	E($t.text);
	E_space();
}

gen ASMSYMBOL():s
{
	E_symref(&$s.sym, 0);
    E_space();
}

gen ASMSUBREF():s
{
	E_subref($s.subr);
    E_space();
}

gen ASMVALUE():c
{
	E_b8('(');
	E_i32($c.value);
	E_b8(')');
}

gen ASMEND()
{
    E_nl();
}



