# longjmps out of the program.
var __exitstack: uint16;
@bytes 0xED, 0x73, &__exitstack; # ld (__exitstack), sp
sub exit(status: uint8)
    @bytes 0xED, 0x7B, &__exitstack; # ld sp, (__exitstack)
end sub;

# Loads the 32-bit value pointed to by HL into EDCA. Corrupts HL.
sub __load_hl()
    @bytes 0x7E;       # ld a, (hl)
    @bytes 0x23;       # inc hl
    @bytes 0x4E;       # ld c, (hl)
    @bytes 0x23;       # inc hl
    @bytes 0x56;       # ld d, (hl)
    @bytes 0x23;       # inc hl
    @bytes 0x5E;       # ld e, (hl)
end sub;

# Saves the 32-bit value pointed to by HL from EDCA. Corrupts HL.
sub __save_hl()
    @bytes 0x77;       # ld (hl), a
    @bytes 0x23;       # inc hl
    @bytes 0x71;       # ld (hl), c
    @bytes 0x23;       # inc hl
    @bytes 0x72;       # ld (hl), d
    @bytes 0x23;       # inc hl
    @bytes 0x73;       # ld (hl), e
end sub;

# Shifts the 32-bit value pointed to by HL left B bits, and writes it back
# to DE. Corrupts all registers (except the index ones).
sub __lsl32()
    @bytes 0xD5;       # push de
    __load_hl();

                       # .loop
    @bytes 0xCB, 0x27; # sla a
    @bytes 0xCB, 0x11; # rl c
    @bytes 0xCB, 0x12; # rl d
    @bytes 0xCB, 0x13; # rl e
    @bytes 0x10, 0xF6; # djnz loop

    @bytes 0xE1;       # pop hl
    __save_hl();
end sub;

# Arithmetic shifts the 32-bit value pointed to by HL left B bits, and writes
# it back to DE. Corrupts all registers (except the index ones).
sub __asr32()
    @bytes 0xD5;       # push de
    __load_hl();

                       # .loop
    @bytes 0xCB, 0x2B; # sra e
    @bytes 0xCB, 0x1A; # rr d
    @bytes 0xCB, 0x19; # rr c
    @bytes 0xCB, 0x18; # rr a
    @bytes 0x10, 0xF6; # djnz loop

    @bytes 0xE1;       # pop hl
    __save_hl();
end sub;

# Logic shifts the 32-bit value pointed to by HL left B bits, and writes
# it back to DE. Corrupts all registers (except the index ones).
sub __lsr32()
    @bytes 0xD5;       # push de
    __load_hl();

                       # .loop
    @bytes 0xCB, 0x3B; # srl e
    @bytes 0xCB, 0x1A; # rr d
    @bytes 0xCB, 0x19; # rr c
    @bytes 0xCB, 0x18; # rr a
    @bytes 0x10, 0xF6; # djnz loop

    @bytes 0xE1;       # pop hl
    __save_hl();
end sub;

# Computes H*E, returning the result in HL.
# Corrupts B, D, H, L.
sub __mul8()
    @bytes 0x16, 0x00; # ld d, #0
    @bytes 0x6A;       # ld l, d
    @bytes 0x06, 0x08; # ld b, #8
                       # .loop
    @bytes 0x29;       # add hl, hl
    @bytes 0x30, 0x01; # jr nc, skip
    @bytes 0x19;       # add hl, de
    @bytes 0x10, 0xFA; # djnz loop 
end sub;

# Computes C/D, result=C, remainder=A
# Corrupts A, B, C.
sub __divmodu8()
    @bytes 0x06, 0x08;       # ld b,8
    @bytes 0xAF;             # xor a
                             # .loop
    @bytes 0xCB, 0x21;       # sla c
    @bytes 0x17;             # rla
    @bytes 0xBA;             # cp d
    @bytes 0x38, 0x02;       # jr c, skip
    @bytes 0x0C;             # inc c
    @bytes 0x92;             # sub d
                             # .skip
    @bytes 0x10, 0xF6;       # djnz loop
end sub;

# Computes C/D, result=C, remainder=A, signed
# Corrupts A, B, C, H, L.
sub __divmods8()
    # If either of the arguments are negative, remember that (in HL, our only
    # spare register) and make them positive.
    # If the top bit of H is set: remainder must be negated.
    # If the top bit of L is set: result must be negated.

    @bytes 0x61;               # ld h, c   --- only care about the top bit
    @bytes 0xCB, 0x79;         # bit 7, c
    @bytes 0x28, 0x03;         # jr z, dont_negate_c
    @bytes 0xAF;               # xor a
    @bytes 0x91;               # sub c
    @bytes 0x4F;               # ld c, a
                               # .dont_negate_c

    @bytes 0x7A;               # ld a, d
    @bytes 0xAC;               # xor h
    @bytes 0x6F;               # ld l, a   --- top bit of l is sign of C ^ sign of D
    @bytes 0xCB, 0x7A;         # bit 7, d
    @bytes 0x28, 0x03;         # .dont_negate_d
    @bytes 0xAF;               # xor a
    @bytes 0x92;               # sub d
    @bytes 0x57;               # ld d, a
                               # .dont_negate_d

    @bytes 0xCD, &__divmodu8;  # call __divmodu8

    @bytes 0xCB, 0x7C;         # bit 7, h  --- does remainder need negating?
    @bytes 0x28, 0x02;         # jr z, dont_negate_remainder
    @bytes 0xED, 0x44;         # neg
                               # .dont_negate_remainder

    @bytes 0xCB, 0x7D;         # bit 7, l  --- does result need negating?
    @bytes 0xC8;               # ret z     --- no? return now
    @bytes 0x67;               # ld h, a   --- preserve old A (the remainder)
    @bytes 0xAF;               # xor a
    @bytes 0x91;               # sub c
    @bytes 0x4F;               # ld c, a
    @bytes 0x7C;               # ld a, h
end sub;

# Computes DE/BC, result=DE, remainder=HL
# Corrupts all 8-bit registers.
sub __divmodu16()
    @bytes 0x3E, 0x10;       # ld a, #16
    @bytes 0x21, 0x00, 0x00; # ld hl, #0
    @bytes 0x18, 0x03;       # jr entry

                             # .loop1:
    @bytes 0x09;             # add hl, bc
                             # .loop2
    @bytes 0x3D;             # dec a
    @bytes 0xC8;             # ret z
                             # .entry
    @bytes 0xCB, 0x23;       # sla e
    @bytes 0xCB, 0x12;       # rl d
    @bytes 0xED, 0x6A;       # adc hl, hl --- shift remainder left and add carry
    @bytes 0xB7;             # or a       --- clear carry
    @bytes 0xED, 0x42;       # sbc hl, bc --- sets carry if remainder(hl) < bc
    @bytes 0x38, 0xF2;       # jr c, loop1 --- if remainder < bc, undo add and go round again
    @bytes 0x1C;             # inc e      --- we know the bottom bit is clear
    @bytes 0x18, 0xF0;       # jr loop2
end sub;

# Computer DE/BC, result=DE, remainder=HL, signed.
# Corrupts all 8-bit registers.
sub __divmods16()
    sub negate_de()
        @bytes 0xAF;             # xor a
        @bytes 0x93;             # sub e
        @bytes 0x5F;             # ld e, a
        @bytes 0x9F;             # sbc a, a  --- clear A to 0 or -1 depending on carry
        @bytes 0x92;             # sub d
        @bytes 0x57;             # ld d, a
    end sub;

    sub negate_bc()
        @bytes 0xAF;             # xor a
        @bytes 0x91;             # sub c
        @bytes 0x4F;             # ld c, a
        @bytes 0x9F;             # sbc a, a  --- clear A to 0 or -1 depending on carry
        @bytes 0x90;             # sub b
        @bytes 0x47;             # ld b, a
    end sub;

    sub negate_hl()
        @bytes 0xAF;             # xor a
        @bytes 0x95;             # sub l
        @bytes 0x6F;             # ld l, a
        @bytes 0x9F;             # sbc a, a  --- clear A to 0 or -1 depending on carry
        @bytes 0x94;             # sub h
        @bytes 0x67;             # ld h, a
    end sub;

    # If either of the arguments are negative, remember that (in HL, our only
    # spare register) and make them positive.
    # If the top bit of H is set: remainder must be negated.
    # If the top bit of L is set: result must be negated.

    @bytes 0x62;               # ld h, d   --- only care about the top bit
    @bytes 0xCB, 0x7A;         # bit 7, d
    @bytes 0xC4, &negate_de;   # call nz, negate_de
    
    @bytes 0x78;               # ld a, b
    @bytes 0xAC;               # xor h     
    @bytes 0x6F;               # ld l, a   --- top bit of l is sign of DE ^ sign of BC
    @bytes 0xCB, 0x78;         # bit 7, b
    @bytes 0xC4, &negate_bc;   # call nz, negate_bc

    @bytes 0xE5;               # push hl
    @bytes 0xCD, &__divmodu16; # call __divmodu16
    @bytes 0xC1;               # pop bc

    @bytes 0xCB, 0x78;         # bit 7, b  --- does remainder need negating?
    @bytes 0xC4, &negate_hl;   # call nz, negate_hl

    @bytes 0xCB, 0x79;         # bit 7, c  --- does result need negating?
    @bytes 0xC4, &negate_de;   # call nz, negate_de
end sub;

sub divmodu32(left: uint32, right: uint32): (quotient: uint32, remainder: uint32)
end sub;
