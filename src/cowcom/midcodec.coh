
sub CountParameters(param: [Symbol]): (count: uint8)
	count := 0;
	while param != (0 as [Symbol]) loop
		count := count + 1;
		param := param.vardata.next_parameter;
	end loop;
end sub;

sub GetInputParameter(subr: [Subroutine], count: uint8): (param: [Symbol])
	param := subr.first_input_parameter;
	while count != 0 loop
		param := param.vardata.next_parameter;
		count := count - 1;
	end loop;
end sub;

sub GetOutputParameter(subr: [Subroutine], count: uint8): (param: [Symbol])
	param := subr.first_output_parameter;
	while count != 0 loop
		param := param.vardata.next_parameter;
		count := count - 1;
	end loop;
end sub;

sub BadNodeWidth(width: uint8)
	print("bad midcode width ");
	print_i8(width);
	print_nl();
	ExitWithError();
end sub;

sub WidthToIndex(width: uint8): (index: uint8)
	case width is
		when 4: index := 3;
		when 8: index := 4;
		when else: index := width;
	end case;
end sub;

include "midcodes.coh";

# Free up the node tree rooted in the parameter. This is more exciting than it
# should be because we don't have recursion.
sub Discard(node: [Node])
	var pending := node;
	while pending != (0 as [Node]) loop
		node := pending;
		pending := node.dlink;

		# Unlink and push any children.
		if node.left != (0 as [Node]) then
			node.left.dlink := pending;
			pending := node.left;
		end if;
		if node.right != (0 as [Node]) then
			node.right.dlink := pending;
			pending := node.right;
		end if;

		# Now free this node.
		Free(node as [uint8]);
	end loop;
end sub;

sub NodeWidth(node: [Node]): (width: uint8)
	width := 0;
	if node.type != (0 as [Symbol]) then
		width := node.type.typedata.width as uint8;
	end if;
end sub;

sub midcodec_i_bad_fold()
	SimpleError("bad fold");
end sub;

sub FoldConstant1(op: uint8, lhsp: [Node]): (result: Arith)
	var lhs := lhsp.constant.value;
	case op is
		when MIDCODE_NOT0: result := ~lhs;
		when MIDCODE_NEG0: result := -lhs;
		when else:
			midcodec_i_bad_fold();
	end case;
end sub;

sub FoldConstant2(op: uint8, lhsp: [Node], rhsp: [Node]): (result: Arith)
	var lhs := lhsp.constant.value;
	var rhs := rhsp.constant.value;
	case op is
		when MIDCODE_ADD0: result := lhs + rhs;
		when MIDCODE_SUB0: result := lhs - rhs;
		when MIDCODE_MUL0: result := lhs * rhs;
		when MIDCODE_DIVU0: result := ((lhs as uint32) / (rhs as uint32)) as Arith;
		when MIDCODE_DIVS0: result := (lhs as int32) / (rhs as int32);
		when MIDCODE_REMU0: result := ((lhs as uint32) % (rhs as uint32)) as Arith;
		when MIDCODE_REMS0: result := (lhs as int32) % (rhs as int32);
		when MIDCODE_AND0: result := lhs & rhs;
		when MIDCODE_OR0:  result := lhs | rhs;
		when MIDCODE_EOR0: result := lhs ^ rhs;
		when else:
			midcodec_i_bad_fold();
	end case;
end sub;

# Called before commutative operators.
sub RotateParameters(baseop: uint8, lhs: [Node], rhs: [Node]): (newlhs: [Node], newrhs: [Node])
	# Ensure that x=1+y becomes x=y+1, which is easier to generate code for.
	var lop := lhs.op;
	if lop == MIDCODE_CONSTANT then
		newlhs := lhs;
		newrhs := rhs;
		return;
	end if;

	# Ensure that x=(y+1)+2 becomes x=y+(1+2).
	if (rhs.op == MIDCODE_CONSTANT)
			and (lhs.op >= baseop) and (lhs.op <= (baseop+4))
			and (lhs.right.op == MIDCODE_CONSTANT)
	then
		newlhs := lhs.left;
		lhs.left := 0 as [Node];

		newrhs := MidConstant(
			FoldConstant2(baseop, lhs.right, rhs));
		Discard(lhs);
		Discard(rhs);
		return;
	end if;

	newlhs := lhs;
	newrhs := rhs;
end sub;

sub MidC1Op(op: uint8, width: uint8, lhs: [Node]): (result: [Node])
	if lhs.op == MIDCODE_CONSTANT then
		lhs.constant.value := FoldConstant1(op, lhs);
		result := lhs;
	else
		result := AllocateNewNode(op + WidthToIndex(width));
		result.left := lhs;
	end if;
end sub;
	
sub GetPowerOfTwo(value: int32): (exp: uint8)
	exp := 0;
	if (value > 0) and ((value & (value - 1)) == 0) then
		while value != 0 loop
			exp := exp + 1;
			value := value >> 1;
		end loop;
	end if;
end sub;

sub MidC2Op(op: uint8, width: uint8, lhs: [Node], rhs: [Node]): (result: [Node])
	# Convert subtractions of negative constants into additions, before the
	# rotation.

	if (op == MIDCODE_SUB0) and (rhs.op == MIDCODE_CONSTANT) then
		rhs.constant.value := -rhs.constant.value;
		op := MIDCODE_ADD0;
	end if;

	# Rotate commutative operations so the constant is on the RHS.

	if op >= MIDCODE_ADD0 then
		(lhs, rhs) := RotateParameters(op, lhs, rhs);
	end if;

	# Special-case folding.

	if (lhs.op != MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		if (op == MIDCODE_MUL0) or (op == MIDCODE_DIVS0) or (op == MIDCODE_DIVU0) then
			var value := rhs.constant.value;
			var exp := GetPowerOfTwo(value);
			if exp != 0 then
				Discard(rhs);
				case op is
					when MIDCODE_MUL0: op := MIDCODE_LSHIFT0;
					when MIDCODE_DIVS0: op := MIDCODE_RSHIFTS0;
					when MIDCODE_DIVU0: op := MIDCODE_RSHIFTU0;
				end case;
				result := AllocateNewNode(op + WidthToIndex(width));
				result.left := lhs;
				result.right := MidConstant((exp-1) as int32);
				return;
			end if;
		elseif (op == MIDCODE_ADD0) or (op == MIDCODE_SUB0) then
			if rhs.constant.value == 0 then
				Discard(rhs);
				result := lhs;
				return;
			end if;
			if lhs.op == MIDCODE_ADDRESS then
				var rvalue := rhs.constant.value as Size;
				case op is
					when MIDCODE_ADD0:
						lhs.address.off := lhs.address.off + rvalue;
						Discard(rhs);
						result := lhs;
						return;
					when MIDCODE_SUB0:
						lhs.address.off := lhs.address.off - rvalue;
						Discard(rhs);
						result := lhs;
						return;
				end case;
			end if;
		end if;
	end if;

	# General constant folding.

	if (lhs.op == MIDCODE_CONSTANT) and (rhs.op == MIDCODE_CONSTANT) then
		lhs.constant.value := FoldConstant2(op, lhs, rhs);
		Discard(rhs);
		result := lhs;
		return;
	end if;

	# If we get this far, then actually create the new node.

	result := AllocateNewNode(op + WidthToIndex(width));
	result.left := lhs;
	result.right := rhs;
end sub;

sub MidCCast(width: uint8, lhs: [Node], issigned: uint8): (result: [Node])
	if lhs.op == MIDCODE_CONSTANT then
		result := lhs;
		return;
	end if;
	var srcwidth := lhs.type.typedata.width as uint8;
	if srcwidth == width then
		result := lhs;
	else
		var op: uint8;
		case srcwidth is
			when 1: op := MIDCODE_CAST10;
			when 2: op := MIDCODE_CAST20;
			when 4: op := MIDCODE_CAST40;
			when 8: op := MIDCODE_CAST80;
		end case;
		result := AllocateNewNode(op + WidthToIndex(width));
		result.left := lhs;
		result.cast10.sext := issigned;
	end if;
end sub;

