sub yyparse(): (result: int8)
    type State := uint8;

    var stack: YYSTYPE[STACK_SIZE];
    var states: State[STACK_SIZE];
    var rule: int16;
    var h: int16;
    var state: State;
    var n: int16;
    var tk: int16;

    var sp: uint8 := 0;
    state := INITIAL_STATE;
    states[sp] := state;
    tk := -1;

    sub check_n(checking: int16): (yes: uint8)
        if (n < 0) or (n >= actions_and_gotos@size) then
            yes := 1;
        elseif checking_table[n as checking_table@index] != checking then
            yes := 1;
        else
            yes := 0;
        end if;
    end sub;

do_loop:
    print("sp: ");
    print_i8(sp);
    print_newline();
    print("state: ");
    print_i16(state as uint16);
    print_newline();
    
    n := state_to_displacement[state];

    print("state displacement: ");
    print_i16(n as uint16);
    print_newline();

    if (tk < 0) and (n > -NUMBER_OF_TOKENS) then
        tk := yylex() as int16;
        print("got token ");
        print_i16(tk as uint16);
        print_newline();
    end if;
    n := n + tk;

    if check_n(tk) != 0 then
        goto do_fail_or_reduce;
    end if;

    n := actions_and_gotos[n as actions_and_gotos@index];
    if n == -1 then
        result := -1;
        return;
    end if;
    if n < 0 then
        rule := 0 - (n+2);
        goto do_reduce;
    end if;

    tk := -1;
    copy_yystype(&yylval, &yyval);
do_stack:
    print("stacking state ");
    print_i16(n as uint16);
    print_newline();

    sp := sp + 1;
    if sp >= STACK_SIZE then
        print("parser stack overflow");
        halt();
        return;
    end if;
    state := n as State;
    states[sp] := state;
    copy_yystype(&yyval, &stack[sp]);
    goto do_loop;

do_fail_or_reduce:
    rule := state_to_reduce[state];
    if rule < 0 then
        result := -1;
        return;
    end if;
    goto do_reduce;

do_reduce:
    print("reducing with rule ");
    print_i16(rule as uint16);
    print_newline();

    var delta: uint8 := rule_to_arity_table[rule as rule_to_arity_table@index];
    print("stack delta ");
    print_i8(delta);
    print_newline();

    sp := sp - delta;
    h := rule_to_symbol[rule as rule_to_symbol@index];
    state := states[sp];

    n := nt_to_displacement[h as nt_to_displacement@index] + (state as int16);
    if check_n(h + NUMBER_OF_TOKENS) != 0 then
        n := nt_to_goto[h as nt_to_goto@index];
    else
        n := actions_and_gotos[n as actions_and_gotos@index];
    end if;

    parser_action(&stack[sp], rule);
    if rule == 0 then
        result := 0;
        return;
    end if;
    goto do_stack;
end sub;
