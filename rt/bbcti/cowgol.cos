# --- Conditionals and branches ---------------------------------------------
#
&X jump
``:
	ldy #1
	lda (ip),y
	pha
	dey
	lda (ip),y
	sta ip+0
	pla
	sta ip+1
	jmp `next

&X cmp1
``:
	dex
	dex
	lda stack+0,x
	cmp stack+1,x
	rts

&X beq1
``:
	jsr `cmp1
	beq `jump
	jmp `inc2_next

&X bne1
``:
	jsr `cmp1
	bne `jump
	jmp `inc2_next

&X bltu1
``:
	jsr `cmp1
	bcc `jump
	jmp `inc2_next

&X bgeu1
``:
	jsr `cmp1
	bcs `jump
	jmp `inc2_next

&X blts1
``:
	jsr `cmp1
	bvc *+4
	eor #$80
	bmi `jump
	jmp `inc2_next

&X bges1
``:
	jsr `cmp1
	bvc *+4
	eor #$80
	bpl `jump
	jmp `inc2_next

&X cmpe2
``:
	dex
	dex
	dex
	dex
	lda stack+0,x
	cmp stack+2,x
	bne +
	lda stack+1,x
	cmp stack+3,x
+
	rts

&X cmpm2
``:
	dex
	dex
	dex
	dex
	lda stack+0,x
	cmp stack+2,x
	lda stack+1,x
	sbc stack+3,x
	rts

&X beq2
``:
	jsr `cmpe2
	beq `jump
	jmp `inc2_next

&X bne2
``:
	jsr `cmpe2
	bne `jump
	jmp `inc2_next

&X bltu2
``:
	jsr `cmpm2
	bcc `jump
	jmp `inc2_next

&X bgeu2
``:
	jsr `cmpm2
	bcs `jump
	jmp `inc2_next

&X blts2
``:
	jsr `cmpm2
	bvc *+4
	eor #$80
	bmi `jump
	jmp `inc2_next

&X bges2
``:
	jsr `cmpm2
	bvc *+4
	eor #$80
	bpl `jump
	jmp `inc2_next

&X cmpe4
``:
	txa
	sec
	sbc #8
	tax
	lda stack+0,x
	cmp stack+4,x
	bne +
	lda stack+1,x
	cmp stack+5,x
	bne +
	lda stack+2,x
	cmp stack+6,x
	bne +
	lda stack+3,x
	cmp stack+7,x
+
	rts

&X cmpm4
``:
	txa
	sec
	sbc #8
	tax
	lda stack+0,x
	cmp stack+4,x
	lda stack+1,x
	sbc stack+5,x
	lda stack+2,x
	sbc stack+6,x
	lda stack+3,x
	sbc stack+7,x
	rts

&X beq4
``:
	jsr `cmpe4
	beq `jump
	jmp `inc2_next

&X bne4
``:
	jsr `cmpe4
	bne `jump
	jmp `inc2_next

&X bltu4
``:
	jsr `cmpm4
	bcc `jump
	jmp `inc2_next

&X bgeu4
``:
	jsr `cmpm4
	bcs `jump
	jmp `inc2_next

&X blts4
``:
	jsr `cmpm4
	bvc *+4
	eor #$80
	bmi `jump
	jmp `inc2_next

&X bges4
``:
	jsr `cmpm4
	bvc *+4
	eor #$80
	bpl `jump
	jmp `inc2_next

# --- Case ------------------------------------------------------------------

# whencase compares the value in x+2 (which can be 1, 2 or 4 bytes) with a
# value inline in the instruction stream. If it does *not* match, it jumps.
# The instruction stream format is <address> <value>.

&X falsecase
``:
	ldy #1
	lda (ip),y
	pha
	dey
	lda (ip),y
	sta ip+0
	pla
	sta ip+1
	jmp `next

&X whencase1
``:
	ldy #2
	lda x+2
	cmp (ip),y
	bne `falsecase
	
	lda #3
	jmp `inc_next

&X whencase2
``:
	ldy #2
	lda x+2
	cmp (ip),y
	bne `falsecase
	iny
	lda x+3
	cmp (ip),y
	bne `falsecase
	
	jmp `inc4_next

&X whencase4
``:
	ldy #2
	lda x+2
	cmp (ip),y
	bne `falsecase
	iny
	lda x+3
	cmp (ip),y
	bne `falsecase
	iny
	lda x+4
	cmp (ip),y
	bne `falsecase
	iny
	lda x+5
	cmp (ip),y
	bne `falsecase
	
	lda #6
	jmp `inc_next

# --- Interpreter -----------------------------------------------------------

&X next
``:
next:
	ldy #0
	lda (ip),y
	sta w+0

	inc ip+0
	bne +
	inc ip+1
+
	lda (ip),y
	sta w+1

	inc ip+0
	bne +
	inc ip+1
+
	jmp (w)

&X enter
``:
enter:
	lda ip+0
	pha
	lda ip+1
	pha

	clc
	lda w+0
	adc #3			; skip over the jmp instruction
	sta ip+0
	lda w+1
	adc #0
	sta ip+1
	jmp `next

&X exit
``:
	pla
	sta ip+1
	pla
	sta ip+0
	jmp `next

&X asmstart
``:
	stx vsp
	jmp (ip)

&X asmend
``:
asmend:
	pla
	tax
	pla
	tay
	inx
	bne +
	iny
+
	stx ip+0
	sty ip+1
	ldx vsp
	jmp `next

# Increments ip by A and jumps to next (useful for words which consume bytes
# from the data stream).
&X inc_next
``:
	clc
	adc ip+0
	sta ip+0
	lda #0
	adc ip+1
	sta ip+1
	jmp `next

&X inc1_next
``:
	lda #1
	jmp `inc_next

&X inc2_next
``:
	lda #2
	jmp `inc_next

&X inc4_next
``:
	lda #4
	jmp `inc_next

# --- Push/pop words --------------------------------------------------------

&X push1
``:
	ldy #0
	lda (ip),y
	sta stack,x
	inx

	jmp `inc1_next

&X push1_m1
``:
	lda #$ff
	sta stack,x
	inx
	jmp `next

&X push1_0
``:
	lda #0
	sta stack,x
	inx
	jmp `next

&X push1_1
``:
	lda #1
	sta stack,x
	inx
	jmp `next

&X push2
``:
	ldy #0
	lda (ip),y
	sta stack+0,x
	iny
	lda (ip),y
	sta stack+1,x
	inx
	inx

	jmp `inc2_next

&X push2_m1
``:
	lda #$ff
	sta stack+0,x
	sta stack+1,x
	inx
	inx
	jmp `next

&X push2_0
``:
	lda #0
	sta stack+0,x
	sta stack+1,x
	inx
	inx
	jmp `next

&X push2_1
``:
	ldy #1
	sty stack+0,x
	dey
	sty stack+1,x
	inx
	inx
	jmp `next

&X push4
``:
	ldy #0
-
	lda (ip),y
	sta stack,x
	inx
	iny
	cpy #4
	bne -

	jmp `inc4_next

&X push4_m1
``:
	lda #$ff
	sta stack+0,x
	sta stack+1,x
	sta stack+2,x
	sta stack+3,x
	inx
	inx
	inx
	inx
	jmp `next

&X push4_0
``:
	lda #0
	sta stack+0,x
	sta stack+1,x
	sta stack+2,x
	sta stack+3,x
	inx
	inx
	inx
	inx
	jmp `next

&X push4_1
``:
	ldy #1
	sty stack+0,x
	dey
	sty stack+1,x
	sty stack+2,x
	sty stack+3,x
	inx
	inx
	inx
	inx
	jmp `next

&X drop1
``:
	dex
	jmp `next

&X drop2
``:
	dex
	dex
	jmp `next

&X drop4
``:
	dex
	dex
	dex
	dex
	jmp `next

# --- Indirect loads and stores ---------------------------------------------

# (value address -- ) or (address -- value).

&X load1
``:
	lda (stack-2,x)
	sta stack-2,x
	dex

	jmp `next

&X load2
``:
	lda stack-2,x
	sta x+0
	lda stack-1,x
	sta x+1

	ldy #0
	lda (x),y
	sta stack-2,x
	iny
	lda (x),y
	sta stack-1,x

	jmp `next

&X load4
``:
	lda stack-2,x
	sta x+0
	lda stack-1,x
	sta x+1
	dex
	dex

	ldy #0
-
	lda (x),y
	sta stack,x
	inx
	iny
	cpy #4
	bne -

	jmp `next

&X store1
``:
	lda stack-3,x
	sta (stack-2,x)
	dex
	dex
	dex

	jmp `next

&X store2
``:
	lda stack-2,x
	sta x+0
	lda stack-1,x
	sta x+1

	ldy #0
	lda stack-4,x
	sta (x),y
	lda stack-3,x
	iny
	sta (x),y

	dex
	dex
	dex
	dex

	jmp `next

&X store4
``:
	lda stack-2,x
	sta x+0
	lda stack-1,x
	sta x+1
	dex
	dex

	ldy #3
-
	dex
	lda stack,x
	sta (x),y
	dey
	bpl -

	jmp `next

# --- Direct loads and stores -----------------------------------------------

# These are (value -- ) or (-- value) with the address taken from the
# instruction stream.

# Fetches two bytes from ip into x. Doesn't advance ip.
&X fetch2
``:
	ldy #0
	lda (ip),y
	sta x+0
	iny
	lda (ip),y
	sta x+1
	rts

&X load1i
``:
	jsr `fetch2

	ldy #0
	lda (x), y
	sta stack,x
	inx

	jmp `inc2_next

&X load2i
``:
	jsr `fetch2
	ldy #0
-
	lda (x),y
	sta stack,x
	inx
	iny
	cpy #2
	bne -

	jmp `inc2_next

&X load4i
``:
	jsr `fetch2
	ldy #0
-
	lda (x),y
	sta stack,x
	inx
	iny
	cpy #4
	bne -

	jmp `inc2_next

&X store1i
``:
	jsr `fetch2
	lda stack-1,x
	ldy #0
	sta (x),y
	dex

	jmp `inc2_next

&X store2i
``:
	jsr `fetch2
	ldy #1
-
	lda stack-1,x
	dex
	sta (x),y
	dey
	bpl -

	jmp `inc2_next

&X store4i
``:
	jsr `fetch2
	ldy #3
-
	lda stack-1,x
	dex
	sta (x),y
	dey
	bpl -

	jmp `inc2_next

# --- Direct maths ----------------------------------------------------------

# These operate on TOS and take the RHS from the instruction stream.

&X add1i
``:
	ldy #0
	clc
	lda stack-1,x
	adc (ip),y
	sta stack-1,x

	jmp `inc1_next

&X add2i
``:
	ldy #0
	clc
	lda stack-2,x
	adc (ip),y
	sta stack-2,x
	iny
	lda stack-1,x
	adc (ip),y
	sta stack-1,x

	jmp `inc2_next

&X add4i
``:
	ldy #0
	clc
	lda stack-4,x
	adc (ip),y
	sta stack-4,x
	iny
	lda stack-3,x
	adc (ip),y
	sta stack-3,x
	iny
	lda stack-2,x
	adc (ip),y
	sta stack-2,x
	iny
	lda stack-1,x
	adc (ip),y
	sta stack-1,x

	jmp `inc4_next

&X sub1i
``:
	ldy #0
	sec
	lda stack-1,x
	sbc (ip),y
	sta stack-1,x

	jmp `inc1_next

&X sub2i
``:
	ldy #0
	sec
	lda stack-2,x
	sbc (ip),y
	sta stack-2,x
	iny
	lda stack-1,x
	sbc (ip),y
	sta stack-1,x

	jmp `inc2_next

&X sub4i
``:
	ldy #0
	sec
	lda stack-4,x
	sbc (ip),y
	sta stack-4,x
	iny
	lda stack-3,x
	sbc (ip),y
	sta stack-3,x
	iny
	lda stack-2,x
	sbc (ip),y
	sta stack-2,x
	iny
	lda stack-1,x
	sbc (ip),y
	sta stack-1,x

	jmp `inc4_next

# --- Maths -----------------------------------------------------------------

&X add1
``:
	clc
	lda stack-2,x
	adc stack-1,x
	sta stack-2,x
	dex

	jmp `next

&X add2
``:
	clc
	lda stack-4,x
	adc stack-2,x
	sta stack-4,x
	lda stack-3,x
	adc stack-1,x
	sta stack-3,x
	dex
	dex

	jmp `next

&X add4
``:
	clc
	lda stack-8,x
	adc stack-4,x
	sta stack-8,x
	lda stack-7,x
	adc stack-3,x
	sta stack-7,x
	lda stack-6,x
	adc stack-2,x
	sta stack-6,x
	lda stack-5,x
	adc stack-1,x
	sta stack-5,x
	dex
	dex
	dex
	dex

	jmp `next

&X sub1
``:
	sec
	lda stack-2,x
	sbc stack-1,x
	sta stack-2,x
	dex

	jmp `next

&X sub2
``:
	sec
	lda stack-4,x
	sbc stack-2,x
	sta stack-4,x
	lda stack-3,x
	sbc stack-1,x
	sta stack-3,x
	dex
	dex

	jmp `next

&X sub4
``:
	sec
	lda stack-8,x
	sbc stack-4,x
	sta stack-8,x
	lda stack-7,x
	sbc stack-3,x
	sta stack-7,x
	lda stack-6,x
	sbc stack-2,x
	sta stack-6,x
	lda stack-5,x
	sbc stack-1,x
	sta stack-5,x
	dex
	dex
	dex
	dex

	jmp `next

&X or1
``:
	lda stack-2,x
	ora stack-1,x
	sta stack-2,x
	dex

	jmp `next

&X or2
``:
	lda stack-4,x
	ora stack-2,x
	sta stack-4,x
	lda stack-3,x
	ora stack-1,x
	sta stack-3,x
	dex
	dex

	jmp `next

&X or4
``:
	lda stack-8,x
	ora stack-4,x
	sta stack-8,x
	lda stack-7,x
	ora stack-3,x
	sta stack-7,x
	lda stack-6,x
	ora stack-2,x
	sta stack-6,x
	lda stack-5,x
	ora stack-1,x
	sta stack-5,x
	dex
	dex
	dex
	dex

	jmp `next

&X and1
``:
	lda stack-2,x
	and stack-1,x
	sta stack-2,x
	dex

	jmp `next

&X and2
``:
	lda stack-4,x
	and stack-2,x
	sta stack-4,x
	lda stack-3,x
	and stack-1,x
	sta stack-3,x
	dex
	dex

	jmp `next

&X and4
``:
	lda stack-8,x
	and stack-4,x
	sta stack-8,x
	lda stack-7,x
	and stack-3,x
	sta stack-7,x
	lda stack-6,x
	and stack-2,x
	sta stack-6,x
	lda stack-5,x
	and stack-1,x
	sta stack-5,x
	dex
	dex
	dex
	dex

	jmp `next

&X eor1
``:
	lda stack-2,x
	eor stack-1,x
	sta stack-2,x
	dex

	jmp `next

&X eor2
``:
	lda stack-4,x
	eor stack-2,x
	sta stack-4,x
	lda stack-3,x
	eor stack-1,x
	sta stack-3,x
	dex
	dex

	jmp `next

&X eor4
``:
	lda stack-8,x
	eor stack-4,x
	sta stack-8,x
	lda stack-7,x
	eor stack-3,x
	sta stack-7,x
	lda stack-6,x
	eor stack-2,x
	sta stack-6,x
	lda stack-5,x
	eor stack-1,x
	sta stack-5,x
	dex
	dex
	dex
	dex

	jmp `next

&X negtos1
``:
	sec
	lda #0
	sbc stack-1,x
	sta stack-1,x
	rts

&X negtos2
``:
	sec
	lda #0
	sbc stack-2,x
	sta stack-2,x
	lda #0
	sbc stack-1,x
	sta stack-1,x
	rts

&X negtos4
``:
	sec
	lda #0
	sbc stack-4,x
	sta stack-4,x
	lda #0
	sbc stack-3,x
	sta stack-3,x
	lda #0
	sbc stack-2,x
	sta stack-2,x
	lda #0
	sbc stack-1,x
	sta stack-1,x
	rts

&X neg1
``:
	jsr `negtos1
	jmp `next

&X neg2
``:
	jsr `negtos2
	jmp `next

&X neg4
``:
	jsr `negtos4
	jmp `next

&X not1
``:
	lda stack-1,x
	eor #$ff
	sta stack-1,x

	jmp `next

&X not2
``:
	lda stack-2,x
	eor #$ff
	sta stack-2,x
	lda stack-1,x
	eor #$ff
	sta stack-1,x

	jmp `next

&X not4
``:
	lda stack-4,x
	eor #$ff
	sta stack-4,x
	lda stack-3,x
	eor #$ff
	sta stack-3,x
	lda stack-2,x
	eor #$ff
	sta stack-2,x
	lda stack-1,x
	eor #$ff
	sta stack-1,x

	jmp `next

# --- Multiplication --------------------------------------------------------

&X mul1
``:
    lda #0
    ldy #8
	lsr stack-2,x
-
    bcc +
    clc
    adc stack-1,x
+
    ror
    ror stack-2,x
    dey
    bne -
    lda stack-2,x

	dex
    jmp `next
	
&X mul2
``:
	lda #0			; low byte of high word
	sta x+0			; high byte of high word
	ldy #$11
	clc
-
	ror x+0
	ror
	ror stack-3,x
	ror stack-4,x
	bcc +
	clc
	adc stack-2,x
	pha
	lda stack-1,x
	adc x+0
	sta x+0
	pla
+
	dey
	bne -

	dex
	dex
	jmp `next

&X mul4
``:
	lda #0
	sta x+0				; high word of result
	sta x+1
	sta x+2
	sta x+3

	clc
	ldy #$21			; bit counter
-
	ror x+3
	ror x+2
	ror x+1
	ror x+0
	ror stack-5,x
	ror stack-6,x
	ror stack-7,x
	ror stack-8,x
	bcc +

	clc					; add rhs to high half of result
	lda x+0
	adc stack-4,x
	sta x+0
	lda x+1
	adc stack-3,x
	sta x+1
	lda x+2
	adc stack-2,x
	sta x+2
	lda x+3
	adc stack-1,x
	sta x+3
+
	dey
	bne -

	dex
	dex
	dex
	dex
	jmp `next
	
# --- Division (unsigned) ---------------------------------------------------

# divrem does: (lhs rhs -- result) and leaves the remainder in x.

&X divremu1
``:
    lda #0
    ldy #8
    asl stack-2,x
-
    rol
    cmp stack-1,x
    bcc +
    sbc stack-1,x
+
    rol stack-2,x
    dey
    bne -

	sta x
	dex
	rts

&X divu1
``:
	jsr `divremu1
	jmp `next

&X remu1
``:
	jsr `divremu1
	lda x
	sta stack-1,x
	jmp `next

&X divremu2
``:
	lda #0
	sta x+0
	sta x+1
	ldy #16
-
	asl stack-4,x
	rol stack-3,x
	rol x+0
	rol x+1

	lda x+0
	sec
	sbc stack-2,x
	sta x+2
	lda x+1
	sbc stack-1,x
	bcc +

	sta x+1
	lda x+2
	sta x+0
	inc stack-4,x
+

	dey
	bne -

	dex
	dex
	rts

&X divu2
``:
	jsr `divremu2
	jmp `next

&X remu2
``:
	jsr `divremu2
	lda x+0
	sta stack-2,x
	lda x+1
	sta stack-1,x
	jmp `next

&X divremu4
``:
	lda #0
	sta x+0
	sta x+1
	sta x+2
	sta x+3
	ldy #32
-
	asl stack-8,x		; left shift result
	rol stack-7,x
	rol stack-6,x
	rol stack-5,x
	rol x+0				; and remainder
	rol x+1
	rol x+2
	rol x+3

	lda x+0				; if remainder < lhs
	cmp stack-4,x
	lda x+1
	sbc stack-3,x
	lda x+2
	sbc stack-2,x
	lda x+3
	sbc stack-1,x
	bcc +
	; (carry is clear here)

	lda x+0				; remainder := remainder - lhs
	sbc stack-4,x
	sta x+0
	lda x+1
	sbc stack-3,x
	sta x+1
	lda x+2
	sbc stack-2,x
	sta x+2
	lda x+3
	sbc stack-1,x
	sta x+3
	inc stack-8,x
+
	dey
	bne -

	dex
	dex
	dex
	dex
	rts

&X divu4
``:
	jsr `divremu4
	jmp `next

&X remu4
``:
	jsr `divremu4
	lda x+0
	sta stack-4,x
	lda x+1
	sta stack-3,x
	lda x+2
	sta stack-2,x
	lda x+3
	sta stack-1,x
	jmp `next

# --- Signed division -------------------------------------------------------

&X divrems1
``:
	lda stack-2,x
	eor stack-1,x		; determine sign of result
	php					; save result sign for later
	lda stack-2,x
	php					; save remainder sign for later

	bpl +				; negate LHS if negative
	lda #0
	sec
	sbc stack-2,x
	sta stack-2,x
+
	lda stack-1,x		; negate RHS is negative
	bpl +
	lda #0
	sec
	sbc stack-1,x
	sta stack-1,x
+
	jsr `divremu1		; actually do the division (and adjust stack)

	plp					; get sign of remainder
	bpl +				; negate remainder if necessary
	lda #0
	sec
	sbc x+0
	sta x+0
+
	plp					; get sign of result
	bpl +				; negate result if necessary
	lda #0
	sec
	sbc stack-1,x
	sta stack-1,x
+
	rts

&X divs1
``:
	jsr `divrems1
	jmp `next

&X rems1
``:
	jsr `divrems1
	lda x
	sta stack-1,x
	jmp `next

&X divrems2
``:
	lda stack-3,x
	eor stack-1,x		; determine sign of result
	php					; save result sign for later
	lda stack-3,x
	php					; save remainder sign for later

	bpl +				; negate LHS if negative
	dex
	dex
	jsr `negtos2		; code reuse!
	inx
	inx
+
	lda stack-1,x		; negate RHS if negative
	bpl +
	jsr `negtos2
+
	jsr `divremu2		; actually do the division (and adjust stack)

	plp					; get sign of remainder
	bpl +				; negate remainder if necessary
	sec
	lda #0
	sbc x+0
	sta x+0
	lda #0
	sbc x+1
	sta x+1
+
	plp					; get sign of result
	bpl +				; negate result if necessary
	jsr `negtos2
+
	rts

&X divs2
``:
	jsr `divrems2
	jmp `next

&X rems2
``:
	jsr `divrems2
	lda x+0
	sta stack-2,x
	lda x+1
	sta stack-1,x
	jmp `next

&X divrems4
``:
	lda stack-5,x
	eor stack-1,x		; determine sign of result
	php					; save result sign for later
	lda stack-5,x
	php					; save remainder sign for later

	bpl +				; negate LHS if negative
	dex
	dex
	dex
	dex
	jsr `negtos4		; code reuse!
	inx
	inx
	inx
	inx
+
	lda stack-1,x		; negate RHS is negative
	bpl +
	jsr `negtos4
+
	jsr `divremu4		; actually do the division (and adjust stack)

	plp					; get sign of remainder
	bpl +				; negate remainder if necessary
	sec
	lda #0
	sbc x+0
	sta x+0
	lda #0
	sbc x+1
	sta x+1
	lda #0
	sbc x+2
	sta x+2
	lda #0
	sbc x+3
	sta x+3
+
	plp					; get sign of result
	bpl +				; negate result if necessary
	jsr `negtos4
+
	rts

&X divs4
``:
	jsr `divrems4
	jmp `next

&X rems4
``:
	jsr `divrems4
	lda x+0
	sta stack-4,x
	lda x+1
	sta stack-3,x
	lda x+2
	sta stack-2,x
	lda x+3
	sta stack-1,x
	jmp `next

# --- Casts -----------------------------------------------------------------

&X cast21
``:
	dex
	jmp `next

&X cast41
``:
	dex
	dex
	dex
	jmp `next

&X cast42
``:
	dex
	dex
	jmp `next

&X cast12u
``:
	lda #0
	sta stack,x
	inx

	jmp `next

&X cast14u
``:
	lda #0
	sta stack,x
	inx
	sta stack,x
	inx
	sta stack,x
	inx

	jmp `next

&X cast24u
``:
	lda #0
	sta stack,x
	inx
	sta stack,x
	inx

	jmp `next

&X cast12s
``:
	lda stack-1,x
	ora #$7f
	bmi *+4
	lda #0
	
	sta stack,x
	inx

	jmp `next

&X cast14s
``:
	lda stack-1,x
	ora #$7f
	bmi *+4
	lda #0

	sta stack,x
	inx
	sta stack,x
	inx
	sta stack,x
	inx

	jmp `next

&X cast24s
``:
	lda stack-1,x
	ora #$7f
	bmi *+4
	lda #0

	sta stack,x
	inx
	sta stack,x
	inx

	jmp `next

# --- Shifts ----------------------------------------------------------------

# (value shift8 -- value)

&X lshift1
``:
	lda stack-1,x
	tay
	dex

	jmp +
-
	asl stack-1,x
+
	dey
	bpl -
	jmp `next

&X lshift2
``:
	lda stack-1,x
	tay
	dex

	jmp +
-
	asl stack-2,x
	rol stack-1,x
+
	dey
	bpl -

	jmp `next

&X lshift4
``:
	lda stack-1,x
	tay
	dex

	jmp +
-
	asl stack-4,x
	rol stack-3,x
	rol stack-2,x
	rol stack-1,x
+
	dey
	bpl -

	jmp `next

&X rshiftu1
``:
	lda stack-1,x
	tay
	dex

	jmp +
-
	lsr stack-1,x
+
	dey
	bpl -

	jmp `next

&X rshiftu2
``:
	lda stack-1,x
	tay
	dex

	jmp +
-
	lsr stack-1,x
	ror stack-2,x
+
	dey
	bpl -

	jmp `next

&X rshiftu4
``:
	lda stack-1,x
	tay
	dex

	jmp +
-
	lsr stack-1,x
	ror stack-2,x
	ror stack-3,x
	ror stack-4,x
+
	dey
	bpl -

	jmp `next


&X rshifts1
``:
	lda stack-1,x
	tay
	dex

	jmp +
-
	lda stack-1,x
	rol
	ror stack-1,x
+
	dey
	bpl -

	jmp `next

&X rshifts2
``:
	lda stack-1,x
	tay
	dex

	jmp +
-
	lda stack-1,x
	rol
	ror stack-1,x
	ror stack-2,x
+
	dey
	bpl -

	jmp `next

&X rshifts4
``:
	lda stack-1,x
	tay
	dex

	jmp +
-
	lda stack-1,x
	rol
	ror stack-1,x
	ror stack-2,x
	ror stack-3,x
	ror stack-4,x
+
	dey
	bpl -

	jmp `next

# --- Indexed loads and stores ----------------------------------------------

# These do (value address -- ) or (address -- value) but with an additional
# 16-bit offset read from the instruction stream.

&X addconstant2
``:
	ldy #0
	clc
	lda (ip),y
	adc stack-2,x
	sta stack-2,x
	iny
	lda (ip),y
	adc stack-2,x
	sta stack-2,x

	clc
	lda ip+0
	adc #2
	sta ip+0
	bcc +
	inc ip+1
+
	rts

&X load1x
``:
	jsr `addconstant2
	jmp `load1

&X load2x
``:
	jsr `addconstant2
	jmp `load2

&X load4x
``:
	jsr `addconstant2
	jmp `load4

&X store1x
``:
	jsr `addconstant2
	jmp `store1

&X store2x
``:
	jsr `addconstant2
	jmp `store2

&X store4x
``:
	jsr `addconstant2
	jmp `store4


