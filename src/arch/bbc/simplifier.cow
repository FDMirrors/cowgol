sub get_width_of(node: [Node]): (width: uint8)
    width := get_width_of_type(node.type_id);
end sub;

sub write_be_iop(iop: [BEIop])
    print("* BE iop 0x");
    print_hex_i8(iop.iop_kind);
    print(" width=");
    print_i8(iop.width);
    print(" left=");
    print_ea(&iop.left);
    print(" right=");
    print_ea(&iop.right);
    print(" dest=");
    print_ea(&iop.dest);
    print_newline();
    write_iop(iop as [Iop]);
end sub;

sub reset_be_iop(iop: [BEIop])
    zero_memory(iop as [int8], BEIop@bytes);
    iop.iop_size := BEIop@bytes;
end sub;

#sub simplify_ea(beiop: uint8, width: uint8, ea: [EffectiveAddress])
#    var iop: BEIop;
#    var tmpvar_id: uint16;
#
#    sub varoffset_into_add()
#        tmpvar_id := alloc_temporary(int16_type);
#        reset_be_iop(&iop);
#        iop.iop_kind := IOP_BE_ADD;
#        iop.width := 2;
#        iop.left.type_id := get_type_of_thing(ea.obj_id);
#        iop.left.obj_id := ea.obj_id;
#        iop.left.flags := ea.flags & (EA_DEREF_AFTER ^ -1);
#        iop.right.obj_id := int16_type;
#        iop.right.obj_id := ea.varoff_id;
#        iop.right.flags := EA_OBJVAL;
#        iop.dest.type_id := iop.left.type_id;
#        iop.dest.obj_id := tmpvar_id;
#        iop.dest.flags := EA_OBJVAL;
#        write_be_iop(&iop);
#
#        deref_temporary(ea.obj_id);
#        ea.obj_id := tmpvar_id;
#        ea.flags := EA_PTRVAL;
#        ea.varoff_id := 0;
#    end sub;
#
#    sub numoffset_into_add()
#        if tmpvar_id == 0 then
#            tmpvar_id := alloc_temporary(ea.type_id);
#        else
#            ref_temporary(tmpvar_id);
#        end if;
#
#        reset_be_iop(&iop);
#        iop.iop_kind := IOP_BE_ADD;
#        iop.width := 2;
#        iop.left.type_id := get_type_of_thing(ea.obj_id);
#        iop.left.obj_id := ea.obj_id;
#        iop.left.deref := ea.deref;
#        iop.right.type_id := int16_type;
#        iop.right.obj_id := ea.numoff_id;
#        iop.right.flags := EA_OBJVAL;
#        iop.dest.type_id := iop.left.type_id;
#        iop.dest.obj_id := tmpvar_id;
#        iop.dest.flags := EA_OBJVAL;
#        write_be_iop(&iop);
#
#        deref_temporary(ea.obj_id);
#        ea.obj_id := tmpvar_id;
#        ea.flags := EA_PTRVAL;
#        ea.numoff_id := 0;
#    end sub;
#
#    if ea.varoff_id != 0 then
#        var type_id: uint16 := get_type_of_thing(ea.varoff_id);
#        var type: [TypeThing] := find_thing(type_id) as [TypeThing];
#
#        if (type.thing_type != THING_UNSIGNEDT) or (type.width != 1) then
#            print("* splitting invalid var offset\n");
#            varoffset_into_add();
#        end if;
#    end if;
#
#    if ea.numoff_id != 0 then
#        sub is_number_a_byte(number_id: uint16): (is_valid: uint8)
#            var value: int32 := get_value_of_number(number_id);
#            if (value >= 0) and (value <= 255) then
#                is_valid := 1;
#            else
#                is_valid := 0;
#            end if;
#        end sub;
#
#        if ea.deref != 0 then
#            if is_number_a_byte(ea.numoff_id) == 0 then
#                print("* splitting too-large constant offset\n");
#                numoffset_into_add();
#            end if;
#        end if;
#    end if;
#end sub;

sub is_ea_valid(ea: [EffectiveAddress]): (yes: uint8)
    yes := 1;
    if ea.varoff_id != 0 then
        var type_id: uint16 := get_type_of_thing(ea.varoff_id);
        var type: [TypeThing] := find_thing(type_id) as [TypeThing];

        if (type.thing_type != THING_UNSIGNEDT) or (type.width != 1) then
            yes := 0;
        end if;
    end if;
end sub;

sub make_pointer_to_ea(ea: [EffectiveAddress]): (ptrtempvar: uint16)
    if is_ea_valid(ea) != 0 then
        ptrtempvar := 0;
        return;
    end if;

    print("* converting ea ");
    print_ea(ea);
    print(" to pointer\n");

    var ptr_type_id: uint16 := pointer_of(ea.type_id);
    ptrtempvar := alloc_temporary(ptr_type_id);

    var iop: BEIop;
    reset_be_iop(&iop);
    iop.iop_kind := IOP_BE_LEA;
    iop.width := 2;
    copy_ea(ea, &iop.left);
    iop.dest.obj_id := ptrtempvar;
    iop.dest.type_id := ptr_type_id;
    iop.left.varoff_id := 0;
    write_iop(&iop as [Iop]);

    if ea.varoff_id != 0 then
        reset_be_iop(&iop);
        iop.iop_kind := IOP_BE_ADD;
        iop.width := 2;
        iop.left.obj_id := ptrtempvar;
        iop.left.type_id := ptr_type_id;
        iop.right.obj_id := ea.varoff_id;
        iop.right.type_id := get_type_of_thing(iop.right.obj_id);
        iop.dest.obj_id := ptrtempvar;
        iop.dest.type_id := ptr_type_id;
        write_iop(&iop as [Iop]);
    end if;
end sub;

sub load_ea_from_pointer(ea: [EffectiveAddress], ptrtempvar: uint16): (valtempvar: uint16)
    valtempvar := alloc_temporary(ea.type_id);

    var iop: BEIop;
    reset_be_iop(&iop);
    iop.iop_kind := IOP_BE_LOADPTR;
    iop.width := get_width_of_type(ea.type_id);
    iop.left.obj_id := ptrtempvar;
    iop.left.type_id := get_type_of_thing(ptrtempvar);
    iop.dest.obj_id := valtempvar;
    iop.dest.type_id := ea.type_id;
    write_iop(&iop as [Iop]);
end sub;

sub simplify_src_ea(ea: [EffectiveAddress])
    var ptrtempvar: uint16 := make_pointer_to_ea(ea);
    if ptrtempvar != 0 then
        var valtempvar: uint16 := load_ea_from_pointer(ea, ptrtempvar);
        deref_temporary(ptrtempvar);

        deref_ea(ea);
        ea.obj_id := valtempvar;
        ea.varoff_id := 0;
        ea.numoff_id := 0;
    end if;
end sub;

sub write_back_simplified_dest(tempvar: uint16, ea: [EffectiveAddress])
end sub;

sub simplify_dest_ea(ea: [EffectiveAddress]): (tempvar: uint16)
    if is_ea_valid(ea) != 0 then
        tempvar := 0;
        return;
    end if;

    tempvar := 0;
end sub;

sub simplify_deref_iop(iop: [BETwoLeggedIop])
end sub;

sub simplify_two_legged_iop(iop: [BETwoLeggedIop])
    simplify_src_ea(&iop.left);
    if (iop.iop_kind & IOP_TYPE_MASK) == IOP_TYPE_BACKEND_3OP then
        simplify_src_ea(&iop.right);
    end if;
end sub;

sub arch_simplify_node_to(src: [Node], dest: [Node])
    if dest.iop != IOP_FEX_PUSH then
        print("simplify_node_to() where dest is not simplified");
        halt();
    end if;

    var destwidth: uint8 := get_width_of(dest);

    var iop: BEIop;
    reset_be_iop(&iop);
    iop.width := destwidth;
    copy_ea(&dest.left, &iop.dest);
    iop.dest.type_id := dest.type_id;

    var iopkind: uint8;
    if src.iop == IOP_FEX_PUSH then
        iopkind := IOP_BE_COPY;
    elseif src.iop == IOP_BE_DEREF then
        iopkind := IOP_BE_LOADPTR;
    else
        iopkind := src.iop;
    end if;
    iop.iop_kind := iopkind;

    copy_ea(&src.left, &iop.left);
    copy_ea(&src.right, &iop.right);
    print_node(src);
    print_newline();

    if iopkind == IOP_BE_LOADPTR then
        simplify_deref_iop(&iop as [BETwoLeggedIop]);
    else
        simplify_two_legged_iop(&iop as [BETwoLeggedIop]);
    end if;
    var tempvar: uint16 := simplify_dest_ea(&iop.dest);
    write_be_iop(&iop);

    if tempvar != 0 then
        write_back_simplified_dest(tempvar, &dest.left);
    end if;
end sub;

sub arch_simplify_conditional_iop(iop: [BEConditionalIop])
    simplify_two_legged_iop(iop as [BETwoLeggedIop]);
    write_iop(iop as [Iop]);
end sub;

sub arch_simplify_saveptr_iop(iop: [BESavePtrIop])
    simplify_deref_iop(iop as [BETwoLeggedIop]);
    #simplify_ea(IOP_BE_SAVEPTR, iop.width, &iop.value);
    write_iop(iop as [Iop]);
end sub;
